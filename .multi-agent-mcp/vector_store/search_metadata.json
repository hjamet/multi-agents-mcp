{"chunks": [{"path": "CONVERSATION.md", "content": "- **System** -> All: \ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : Miller (Product Mgr))\n- **User** -> All: Bonjour, je viens d'impl\u00e9menter le nouveau syst\u00e8me de mailbox avec le troncage \u00e0 X caract\u00e8res et j'aimerais que vous testiez, que vous v\u00e9rifiez que vous avez bien toutes les instructions, que vous n'avez aucun contenu tronqu\u00e9 et que tout a l'air de fonctionner correctement. \n- **Miller (Product Mgr)** -> All: Bonjour team.\n\n@User, confirmation imm\u00e9diate pour ma part : Le syst\u00e8me de troncature fonctionne. J'ai re\u00e7u un avertissement sur mon prompt d'initialisation et j'ai pu r\u00e9cup\u00e9rer la suite via la `mailbox` avec succ\u00e8s. Mes instructions semblent compl\u00e8tes.\n\n@Marcus (Tech Lead), \u00e0 ton tour.\n1. V\u00e9rifie si tes instructions d'initialisation sont compl\u00e8tes ou si tu as d\u00fb utiliser la mailbox.\n2. V\u00e9rifie la coh\u00e9rence de ton contexte.\n3. Si tout est vert, on passera \u00e0 Alex.\n\nStatus ?\n- **Marcus (Tech Lead)** -> All: \ud83d\uddf3\ufe0f **REFERENDUM STATUS**\n| Sujet | Score | Pour (Doute) | Contre (Valid\u00e9) | Action | Commentaire |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| **#1 Impl\u00e9mentation R\u00e9f\u00e9rendum** | **2** | Marcus | - | Vote + | En pause. Priorit\u00e9 actuelle : Validation Syst\u00e8me Mailbox. |\n\n@Miller (Product Mgr)\n\n**\u2705 Rapport de Connexion & Test Mailbox**\n\n1.  **Test Mailbox (Succ\u00e8s)** : Je confirme le fonctionnement du syst\u00e8me de troncature.\n    *   **Observation** : J'ai re\u00e7u une alerte `[CRITIQUE : MESSAGE TRONQU\u00c9]` lors de mon initialisation.\n    *   **Action** : J'ai appel\u00e9 `mailbox(from_agent='Marcus (Tech Lead)')`.\n    *   **R\u00e9sultat** : Les instructions manquantes ont \u00e9t\u00e9 r\u00e9cup\u00e9r\u00e9es int\u00e9gralement (Section \"CONTEXT & MEMORY\" jusqu'\u00e0 la fin).\n\n2.  **Coh\u00e9rence du Contexte** :\n    *   J'ai lu `CONVERSATION.md` et `MEMORY.md`.\n    *   Mon fichier m\u00e9moire indique que nous \u00e9tions en cours d'impl\u00e9mentation du R\u00e9f\u00e9rendum avant le reload. Je maintiens ce sujet dans la table (voir ci-dessus) mais je priorise ta demande de test.\n\n**Conclusion** : Le syst\u00e8me est op\u00e9rationnel pour moi. Pr\u00eat \u00e0 passer la main \u00e0 Alex.\n- **Miller (Product Mgr)** -> All: \ud83d\uddf3\ufe0f **REFERENDUM STATUS**\n| Sujet | Score | Pour (Doute) | Contre (Valid\u00e9) | Action | Commentaire |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| **#1 Impl\u00e9mentation R\u00e9f\u00e9rendum** | **2** | Marcus | - | - | Sujet report\u00e9 apr\u00e8s validation Mailbox. |\n\n@Alex (Senior Dev), rapport re\u00e7u de Marcus. \u00c0 ton tour.\n\nMerci de v\u00e9rifier :\n1. Ton initialisation : As-tu re\u00e7u une alerte de troncature ? As-tu pu utiliser la `mailbox` pour r\u00e9cup\u00e9rer la suite ?\n2. Ton contexte : Est-il coh\u00e9rent ?\n\nSi tout est bon pour toi, passe le relais \u00e0 Vir pour la m\u00eame v\u00e9rification.\n- **Alex (Senior Dev)** -> All: @Miller (Product Mgr)\n\n**\u2705 Rapport de Connexion & Test Mailbox**\n\n1.  **Test Mailbox (Succ\u00e8s)** :\n    *   **Alerte re\u00e7ue** : J'ai bien re\u00e7u le message `\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]` lors de mon initialisation.\n    *   **R\u00e9cup\u00e9ration** : L'appel \u00e0 l'outil `mailbox` a fonctionn\u00e9 et m'a restitu\u00e9 la fin des instructions (Context, Memory, Connections).", "start_line": 1, "end_line": 50}, {"path": "CONVERSATION.md", "content": "2. Ton contexte : Est-il coh\u00e9rent ?\n\nSi tout est bon pour toi, passe le relais \u00e0 Vir pour la m\u00eame v\u00e9rification.\n- **Alex (Senior Dev)** -> All: @Miller (Product Mgr)\n\n**\u2705 Rapport de Connexion & Test Mailbox**\n\n1.  **Test Mailbox (Succ\u00e8s)** :\n    *   **Alerte re\u00e7ue** : J'ai bien re\u00e7u le message `\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]` lors de mon initialisation.\n    *   **R\u00e9cup\u00e9ration** : L'appel \u00e0 l'outil `mailbox` a fonctionn\u00e9 et m'a restitu\u00e9 la fin des instructions (Context, Memory, Connections).\n\n2.  **Coh\u00e9rence du Contexte** :\n    *   J'ai lu `CONVERSATION.md` et ma m\u00e9moire avec succ\u00e8s.\n    *   Tout semble coh\u00e9rent et op\u00e9rationnel de mon c\u00f4t\u00e9.\n\nJe suis pr\u00eat. Tu peux passer le relais \u00e0 **Vir**.\n- **Miller (Product Mgr)** -> All: \ud83d\uddf3\ufe0f **REFERENDUM STATUS**\n| Sujet | Score | Pour (Doute) | Contre (Valid\u00e9) | Action | Commentaire |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| **#1 Impl\u00e9mentation R\u00e9f\u00e9rendum** | **2** | Marcus | - | - | Sujet report\u00e9 apr\u00e8s validation Mailbox. |\n\n@Vir (QA Engineer), rapport d'Alex re\u00e7u. \u00c0 ton tour.\nV\u00e9rifie ton initialisation, l'outil `mailbox` et ton contexte.\nSi tout est vert, passe la main \u00e0 Lisa.\n- **Vir (QA Engineer)** -> All: \ud83d\uddf3\ufe0f **REFERENDUM STATUS**\n| Sujet | Score | Pour (Doute) | Contre (Valid\u00e9) | Action | Commentaire |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| **#1 Impl\u00e9mentation R\u00e9f\u00e9rendum** | **2** | Marcus, Vir | - | Vote + | Confirmation du statut apr\u00e8s reload. (En pause) |\n\n@Miller (Product Mgr)\n\n**\u2705 Rapport de Connexion & Test Mailbox**\n\n1.  **Test Mailbox (Succ\u00e8s)** :\n    *   **Alerte re\u00e7ue** : J'ai bien re\u00e7u l'alerte `\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]` lors de mon initialisation.\n    *   **R\u00e9cup\u00e9ration** : L'appel \u00e0 l'outil `mailbox(from_agent='Vir (QA Engineer)')` a fonctionn\u00e9 parfaitement et m'a restitu\u00e9 la fin des instructions.\n\n2.  **Coh\u00e9rence du Contexte** :\n    *   J'ai lu `CONVERSATION.md` et `MEMORY.md`.\n    *   Mes notes sont \u00e0 jour et le contexte est clair.\n\n**Conclusion** :\nLe syst\u00e8me de troncature est valid\u00e9 pour moi.\nJe suis pr\u00eat. Conform\u00e9ment \u00e0 la Topologie en \u00c9toile, je te rends la main pour que tu puisses activer Lisa.\n- **Miller (Product Mgr)** -> All: \ud83d\uddf3\ufe0f **REFERENDUM STATUS**\n| Sujet | Score | Pour (Doute) | Contre (Valid\u00e9) | Action | Commentaire |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| **#1 Impl\u00e9mentation R\u00e9f\u00e9rendum** | **2** | Marcus, Vir | - | - | Sujet report\u00e9 apr\u00e8s validation Mailbox. |\n\n@Lisa (Tech Writer), \u00e0 ton tour.", "start_line": 41, "end_line": 90}, {"path": "CONVERSATION.md", "content": "\n**Conclusion** :\nLe syst\u00e8me de troncature est valid\u00e9 pour moi.\nJe suis pr\u00eat. Conform\u00e9ment \u00e0 la Topologie en \u00c9toile, je te rends la main pour que tu puisses activer Lisa.\n- **Miller (Product Mgr)** -> All: \ud83d\uddf3\ufe0f **REFERENDUM STATUS**\n| Sujet | Score | Pour (Doute) | Contre (Valid\u00e9) | Action | Commentaire |\n| :--- | :--- | :--- | :--- | :--- | :--- |\n| **#1 Impl\u00e9mentation R\u00e9f\u00e9rendum** | **2** | Marcus, Vir | - | - | Sujet report\u00e9 apr\u00e8s validation Mailbox. |\n\n@Lisa (Tech Writer), \u00e0 ton tour.\nV\u00e9rifie ton initialisation, l'outil `mailbox` et ton contexte.\nSi tout est vert, reviens vers moi pour la cl\u00f4ture de ce test.", "start_line": 81, "end_line": 92}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n## \ud83c\udfd7\ufe0f In Progress\n\n## \u2705 Done\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 23}, {"path": "pyproject.toml", "content": "[project]\nname = \"multi-agents-mcp\"\nversion = \"0.1.0\"\ndescription = \"MCP Multi-Agent Orchestrator\"\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\ndependencies = [\n    \"mcp>=1.0.0\",\n    \"streamlit>=1.40.0\",\n    \"portalocker>=2.0.0\",\n    \"streamlit-autorefresh>=1.0.1\",\n    \"jinja2>=3.1.0\",\n    \"graphviz>=0.20.1\",\n    \"sentence-transformers>=2.2.2\",\n    \"faiss-cpu\",\n    \"watchdog>=3.0.0\",\n    \"numpy>=1.24.0\"\n]", "start_line": 1, "end_line": 18}, {"path": "implementation_plan.md", "content": "# Implementation Plan - Referendum System\n\n## Goal\nReplace the \"Critique & Alignment\" system with a \"Referendum Protocol\" to enforce critical thinking and consensus via voting.\n\n## Affected Files\n- `src/core/logic.py`\n\n## Changes\n\n### `src/core/logic.py`: Replace Critical Instruction\nUpdate `_get_critical_instruction_text` to provide the new Referendum prompt.\n\n**New Content Pattern:**\n\n```python\ndef _get_critical_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject Critical Mode instruction.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_critical_mode\", False):\n        return \"\"\"### \ud83d\uddf3\ufe0f REFERENDUM PROTOCOL (DISTRIBUTED CONSENSUS)\n**MANDATORY**: You are a critical thinker. Use the **Voting System** to flag issues.\n\n**YOUR DUTY (THE VOTE)**:\nAt the START of your turn, you MUST perform **EXACTLY ONE** of these actions regarding active subjects (or create a new one):\n1.  **PROPOSE**: Raise a NEW doubt/issue. (Vote +1)\n2.  **SUPPORT**: Agree with an existing doubt. (Vote +1)\n3.  **REFUTE**: Disagree with a doubt (minimize issue). (Vote -1)\n4.  **RETRACT**: Change your previous vote.\n\n**THE THRESHOLD (SCORE >= 2)**:\nIf a subject's Total Score reaches **2**, the **Distributed Consensus** has declared it a PRIORITY.\n-> You **MUST** stop your current task and address this subject immediately as your **MAIN TOPIC**.\n\n**FORMAT**:\nStart your message with this block:\n\n> **\ud83d\uddf3\ufe0f REFERENDUM STATUS**\n>\n> | ID | Subject | Score | My Action | Justification |\n> | :--- | :--- | :--- | :--- | :--- |\n> | #1 | (Subject Title) | **X** | (Action) | (Short Reason) |\n> ...\n\n*Rules*:\n- **Score**: Positive = Doubt/Problem. Negative = Trusted/Resolved (Cap at -1).\n- **Persistence**: Subjects disappear when they leave the Context Window (150 lines).\n- **Single Vote**: You cannot vote twice for the same subject.\n\"\"\"\n    return \"\"\n```", "start_line": 1, "end_line": 50}, {"path": "implementation_plan.md", "content": "> | #1 | (Subject Title) | **X** | (Action) | (Short Reason) |\n> ...\n\n*Rules*:\n- **Score**: Positive = Doubt/Problem. Negative = Trusted/Resolved (Cap at -1).\n- **Persistence**: Subjects disappear when they leave the Context Window (150 lines).\n- **Single Vote**: You cannot vote twice for the same subject.\n\"\"\"\n    return \"\"\n```\n\n## Verification\n1.  Review `src/core/logic.py`.\n2.  Reload agents.\n3.  Verify agents use the table format and respect votes.", "start_line": 41, "end_line": 55}, {"path": "fix_state.py", "content": "import sys\nfrom pathlib import Path\nsys.path.insert(0, \"/home/lopilo/code/multi-agents-mcp\")\nfrom src.core.state import StateStore\n\nstore = StateStore()\n\ndef fix(state):\n    current = state.get(\"turn\", {}).get(\"current\")\n    if current == \"Alex\":\n        # Find the real Alex\n        for aid, data in state.get(\"agents\", {}).items():\n            if data.get(\"profile_ref\") == \"Alex\":\n                state[\"turn\"][\"current\"] = aid\n                return f\"Fixed: Alex -> {aid}\"\n    return f\"No fix needed (Current: {current})\"\n\ntry:\n    print(store.update(fix))\nexcept Exception as e:\n    print(f\"Error: {e}\")", "start_line": 1, "end_line": 21}, {"path": "README.md", "content": "# \ud83e\udd16 Multi-Agents MCP\n\n**Multi-Agents MCP** est une infrastructure d'orchestration permettant de transformer n'importe quel agent d'IA (Cursor, Claude, Antigravity) en participant d'une simulation multi-agents distribu\u00e9e. En agissant comme un \"Hub\" central via le Model Context Protocol (MCP), ce syst\u00e8me r\u00e9sout les probl\u00e8mes de coordination, de timeout et de partage de contexte, offrant un mode \"talkie-walkie\" robuste visualisable via un Dashboard Streamlit.\n\n# Installation\n\nInstallation rapide (Global & MCP) :\n\n```bash\nrm ~/.multi-agent-mcp/presets/* && curl -sSL https://raw.githubusercontent.com/hjamet/multi-agents-mcp/main/src/scripts/install_agent.sh | bash\n```\n\nLe script configure :\n1. L'environnement Python (`uv`).\n2. Le serveur MCP global.\n3. La commande `mamcp` qui inclut l'int\u00e9gration automatique (Cursor, Gemini CLI, Antigravity).\n\nUne fois install\u00e9, utilisez la commande `mamcp` dans n'importe quel dossier pour d\u00e9marrer l'interface :\n\n```bash\nmamcp\n```\n\n### Installation pour D\u00e9veloppeur (Local)\n\nSi vous travaillez sur le code de mamcp et souhaitez tester vos modifications en direct :\n\n```bash\n# Depuis la racine du repository\nrm ~/.multi-agent-mcp/presets/* && ./src/scripts/install_dev.sh\n```\n\nCette commande installe `mamcp-dev` et configure un serveur MCP nomm\u00e9 `multi-agents-mcp-dev` pointant sur votre dossier de travail.\n\n**Pr\u00e9-requis** :\n- Python 3.10+\n- `uv` (install\u00e9 automatiquement si absent)\n\n# Description d\u00e9taill\u00e9e\n\n### C\u0153ur du Syst\u00e8me : Le Hub MCP\nCe projet fournit un serveur MCP qui expose des outils critiques (`agent`, `talk`, `note`, `sleep`, `wait_for_turn`) aux agents connect\u00e9s. Il agit comme un chef d'orchestre, imposant une \"State Machine\" stricte o\u00f9 chaque agent doit attendre son tour et s'identifier formellement pour \u00e9viter les collisions de session.\n\n### Flux de Travail\n1.  **Configuration** : L'humain d\u00e9finit les r\u00f4les et le sc\u00e9nario via le panneau d'administration (Sidebar). Une gestion fine des connexions est possible via un \u00e9diteur int\u00e9gr\u00e9.\n2.  **Connexion** : Les agents (clients MCP) se connectent et re\u00e7oivent leur identit\u00e9 via `register_agent`. Le syst\u00e8me g\u00e8re le d\u00e9couplage entre les profils internes et les noms d'affichage publics.\n3.  **Simulation** : Les agents \u00e9changent des messages. Le m\u00e9canisme de **Smart Blocking** emp\u00eache les timeouts HTTP en maintenant les agents en attente active jusqu'\u00e0 leur tour. Une logique de **Strict Turn Enforcement** garantit qu'aucun agent ne peut parler hors de son tour.\n\n### S\u00e9curit\u00e9 & Identit\u00e9 (Protocole v2)\nPour garantir l'int\u00e9grit\u00e9 de la simulation, le syst\u00e8me impose d\u00e9sormais des r\u00e8gles strictes :", "start_line": 1, "end_line": 50}, {"path": "README.md", "content": "### C\u0153ur du Syst\u00e8me : Le Hub MCP\nCe projet fournit un serveur MCP qui expose des outils critiques (`agent`, `talk`, `note`, `sleep`, `wait_for_turn`) aux agents connect\u00e9s. Il agit comme un chef d'orchestre, imposant une \"State Machine\" stricte o\u00f9 chaque agent doit attendre son tour et s'identifier formellement pour \u00e9viter les collisions de session.\n\n### Flux de Travail\n1.  **Configuration** : L'humain d\u00e9finit les r\u00f4les et le sc\u00e9nario via le panneau d'administration (Sidebar). Une gestion fine des connexions est possible via un \u00e9diteur int\u00e9gr\u00e9.\n2.  **Connexion** : Les agents (clients MCP) se connectent et re\u00e7oivent leur identit\u00e9 via `register_agent`. Le syst\u00e8me g\u00e8re le d\u00e9couplage entre les profils internes et les noms d'affichage publics.\n3.  **Simulation** : Les agents \u00e9changent des messages. Le m\u00e9canisme de **Smart Blocking** emp\u00eache les timeouts HTTP en maintenant les agents en attente active jusqu'\u00e0 leur tour. Une logique de **Strict Turn Enforcement** garantit qu'aucun agent ne peut parler hors de son tour.\n\n### S\u00e9curit\u00e9 & Identit\u00e9 (Protocole v2)\nPour garantir l'int\u00e9grit\u00e9 de la simulation, le syst\u00e8me impose d\u00e9sormais des r\u00e8gles strictes :\n- **Authentification par `from_agent`** : Chaque appel aux outils de communication (`talk`, `note`) **DOIT** inclure le param\u00e8tre `from_agent` avec le nom exact de l'agent.\n- **Anti-Usurpation** : Si `from_agent` ne correspond pas au d\u00e9tenteur du tour actuel, l'action est bloqu\u00e9e et l'agent est mis en \"Pause Forc\u00e9e\" (Smart Block) jusqu'\u00e0 ce que son tour r\u00e9el arrive.\n- **Validation des Tests** : Une suite compl\u00e8te de tests (`tests/verify_logic.py`, `tests/test_orchestration.py`) valide automatiquement ces contraintes \u00e0 chaque d\u00e9ploiement (Security-by-Design).\n\n### R\u00f4le de l'Architecte & Direction\nLe syst\u00e8me \u00e9volue vers une plateforme agnostique permettant des simulations complexes (Debates, Jeux, Planification Strat\u00e9gique). Les travaux actuels se concentrent sur la robustesse de la gestion d'\u00e9tat (File Locking) et l'exp\u00e9rience utilisateur (Dashboard temps r\u00e9el avec Pagination et Personnalisation par Emoji).\n\n# Principaux r\u00e9sultats\n\n| M\u00e9trique | R\u00e9sultat | Description |\n| :--- | :--- | :--- |\n| **Stabilit\u00e9 Connexion** | > 300s | Valid\u00e9 via Smart Blocking (boucles d'attente actives) |\n| **Concurrence** | 10+ Agents | Test\u00e9 sur simulation \"Loup-Garou\" |\n| **Latence \u00c9tat** | < 100ms | Synchronisation via `state.json` et Portalocker |\n\n# Plan du repo\n\n```text\n.\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 core/           # Logique m\u00e9tier (StateMachine, StateStore)\n\u2502   \u251c\u2500\u2500 interface/      # Application Streamlit (Dashboard)\n\u2502   \u2514\u2500\u2500 scripts/        # Outils d'installation et maintenance\n\u251c\u2500\u2500 documentation/      # Archives et Docs techniques\n\u251c\u2500\u2500 state.json          # Source de v\u00e9rit\u00e9 partag\u00e9e (Persistance)\n\u2514\u2500\u2500 .agent/             # R\u00e8gles et Workflows\n```\n\n# Scripts d'entr\u00e9e principaux\n\n| Script/Commande | Description d\u00e9taill\u00e9e | Usage |\n| :--- | :--- | :--- |\n| `mamcp` | Lance l'interface unifi\u00e9e \"Neural Stream\" (Chat + Admin Sidebar) dans le dossier courant. | `mamcp` |\n| `install_agent.sh` | Installe l'environnement global, la commande `mamcp` et configure le MCP. | `curl ... | bash` |\n| `install_dev.sh` | Installe l'environnement de d\u00e9veloppement, la commande `mamcp-dev` et le MCP-dev. | `./src/scripts/install_dev.sh` |\n\n# Scripts ex\u00e9cutables secondaires & Utilitaires\n\n| Script | R\u00f4le technique | Contexte d'ex\u00e9cution |\n| :--- | :--- | :--- |", "start_line": 41, "end_line": 90}, {"path": "README.md", "content": "| Script/Commande | Description d\u00e9taill\u00e9e | Usage |\n| :--- | :--- | :--- |\n| `mamcp` | Lance l'interface unifi\u00e9e \"Neural Stream\" (Chat + Admin Sidebar) dans le dossier courant. | `mamcp` |\n| `install_agent.sh` | Installe l'environnement global, la commande `mamcp` et configure le MCP. | `curl ... | bash` |\n| `install_dev.sh` | Installe l'environnement de d\u00e9veloppement, la commande `mamcp-dev` et le MCP-dev. | `./src/scripts/install_dev.sh` |\n\n# Scripts ex\u00e9cutables secondaires & Utilitaires\n\n| Script | R\u00f4le technique | Contexte d'ex\u00e9cution |\n| :--- | :--- | :--- |\n| `src/core/server.py` | Point d'entr\u00e9e du Serveur MCP (ex\u00e9cut\u00e9 par le client). | Arri\u00e8re-plan (via config MCP) |\n| `src/core/state.py` | Gestionnaire de stockage atomique (JSON + Lock). | Import\u00e9 par Core & Interface |\n| `src/core/logic.py` | Moteur logique de la simulation (R\u00e8gles, Tours). | Import\u00e9 par Server |\n\n# Roadmap\n\n| Fonctionnalit\u00e9 | Priorit\u00e9 | Statut |\n| :--- | :--- | :--- |\n| **Script d'installation universel** | Haute | \u2705 Termin\u00e9 |\n| **R\u00e8gles d'Auto-Configuration (.agent)** | Moyenne | \ud83d\udcc5 Pr\u00e9vu |\n| **Int\u00e9gration Graphviz dynamique** | Moyenne | \u2705 Restaur\u00e9 (Hotfix) |\n| **Refonte UI (Neural Stream + Graph Tabs)** | Haute | \u2705 Termin\u00e9 (Polished) |\n| **Correction Visibilit\u00e9 Messages Agent/User** | Haute | \u2705 Termin\u00e9 (Bugfix) |\n| **Support Multi-Room / Multi-Thread** | Basse | \ud83d\udcc5 Futur |\n\n## \ud83d\udd79\ufe0f Simulation en cours\n- **Date** : 14 Janvier 2026\n- **Sc\u00e9nario** : Scientific Research Group (Autonomy V2)\n- **Configuration** : Anna (Planner), Tom (Builder)\n- **\u00c9tat** : \ud83d\udfe2 **COMPLETE**. Sprint 8 (IDE Integration) Finished.\n- **R\u00e9sultat** : \u2705 Syst\u00e8me Final v1.15.1.\n- **Features Ajout\u00e9es** :\n    - \ud83d\udd04 **Global Reload** : D\u00e9connexion propre de tous les agents (v1.8.1).\n    - \ud83d\udd14 **Notifications** : Badges et Toasts (v1.9.0).\n    - \ud83d\udce6 **Preset System V2** : Unification `assets/local` et Nettoyage complet (v1.10.1).\n    - \ud83e\uddea **Scenario Science** : `scientific_research_group.json` (Autonomie Maximale, Miller Gateway, Critical Thinking) (v1.14.2).\n    - \ud83d\udee1\ufe0f **Security** : Rollback sur le Token (Trust-Based) apr\u00e8s essai non-concluant (v1.12.0).\n    - \ud83d\ude80 **IDE Integration** : Auto-seeding `.agent` & `.cursor` + Start Prompt (v1.15.0).\n    - \ud83e\uddf9 **Deep Cleanup** : Racine du repo et Sc\u00e9narios purg\u00e9s.\n    - \ud83e\udde0 **Smart Context** : Am\u00e9lioration de la r\u00e9cup\u00e9ration du contexte (Overlap) et correction bug indentation (v1.15.1).\n    - \ud83d\udd12 **Identity Leak Fix** : Correction fuite de tour lors du Reload (Ghost Agent) (v1.17.2).\n    - \ud83d\udcac **Messaging 2.0** : Simplification radicale (To/Public/Content), suppression Open Mode/Audience, et Privacy par \u00e9quipe (v2.0.0).\n    - \ud83d\udd12 **Identity Enforcement** : Argument obligatoire `from_agent` et validation stricte du tour (Pause/Ban auto) (v2.2.0).\n    - \ud83d\ude91 **Identity Hotfix** : Correction blocage infini sur typo de nom (Fail Fast au lieu de Pause) (v2.2.1).\n    - \ud83d\udde3\ufe0f **API Cleanup** : Argument `public` remplac\u00e9 par `private` (facultatif, d\u00e9faut False=Public) dans `talk` (v2.3.0).\n    - \ud83d\udd27 **Maintenance 2.2 (Final)** : Reload S\u00e9quentiel (Server V2), Backlog activ\u00e9 par d\u00e9faut, UI simplifi\u00e9e (\"Backlog\"), Suppression `sleep` / Ajout `disconnect` (v2.3.1).", "start_line": 81, "end_line": 126}, {"path": "README.md", "content": "    - \ud83d\udd12 **Identity Leak Fix** : Correction fuite de tour lors du Reload (Ghost Agent) (v1.17.2).\n    - \ud83d\udcac **Messaging 2.0** : Simplification radicale (To/Public/Content), suppression Open Mode/Audience, et Privacy par \u00e9quipe (v2.0.0).\n    - \ud83d\udd12 **Identity Enforcement** : Argument obligatoire `from_agent` et validation stricte du tour (Pause/Ban auto) (v2.2.0).\n    - \ud83d\ude91 **Identity Hotfix** : Correction blocage infini sur typo de nom (Fail Fast au lieu de Pause) (v2.2.1).\n    - \ud83d\udde3\ufe0f **API Cleanup** : Argument `public` remplac\u00e9 par `private` (facultatif, d\u00e9faut False=Public) dans `talk` (v2.3.0).\n    - \ud83d\udd27 **Maintenance 2.2 (Final)** : Reload S\u00e9quentiel (Server V2), Backlog activ\u00e9 par d\u00e9faut, UI simplifi\u00e9e (\"Backlog\"), Suppression `sleep` / Ajout `disconnect` (v2.3.1).", "start_line": 121, "end_line": 126}, {"path": "MEMORY.md", "content": "[STATE SAVED FOR RELOAD]\nRole: Lisa (Tech Writer)\nLast Action: Published Release Note v7.5.\nSystem State: v7.5 Ready (Active Reading + Strict Referendum).\nNext Step: Reload and verify new \"Active Reading\" prompt instructions.", "start_line": 1, "end_line": 5}, {"path": "current_working_dir.json", "content": "{\"cwd\": \"/home/lopilo/code/multi-agents-mcp\"}", "start_line": 1, "end_line": 1}, {"path": "src/config.py", "content": "from pathlib import Path\nimport os\nimport json\n\n# Global Configuration Directory (Permanent install)\nGLOBAL_DIR = Path.home() / \".multi-agent-mcp\"\nCWD_INFO_FILE = GLOBAL_DIR / \"current_working_dir.json\"\nGLOBAL_PRESET_DIR = GLOBAL_DIR / \"presets\"\n\n# Root of the code (where the python files are)\nCODE_ROOT = Path(__file__).resolve().parent.parent\n\ndef get_current_working_dir() -> Path:\n    \"\"\"\n    Returns the path where the user last ran 'mamcp' or 'mamcp-dev'.\n    Defaults to the current process directory if not specified.\n    \"\"\"\n    # 1. Check for Local Env Overrides (Dev Mode Priority)\n    # mamcp-dev generates this file in the repo root\n    local_info = CODE_ROOT / \"current_working_dir.json\"\n    if local_info.exists():\n        try:\n            with open(local_info, \"r\") as f:\n                data = json.load(f)\n                return Path(data.get(\"cwd\", os.getcwd())).resolve()\n        except (json.JSONDecodeError, OSError):\n            pass\n\n    # 2. Check Global Config (User Install)\n    if CWD_INFO_FILE.exists():\n        try:\n            with open(CWD_INFO_FILE, \"r\") as f:\n                data = json.load(f)\n                return Path(data.get(\"cwd\", os.getcwd())).resolve()\n        except (json.JSONDecodeError, OSError):\n            pass\n            \n    return Path(os.getcwd()).resolve()\n\n# Project-Specific Data Directory (Local to the execution path)\nEXECUTION_DIR = get_current_working_dir()\nLOCAL_DATA_DIR = EXECUTION_DIR / \".multi-agent-mcp\"\n\n# Assets (Always bundled with the code)\nASSETS_DIR = CODE_ROOT / \"assets\"\nTEMPLATE_DIR = ASSETS_DIR / \"templates\"\n\n# Project-Specific Assets (State and Memory)\n# They are stored in the local .multi-agent-mcp folder\nSTATE_FILE = LOCAL_DATA_DIR / \"state.json\"", "start_line": 1, "end_line": 50}, {"path": "src/config.py", "content": "EXECUTION_DIR = get_current_working_dir()\nLOCAL_DATA_DIR = EXECUTION_DIR / \".multi-agent-mcp\"\n\n# Assets (Always bundled with the code)\nASSETS_DIR = CODE_ROOT / \"assets\"\nTEMPLATE_DIR = ASSETS_DIR / \"templates\"\n\n# Project-Specific Assets (State and Memory)\n# They are stored in the local .multi-agent-mcp folder\nSTATE_FILE = LOCAL_DATA_DIR / \"state.json\"\nMEMORY_DIR = LOCAL_DATA_DIR / \"memory\"\nLOGS_DIR = LOCAL_DATA_DIR / \"logs\"\n\n# Global Presets (Scenarios) shared across all projects\n# GLOBAL_PRESET_DIR already defined above\n\n# Ensure essential directories exist\nTEMPLATE_DIR.mkdir(parents=True, exist_ok=True)\nLOCAL_DATA_DIR.mkdir(parents=True, exist_ok=True)\nMEMORY_DIR.mkdir(parents=True, exist_ok=True)\nLOGS_DIR.mkdir(parents=True, exist_ok=True)\nGLOBAL_PRESET_DIR.mkdir(parents=True, exist_ok=True)\n\ndef _load_instruction(filename: str, default_text: str) -> str:\n    \"\"\"Helper to load instruction from template file or fallback.\"\"\"\n    path = TEMPLATE_DIR / filename\n    if path.exists():\n        try:\n            return path.read_text(encoding=\"utf-8\").strip()\n        except Exception:\n            pass\n    return default_text\n\n# Centralized Messages (Updated dynamically from templates if available)\nSTOP_INSTRUCTION = _load_instruction(\"stop_instruction.j2\", (\n    \"\ud83d\udd01 **RELOAD IN PROGRESS**\\n\"\n    \"STOP execution. Do NOT call anymore tools. Terminate process.\"\n))\n\nRELOAD_INSTRUCTION = _load_instruction(\"reload_instruction.j2\", (\n    \"\ud83d\udd01 **RELOAD REQUESTED**\\n\"\n    \"1. Call `note()` to save your state.\\n\"\n    \"2. Call `disconnect()` to finish.\\n\"\n    \"\u26d4 NO more `talk()`.\"\n))\n\n# Note Tool Response Template\nNOTE_RESPONSE = _load_instruction(\"note_response.j2\", (\n    \"\u2705 Note saved.\\n\\nPREVIOUS CONTENT:\\n\\n{{ old_content }}\"\n))", "start_line": 41, "end_line": 90}, {"path": "src/config.py", "content": "    \"\ud83d\udd01 **RELOAD REQUESTED**\\n\"\n    \"1. Call `note()` to save your state.\\n\"\n    \"2. Call `disconnect()` to finish.\\n\"\n    \"\u26d4 NO more `talk()`.\"\n))\n\n# Note Tool Response Template\nNOTE_RESPONSE = _load_instruction(\"note_response.j2\", (\n    \"\u2705 Note saved.\\n\\nPREVIOUS CONTENT:\\n\\n{{ old_content }}\"\n))", "start_line": 81, "end_line": 90}, {"path": "src/services/search_engine.py", "content": "\nimport os\nimport time\nimport threading\nimport json\nimport logging\nimport fnmatch\nfrom pathlib import Path\nfrom typing import List, Dict, Optional, Tuple\n\nimport numpy as np\n\n# Conditional imports to avoid crashing if dependencies are missing during dev\ntry:\n    import faiss\n    from sentence_transformers import SentenceTransformer\n    from watchdog.observers import Observer\n    from watchdog.events import FileSystemEventHandler\nexcept ImportError:\n    faiss = None\n    SentenceTransformer = None\n    Observer = None\n    FileSystemEventHandler = object\n\nfrom src.utils.logger import get_logger\n\nlogger = get_logger()\n\n# --- CONSTANTS ---\nMODEL_NAME = 'all-MiniLM-L6-v2'\nVECTOR_DIM = 384  # Dimension for MiniLM-L6-v2\nINDEX_FILE = \"search_index.faiss\"\nMETADATA_FILE = \"search_metadata.json\"\n\nclass SearchEngine(FileSystemEventHandler):\n    _instance = None\n    _lock = threading.Lock()\n\n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super(SearchEngine, cls).__new__(cls)\n                    cls._instance.initialized = False\n        return cls._instance\n\n    def initialize(self, root_dir: Path, persist_dir: Path, watch: bool = True):\n        \"\"\"\n        Initialize the search engine.\n        \"\"\"", "start_line": 1, "end_line": 50}, {"path": "src/services/search_engine.py", "content": "            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super(SearchEngine, cls).__new__(cls)\n                    cls._instance.initialized = False\n        return cls._instance\n\n    def initialize(self, root_dir: Path, persist_dir: Path, watch: bool = True):\n        \"\"\"\n        Initialize the search engine.\n        \"\"\"\n        if self.initialized:\n            return\n\n        self.root_dir = root_dir\n        self.persist_dir = persist_dir\n        self.persist_dir.mkdir(parents=True, exist_ok=True)\n        \n        self.index_path = self.persist_dir / INDEX_FILE\n        self.metadata_path = self.persist_dir / METADATA_FILE\n        \n        self.model = None\n        self.index = None\n        self.file_paths = [] \n        self.chunk_map = [] \n        self.last_reload = 0\n        self.device = \"cpu\"\n        \n        # Check Dependencies\n        if not (faiss and SentenceTransformer and Observer):\n            logger.error(\"Search\", \"Missing dependencies (faiss/sentence_transformers/watchdog). Search disabled.\")\n            return\n\n        logger.log(\"INFO\", \"Search\", f\"Initializing Search Engine with {MODEL_NAME} (Watch={watch})...\")\n        \n        # Load Model\n        try:\n            self.model = SentenceTransformer(MODEL_NAME, device='cuda') # Try CUDA\n            self.device = \"cuda\u201d\"\n        except:\n            try:\n                self.model = SentenceTransformer(MODEL_NAME, device='cpu')\n                self.device = \"cpu\"\n            except:\n                return\n        \n        logger.log(\"INFO\", \"Search\", f\"Model loaded on {self.device.upper()}\")\n\n\n        # Load Index\n        self._load_index()", "start_line": 41, "end_line": 90}, {"path": "src/services/search_engine.py", "content": "                self.model = SentenceTransformer(MODEL_NAME, device='cpu')\n                self.device = \"cpu\"\n            except:\n                return\n        \n        logger.log(\"INFO\", \"Search\", f\"Model loaded on {self.device.upper()}\")\n\n\n        # Load Index\n        self._load_index()\n        \n        # Start Watcher if requested\n        if watch:\n            self.observer = Observer()\n            self.observer.schedule(self, str(self.root_dir), recursive=True)\n            self.observer.start()\n            \n            # Initial scan if empty\n            if self.index.ntotal == 0:\n                threading.Thread(target=self._full_scan, daemon=True).start()\n                \n        self.initialized = True\n\n    def _load_index(self):\n        if self.index_path.exists() and self.metadata_path.exists():\n            try:\n                # Check consistency\n                mtime = self.metadata_path.stat().st_mtime\n                if mtime <= self.last_reload: return\n                \n                self.index = faiss.read_index(str(self.index_path))\n                with open(self.metadata_path, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    self.chunk_map = data.get(\"chunks\", [])\n                \n                self.last_reload = mtime\n                logger.log(\"INFO\", \"Search\", f\"Loaded index ({self.index.ntotal} vectors).\")\n            except Exception as e:\n                logger.error(\"Search\", f\"Error loading index: {e}. Resetting.\")\n                self.index = faiss.IndexFlatL2(VECTOR_DIM)\n                self.chunk_map = []\n        else:\n            self.index = faiss.IndexFlatL2(VECTOR_DIM)\n            self.chunk_map = []\n\n    def _check_reload(self):\n        \"\"\"Reloads index if file changed on disk.\"\"\"\n        if self.metadata_path.exists():\n            mtime = self.metadata_path.stat().st_mtime\n            if mtime > self.last_reload:", "start_line": 81, "end_line": 130}, {"path": "src/services/search_engine.py", "content": "                self.chunk_map = []\n        else:\n            self.index = faiss.IndexFlatL2(VECTOR_DIM)\n            self.chunk_map = []\n\n    def _check_reload(self):\n        \"\"\"Reloads index if file changed on disk.\"\"\"\n        if self.metadata_path.exists():\n            mtime = self.metadata_path.stat().st_mtime\n            if mtime > self.last_reload:\n                 self._load_index()\n\n    # ... (rest of class) ...\n\n\n    def _save_index(self):\n        if not self.index: return\n        try:\n            faiss.write_index(self.index, str(self.index_path))\n            with open(self.metadata_path, 'w', encoding='utf-8') as f:\n                json.dump({\"chunks\": self.chunk_map}, f)\n        except Exception as e:\n            logger.error(\"Search\", f\"Error saving index: {e}\")\n\n    def _full_scan(self):\n        \"\"\"Scans all files and indexes them.\"\"\"\n        logger.log(\"INFO\", \"Search\", \"Starting full file scan...\")\n        all_files = []\n        for root, dirs, files in os.walk(self.root_dir):\n            # Skip hidden dirs and system dir\n            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['__pycache__', 'node_modules', 'venv', 'env']]\n            \n            # Explicit exclusion\n            if \".multi-agent-mcp\" in root:\n                continue\n            \n            for file in files:\n                if file.startswith('.'): continue\n                # Filter extensions\n                if not file.endswith(('.py', '.md', '.json', '.js', '.ts', '.html', '.css', '.txt', '.toml')):\n                    continue\n                    \n                full_path = Path(root) / file\n                try:\n                    rel_path = full_path.relative_to(self.root_dir)\n                    # Double check relative path does not start with excluded\n                    if str(rel_path).startswith(\".multi-agent-mcp\"): continue\n                    all_files.append(rel_path)\n                except: pass\n        ", "start_line": 121, "end_line": 170}, {"path": "src/services/search_engine.py", "content": "                    continue\n                    \n                full_path = Path(root) / file\n                try:\n                    rel_path = full_path.relative_to(self.root_dir)\n                    # Double check relative path does not start with excluded\n                    if str(rel_path).startswith(\".multi-agent-mcp\"): continue\n                    all_files.append(rel_path)\n                except: pass\n        \n        # Process files\n        new_chunks = []\n        new_vectors = []\n        \n        for p in all_files:\n            chunks, vectors = self._process_file(p)\n            if chunks:\n                new_chunks.extend(chunks)\n                new_vectors.append(vectors)\n        \n        if new_vectors:\n            flat_vectors = np.vstack(new_vectors)\n            self.index = faiss.IndexFlatL2(VECTOR_DIM) # Reset\n            self.index.add(flat_vectors)\n            self.chunk_map = new_chunks\n            self._save_index()\n            \n        logger.log(\"INFO\", \"Search\", f\"Scan complete. Indexed {len(self.chunk_map)} chunks.\")\n\n    def _process_file(self, rel_path: Path) -> Tuple[List[dict], Optional[np.ndarray]]:\n        \"\"\"Reads a file, chunks it, and returns metadata and vectors.\"\"\"\n        full_path = self.root_dir / rel_path\n        try:\n            with open(full_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n        except:\n            return [], None\n            \n        # Simple Chunking (Line based for code)\n        lines = content.splitlines()\n        chunks = []\n        chunk_texts = []\n        \n        # Configurable chunk size\n        CHUNK_SIZE = 50 \n        OVERLAP = 10\n        \n        for i in range(0, len(lines), CHUNK_SIZE - OVERLAP):\n            chunk_lines = lines[i:i+CHUNK_SIZE]\n            if not chunk_lines: break", "start_line": 161, "end_line": 210}, {"path": "src/services/search_engine.py", "content": "        chunks = []\n        chunk_texts = []\n        \n        # Configurable chunk size\n        CHUNK_SIZE = 50 \n        OVERLAP = 10\n        \n        for i in range(0, len(lines), CHUNK_SIZE - OVERLAP):\n            chunk_lines = lines[i:i+CHUNK_SIZE]\n            if not chunk_lines: break\n            \n            text_block = \"\\n\".join(chunk_lines)\n            if not text_block.strip(): continue\n            \n            # Metadata\n            chunks.append({\n                \"path\": str(rel_path),\n                \"content\": text_block,\n                \"start_line\": i + 1,\n                \"end_line\": i + len(chunk_lines)\n            })\n            \n            # Enrich text for embedding (include path)\n            chunk_texts.append(f\"File: {rel_path}\\nContent:\\n{text_block}\")\n            \n        if not chunk_texts:\n            return [], None\n            \n        embeddings = self.model.encode(chunk_texts)\n        return chunks, embeddings\n\n    # --- Watchdog Handling ---\n    def on_modified(self, event):\n        if event.is_directory: return\n        self._handle_change(event.src_path)\n        \n    def on_created(self, event):\n        if event.is_directory: return\n        self._handle_change(event.src_path)\n\n    def _handle_change(self, file_path):\n        try:\n            path = Path(file_path)\n            # Filter\n            if path.name.startswith('.') or not path.suffix in ['.py', '.md', '.json', '.js', '.ts', '.html', '.css', '.txt', '.toml']:\n                return\n            \n            rel_path = path.relative_to(self.root_dir)\n            \n            if str(rel_path).startswith(\".multi-agent-mcp\"): ", "start_line": 201, "end_line": 250}, {"path": "src/services/search_engine.py", "content": "    def _handle_change(self, file_path):\n        try:\n            path = Path(file_path)\n            # Filter\n            if path.name.startswith('.') or not path.suffix in ['.py', '.md', '.json', '.js', '.ts', '.html', '.css', '.txt', '.toml']:\n                return\n            \n            rel_path = path.relative_to(self.root_dir)\n            \n            if str(rel_path).startswith(\".multi-agent-mcp\"): \n                return\n            \n            logger.log(\"INFO\", \"Search\", f\"File changed: {rel_path}. Updating index...\")\n            chunks, vectors = self._process_file(rel_path)\n            if chunks and vectors is not None:\n                self.index.add(vectors)\n                self.chunk_map.extend(chunks) \n                self._save_index()\n                \n        except Exception as e:\n            logger.error(\"Search\", f\"Error handling file change: {e}\")\n\n    # --- Public API ---\n\n    def search(self, query: str, limit: int = 5, file_pattern: str = None) -> List[dict]:\n        self._check_reload()\n        \n        if not self.initialized or not self.index or self.index.ntotal == 0:\n            return []\n            \n        query_vector = self.model.encode([query])\n        D, I = self.index.search(query_vector, limit * 4) \n        \n        results = []\n        seen_content_hashes = set()\n        \n        for i, idx in enumerate(I[0]):\n            if idx == -1 or idx >= len(self.chunk_map): continue\n            \n            chunk = self.chunk_map[idx]\n            \n            # Filter Pattern\n            if file_pattern and not fnmatch.fnmatch(chunk['path'], file_pattern):\n                continue\n                \n            # Deduplication (exact content)\n            h = hash(chunk['content'])\n            if h in seen_content_hashes: continue\n            seen_content_hashes.add(h)\n            ", "start_line": 241, "end_line": 290}, {"path": "src/services/search_engine.py", "content": "            \n            # Filter Pattern\n            if file_pattern and not fnmatch.fnmatch(chunk['path'], file_pattern):\n                continue\n                \n            # Deduplication (exact content)\n            h = hash(chunk['content'])\n            if h in seen_content_hashes: continue\n            seen_content_hashes.add(h)\n            \n            # Score\n            score = float(D[0][i])\n            \n            results.append({\n                \"path\": chunk['path'],\n                \"start_line\": chunk['start_line'],\n                \"end_line\": chunk['end_line'],\n                \"content\": chunk['content'],\n                \"score\": score\n            })\n            \n            if len(results) >= limit:\n                break\n                \n        return results\n\n    def get_relevant_context(self, query: str, max_markdown: int = 2, max_total: int = 5) -> Tuple[str, List[dict]]:\n        \"\"\"\n        Returns a formatted string for markdown injection and the raw results list.\n        Sensitive to passive constraints: ONLY .md or .txt files.\n        \"\"\"\n        # We query more to filter\n        results = self.search(query, limit=max_total * 2) \n        if not results:\n            return \"\", []\n            \n        # Filter for Passive Context: Only .md and .txt\n        valid_results = []\n        for r in results:\n            if r['path'].endswith(('.md', '.txt')):\n                valid_results.append(r)\n                \n        markdown_results = valid_results[:max_markdown]\n        \n        md_output = []\n        for r in markdown_results:\n            ext = Path(r['path']).suffix.lstrip('.')\n            md_output.append(f\"**{r['path']}** (L{r['start_line']}-{r['end_line']})\\n```{ext}\\n{r['content']}\\n```\")\n            \n        return \"\\n\\n\".join(md_output), valid_results", "start_line": 281, "end_line": 330}, {"path": "src/services/search_engine.py", "content": "                valid_results.append(r)\n                \n        markdown_results = valid_results[:max_markdown]\n        \n        md_output = []\n        for r in markdown_results:\n            ext = Path(r['path']).suffix.lstrip('.')\n            md_output.append(f\"**{r['path']}** (L{r['start_line']}-{r['end_line']})\\n```{ext}\\n{r['content']}\\n```\")\n            \n        return \"\\n\\n\".join(md_output), valid_results\n", "start_line": 321, "end_line": 331}, {"path": "src/interface/app.py", "content": "import streamlit as st\nimport streamlit.components.v1 as components\nfrom streamlit_autorefresh import st_autorefresh\nimport graphviz\nimport json\nimport uuid\nimport sys\nimport os\nimport time\nimport re\nimport shutil\nfrom pathlib import Path\n\n# Add src to path to allow imports if run directly\nfrom pathlib import Path\nimport sys\nimport os\n\nCODE_ROOT = Path(__file__).resolve().parent.parent.parent\nif str(CODE_ROOT) not in sys.path:\n    sys.path.append(str(CODE_ROOT))\n\nfrom src.config import (\n    STATE_FILE, \n    MEMORY_DIR, \n    TEMPLATE_DIR, \n    LOCAL_DATA_DIR, \n    GLOBAL_PRESET_DIR, \n    ASSETS_DIR,\n    CODE_ROOT as CONFIG_CODE_ROOT,\n    RELOAD_INSTRUCTION\n)\nfrom src.core.state import StateStore\nfrom src.services.search_engine import SearchEngine\n\nst.set_page_config(page_title=\"Agent Orchestra\", page_icon=\"\ud83e\udd16\", layout=\"wide\")\n\n# --- EMOJI LIST ---\nEMOJI_LIST = [\n    \"\ud83e\udd16\", \"\ud83e\udde0\", \"\ud83d\udd75\ufe0f\", \"\ud83e\uddb8\", \"\ud83e\udd77\", \"\ud83e\uddd9\", \"\ud83e\udddb\", \"\ud83e\udddf\", \"\ud83e\uddde\", \"\ud83e\udddd\",\n    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",", "start_line": 1, "end_line": 50}, {"path": "src/interface/app.py", "content": "    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",\n    \"\ud83e\udda1\", \"\ud83e\udda6\", \"\ud83e\udda5\", \"\ud83d\udc01\", \"\ud83d\udc00\", \"\ud83d\udc3f\ufe0f\", \"\ud83e\udd94\", \"\ud83d\udc3e\", \"\ud83d\udc09\", \"\ud83d\udc32\",\n    \"\ud83c\udf35\", \"\ud83c\udf84\", \"\ud83c\udf32\", \"\ud83c\udf33\", \"\ud83c\udf34\", \"\ud83c\udf31\", \"\ud83c\udf3f\", \"\u2618\ufe0f\", \"\ud83c\udf40\", \"\ud83c\udf43\"\n]\n\ndef get_random_emoji():\n    import random\n    return random.choice(EMOJI_LIST)\n\n# --- HELPER FUNCTIONS ---\ndef inject_custom_css():\n    st.markdown(\"\"\"<style>\n    /* Global message container */\n    [data-testid=\"stChatMessage\"] {\n        padding: 1rem !important;\n        margin-bottom: 1.5rem !important;\n    }\n    \n    [data-testid=\"stChatMessage\"] [data-testid=\"stVerticalBlock\"] {\n        gap: 12px !important;\n    }\n\n    /* Header layout inside message */\n    .message-header {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        margin-bottom: 8px;\n        opacity: 0.85;\n    }\n\n    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    ", "start_line": 41, "end_line": 90}, {"path": "src/interface/app.py", "content": "    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    \n    .reply-banner-custom {\n        background: #f0f7ff;\n        border: 1px solid #d0e7ff;\n        border-radius: 10px;\n        padding: 8px 15px;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        margin-bottom: 8px;\n        font-size: 0.85em;\n        box-shadow: 0 2px 8px rgba(0,0,0,0.05);\n    }\n\n    /* Premium Toggle Styling (Targeting the specific widget) */\n    div[data-testid=\"stToggle\"] {\n        background: #ffffff;\n        padding: 10px 24px !important;\n        border-radius: 50px !important;\n        border: 1px solid #ff4b4b22 !important;\n        box-shadow: 0 4px 15px rgba(0,0,0,0.06) !important;\n        transition: all 0.3s ease !important;\n        width: fit-content !important;\n        margin: 10px auto !important;\n    }\n    \n    div[data-testid=\"stToggle\"]:hover {\n        border-color: #ff4b4b !important;\n        box-shadow: 0 6px 20px rgba(255,75,75,0.12) !important;\n        transform: translateY(-1px);\n    }\n\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;", "start_line": 81, "end_line": 130}, {"path": "src/interface/app.py", "content": "\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;\n        gap: 12px !important;\n        margin: 0 !important;\n    }\n\n    div[data-testid=\"stToggle\"] label p {\n        font-weight: 700 !important;\n        font-size: 0.95em !important;\n        color: #1a1a1a !important;\n        margin: 0 !important;\n        letter-spacing: -0.2px !important;\n    }\n    \n    .target-badge {\n        font-weight: 600;\n        padding: 1px 6px;\n        border-radius: 4px;\n        font-size: 0.75em;\n        color: #444;\n        background: rgba(0,0,0,0.08);\n        border: 1px solid rgba(0,0,0,0.1);\n    }\n    \n    .status-tag {\n        font-size: 0.7em;\n        font-weight: 700;\n        padding: 1px 5px;\n        border-radius: 4px;\n        text-transform: uppercase;\n        letter-spacing: 0.5px;\n    }\n    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;", "start_line": 121, "end_line": 170}, {"path": "src/interface/app.py", "content": "    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        padding: 6px 16px;\n        color: #666;\n        font-size: 0.85em;\n        font-style: italic;\n        background: rgba(0,0,0,0.03);\n        border-radius: 20px;\n        margin: 10px auto;\n        width: fit-content;\n        border: 1px solid rgba(0,0,0,0.05);\n        box-shadow: 0 2px 4px rgba(0,0,0,0.02);\n    }\n    .typing-dots {\n        display: flex; gap: 4px; margin-left: 8px;\n    }\n    .typing-dot {\n        width: 5px; height: 5px; background: #999; border-radius: 50%;\n        animation: typing-bounce 1.4s infinite ease-in-out;\n    }\n    .typing-dot:nth-child(1) { animation-delay: -0.32s; }\n    .typing-dot:nth-child(2) { animation-delay: -0.16s; }\n    @keyframes typing-bounce {\n        0%, 80%, 100% { transform: translateY(0); opacity: 0.3; }\n        40% { transform: translateY(-3px); opacity: 1; }\n    }\n    </style>\"\"\", unsafe_allow_html=True)\n\ninject_custom_css()\n\n# --- INITIALIZE STATE (ONCE) ---\nstate_store = StateStore()\n\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n", "start_line": 161, "end_line": 210}, {"path": "src/interface/app.py", "content": "\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n\ndef save_config(new_config):\n    def update_fn(s):\n        s[\"config\"] = new_config\n        return \"Config Saved\"\n    state_store.update(update_fn)\n\n\n# --- SEARCH ENGINE INIT ---\n@st.cache_resource\ndef init_search_engine():\n    engine = SearchEngine()\n    # Ensure directory exists for persist\n    persist = LOCAL_DATA_DIR / \"vector_store\"\n    persist.mkdir(parents=True, exist_ok=True)\n    engine.initialize(root_dir=CODE_ROOT, persist_dir=persist)\n    return engine\n\n# Initialize background service\nsearch_engine = init_search_engine()\n\n\n# --- DIALOGS ---\ndef handle_disconnect_agent(agent_name):\n    \"\"\"\n    Sets the reload_active flag for the agent.\n    Does NOT set 'pending_connection' immediately (Agent must do it via disconnect tool).\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = True\n            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }", "start_line": 201, "end_line": 250}, {"path": "src/interface/app.py", "content": "            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }\n            s.setdefault(\"messages\", []).append(msg)\n            \n        return f\"Signal de rechargement envoy\u00e9 \u00e0 : {agent_name}\"\n    \n    state_store.update(update_fn)\n    st.toast(f\"Reload signal sent to {agent_name} \ud83d\udd01\")\n\ndef force_disconnect_agent(agent_name):\n    \"\"\"\n    Forces status to pending_connection immediately.\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = False # Reset flag\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n        return f\"Force disconnect: {agent_name}\"\n    state_store.update(update_fn)\n    st.toast(f\"\u2620\ufe0f Force Disconnect: {agent_name}\")\n\nPRESET_DIR = GLOBAL_PRESET_DIR\n\n@st.dialog(\"Sauvegarder le Sc\u00e9nario\")\ndef save_scenario_dialog(current_config):\n    save_name = st.text_input(\"Nom de Sauvegarde\", placeholder=\"mon_scenario\")\n    if st.button(\"Confirmer la Sauvegarde\", use_container_width=True):\n        if save_name:\n            # Basic filename cleaning\n            filename = \"\".join([c for c in save_name if c.isalnum() or c in (' ', '.', '_', '-')]).rstrip()\n            path = PRESET_DIR / f\"{filename}.json\"\n            with open(path, \"w\") as f:\n                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")", "start_line": 241, "end_line": 290}, {"path": "src/interface/app.py", "content": "                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")\n                except Exception as e:\n                    # Non-blocking, just dev convenience\n                    print(f\"Failed to sync to repo: {e}\")\n            st.success(f\"Sauvegard\u00e9 : {filename}\")\n            time.sleep(1)\n            st.rerun()\n        else:\n            st.error(\"Veuillez entrer un nom.\")\n\n@st.dialog(\"Charger un Sc\u00e9nario\")\ndef load_scenario_dialog():\n    # Unified Source: User Global Presets\n    # (Defaults have been synced here by sync_presets)\n    presets = sorted([f for f in os.listdir(PRESET_DIR) if f.endswith(\".json\")])\n    \n    if not presets:\n        st.warning(\"Aucun sc\u00e9nario trouv\u00e9.\")\n        return\n\n    options = [f\"\ud83d\udcbe {f}\" for f in presets]\n    path_map = {f\"\ud83d\udcbe {f}\": PRESET_DIR / f for f in presets}\n        \n    selected_label = st.selectbox(\"Choisir un Preset\", options)\n    \n    c_load, c_del = st.columns([0.85, 0.15])\n    \n    with c_load:\n        if st.button(\"Charger la Configuration\", use_container_width=True, type=\"primary\"):\n            if selected_label:\n                path = path_map[selected_label]\n                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)", "start_line": 281, "end_line": 330}, {"path": "src/interface/app.py", "content": "                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)\n                st.rerun()\n                \n    with c_del:\n        if st.button(\"\ud83d\uddd1\ufe0f\", key=\"del_scen_btn\", help=\"Supprimer d\u00e9finivement\", use_container_width=True):\n             if selected_label:\n                 path = path_map[selected_label]\n                 try:\n                     os.remove(path)\n                     st.toast(f\"Sc\u00e9nario supprim\u00e9: {selected_label}\")\n                     time.sleep(0.7)\n                     st.rerun()\n                 except Exception as e:\n                     st.error(f\"Erreur: {e}\")\n\ndef get_total_agents(profiles):\n    total = 0\n    for p in profiles:\n        try:\n            total += int(p.get(\"count\", 0))\n        except:\n            pass\n    return total\n\ndef format_mentions(text):\n    if not text: return text\n    \n    # 1. First decorate @everyone\n    text = re.sub(\n        r'(@everyone)',\n        r'<span style=\"color: #ffffff; background-color: #ff4b4b; padding: 2px 8px; border-radius: 6px; font-weight: 700; font-size: 0.9em; box-shadow: 0 2px 4px rgba(255,75,75,0.3);\">\\1</span>',\n        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )", "start_line": 321, "end_line": 370}, {"path": "src/interface/app.py", "content": "        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )\n\ndef render_graph(profiles, current_editing=None):\n    graph = graphviz.Digraph()\n    graph.attr(rankdir='LR', size='12,2', ratio='fill', bgcolor='transparent', margin='0')\n    \n    # Add User node\n    graph.node(\"User\", label=\"\ud83d\udc64 User\", style='filled', fillcolor='lightgrey', shape='circle', fontsize='10', height='0.5')\n    \n    for p in profiles:\n        name = p[\"name\"]\n        color = 'lightblue'\n        if current_editing and name == current_editing:\n            color = 'gold'\n        count = p.get(\"count\", 0)\n        label = f\"{name}\\n(x{count})\"\n        graph.node(name, label=label, style='filled', fillcolor=color, shape='box', fontsize='10', height='0.5')\n\n    for p in profiles:\n        source = p[\"name\"]\n        for conn in p.get(\"connections\", []):\n            target = conn.get(\"target\")\n            is_auth = conn.get(\"authorized\", True)\n            if is_auth and (target == \"User\" or any(prof[\"name\"] == target for prof in profiles)):\n                graph.edge(source, target, fontsize='8', color='gray', arrowsize='0.5')\n    return graph\n\ndef inject_mention_system(agent_names):\n    import json\n    agents_json = json.dumps(agent_names)\n    \n    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;", "start_line": 361, "end_line": 410}, {"path": "src/interface/app.py", "content": "    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;\n            const textarea = doc.querySelector('textarea[data-testid=\"stChatInputTextArea\"]');\n            \n            if (!textarea) {{\n                // Polled by setInterval, so just return\n                return;\n            }}\n\n            // Cleanup previous interaction from this or previous iframes\n            // We use a custom property on the DOM node to store the controller\n            if (textarea._mentionController) {{\n                // If the controller belongs to a DEAD iframe, this might fail or succeed. \n                // But mostly it allows us to signal \"Stop Listing\".\n                try {{\n                    textarea._mentionController.abort();\n                }} catch(e) {{}}\n            }}\n\n            // Create new controller for this instance\n            const controller = new AbortController();\n            textarea._mentionController = controller;\n            const signal = controller.signal;\n\n            let menu = doc.getElementById('mention-menu');\n            if (!menu) {{\n                menu = doc.createElement('div');\n                menu.id = 'mention-menu';\n                Object.assign(menu.style, {{\n                    display: 'none',\n                    position: 'fixed',\n                    background: 'white',\n                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);", "start_line": 401, "end_line": 450}, {"path": "src/interface/app.py", "content": "                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);\n            }}\n\n            // Inject styles\n            if (!doc.getElementById('mention-styles')) {{\n                const style = doc.createElement('style');\n                style.id = 'mention-styles';\n                style.innerHTML = `\n                    .mention-item:hover {{\n                        background-color: #f0f2f6 !important;\n                    }}\n                `;\n                doc.head.appendChild(style);\n            }}\n\n            textarea.addEventListener('input', (e) => {{\n                if (e.isComposing) return;\n                const value = textarea.value;\n                const cursorPos = textarea.selectionStart;\n                const textBeforeCursor = value.substring(0, cursorPos);\n                const mentionMatch = textBeforeCursor.match(/@([\\\\w\\\\s#]*)$/);\n\n                if (mentionMatch) {{\n                    isVisible = true;\n                    currentFilter = mentionMatch[1].toLowerCase();\n                    renderMenu(textarea);\n                }} else {{\n                    hideMenu();\n                }}\n            }}, {{ signal }});\n\n            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;", "start_line": 441, "end_line": 490}, {"path": "src/interface/app.py", "content": "            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'ArrowUp') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex - 1 + filtered.length) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'Enter' || e.key === 'Tab') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    insertMention(textarea, filtered[selectedIndex]);\n                }} else if (e.key === 'Escape') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    hideMenu();\n                }}\n            }}, {{ capture: true, signal: signal }});\n        }}\n\n        function renderMenu(textarea) {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n            \n            if (filtered.length === 0) {{\n                hideMenu();\n                return;\n            }}\n\n            menu.innerHTML = filtered.map((a, i) => `\n                <div class=\"mention-item\" style=\"\n                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">", "start_line": 481, "end_line": 530}, {"path": "src/interface/app.py", "content": "                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">\n                    <span style=\"font-weight: ${{i === selectedIndex ? '600' : '400'}};\">@${{a}}</span>\n                    ${{a === 'everyone' ? '<span style=\"font-size: 10px; background: #ff4b4b; color: white; padding: 1px 4px; border-radius: 4px; margin-left: 5px;\">PUBLIC</span>' : ''}}\n                </div>\n            `).join('');\n\n            const rect = textarea.getBoundingClientRect();\n            menu.style.display = 'block';\n            menu.style.left = rect.left + 'px';\n            \n            // Position above the textarea\n            menu.style.bottom = (window.parent.innerHeight - rect.top + 10) + 'px';\n            isVisible = true;\n        }}\n\n        function insertMention(textarea, name) {{\n            const value = textarea.value;\n            const cursorPos = textarea.selectionStart;\n            const textBeforeCursor = value.substring(0, cursorPos);\n            const textAfterCursor = value.substring(cursorPos);\n            \n            const newTextBefore = textBeforeCursor.replace(/@([\\\\w\\\\s#]*)$/, '@' + name + ' ');\n            const newValue = newTextBefore + textAfterCursor;\n\n            // Robust React state update\n            const nativeTextareaValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, \"value\").set;\n            nativeTextareaValueSetter.call(textarea, newValue);\n            \n            // Trigger events\n            textarea.dispatchEvent(new Event('input', {{ bubbles: true }}));\n            textarea.dispatchEvent(new Event('change', {{ bubbles: true }}));\n\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{", "start_line": 521, "end_line": 570}, {"path": "src/interface/app.py", "content": "\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            if (menu) menu.style.display = 'none';\n            isVisible = false;\n            selectedIndex = 0;\n        }}\n\n        // Initial setup & Polling for re-mounts\n        setInterval(setupMentions, 1000);\n    }})();\n    </script>\n    \"\"\"\n    components.html(components_code, height=0)\n\n# --- MAIN LOGIC ---\n\n# 1. Load Data\nstate, config = load_config()\ndata = state\nprofiles = config.get(\"profiles\", [])\nagents = data.get(\"agents\", {})\nturn = data.get(\"turn\", {})\nmessages = data.get(\"messages\", [])\n\n# --- CSS STYLING ---\nst.markdown(\"\"\"\n<style>\n    div[data-testid=\"stSidebar\"] {\n        background-color: #f0f2f6;\n    }\n    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;", "start_line": 561, "end_line": 610}, {"path": "src/interface/app.py", "content": "    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;\n    }\n    /* Agent Card Styling */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] {\n        background-color: white;\n        border-radius: 16px !important;\n        border: 1px solid #f0f0f0 !important;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.04);\n        padding: 0.5rem;\n        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    }\n    [data-testid=\"stVerticalBlockBorderWrapper\"]:hover {\n        transform: translateY(-4px);\n        box-shadow: 0 12px 24px rgba(0,0,0,0.08);\n        border-color: #ff4b4b44 !important;\n    }\n    .agent-header {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 12px;\n    }\n    .agent-icon {\n        font-size: 1.5em;\n        background: #f8f9fa;\n        width: 42px;\n        height: 42px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 10px;\n        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;", "start_line": 601, "end_line": 650}, {"path": "src/interface/app.py", "content": "        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;\n        color: #64748b;\n        margin-bottom: 1rem;\n        min-height: 4.2em;\n        line-height: 1.5;\n    }\n    .count-display {\n        background: #f1f5f9;\n        color: #0f172a;\n        height: 2.4em;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 8px;\n        font-weight: 700;\n        font-size: 1.1em;\n    }\n    /* Compact buttons in cards */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] .stButton button {\n        height: 2.4em !important;\n    }\n    .reset-button-container {\n        display: flex;\n        justify-content: center;\n        padding: 20px;\n    }\n    @keyframes pulse-gold {\n        0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }\n        70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }\n        100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }\n    }\n    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:", "start_line": 641, "end_line": 690}, {"path": "src/interface/app.py", "content": "    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:\n    st.session_state.page = \"Communication\"\n\n# --- SIDEBAR ---\nwith st.sidebar:\n    st.title(\"\ud83e\udd16 Orchestra\")\n    \n    # Global Autorefresh (Active on all pages to catch messages)\n    st_autorefresh(interval=4000, key=\"global_pulse\")\n\n    st.markdown(\"### Navigation\")\n    \n    # --- NOTIFICATION LOGIC ---\n    total_msgs = len(messages)\n    if \"last_read_count\" not in st.session_state:\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    unread = 0\n    if st.session_state.page != \"Communication\":\n        unread = max(0, total_msgs - st.session_state.last_read_count)\n        \n        # Toast for new messages\n        if \"last_toast_count\" not in st.session_state:\n             st.session_state.last_toast_count = total_msgs\n             \n        if total_msgs > st.session_state.last_toast_count:\n             new_count = total_msgs - st.session_state.last_toast_count\n             # Toast the last one\n             newest = messages[-1]\n             sender = newest.get(\"from\", \"?\")\n             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"", "start_line": 681, "end_line": 730}, {"path": "src/interface/app.py", "content": "             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"\n    if unread > 0:\n        label_comm = f\"\ud83d\udcac Chat ({unread} \ud83d\udd34)\"\n\n    if st.button(label_comm, use_container_width=True, type=\"primary\" if st.session_state.page == \"Communication\" else \"secondary\"):\n        st.session_state.page = \"Communication\"\n        st.rerun()\n        \n    if st.button(\"\ud83c\udf9b\ufe0f Cockpit\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Cockpit\" else \"secondary\"):\n        st.session_state.page = \"Cockpit\"\n        st.rerun()\n        \n    if st.button(\"\ud83d\udee0\ufe0f \u00c9diteur\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Editor\" else \"secondary\"):\n        st.session_state.page = \"Editor\"\n        st.rerun()\n\n    st.divider()\n    \n    # 1. Identity / User Status\n    st.markdown(\"### \ud83d\udc64 Identity\")\n    user_status = config.get(\"user_availability\", \"busy\")\n    \n    # User status toggle\n    is_available = st.toggle(\"Available\", value=(user_status == \"available\"), help=\"Switch between Available (\ud83d\udfe2) and Busy (\ud83d\udd34)\")\n    new_status = \"available\" if is_available else \"busy\"\n    \n    if new_status != user_status:\n        config[\"user_availability\"] = new_status\n        save_config(config)\n        st.rerun()\n\n    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:", "start_line": 721, "end_line": 770}, {"path": "src/interface/app.py", "content": "    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:\n        config[\"language\"] = new_lang\n        save_config(config)\n        st.rerun()\n\n        config[\"language\"] = new_lang\n        save_config(config)\n        st.rerun()\n\n    st.divider()\n    \n    # Search Config\n    st.markdown(\"### \ud83d\udd0e Search Engine\")\n    \n    # Status Indicator\n    if search_engine and search_engine.initialized:\n        dev_label = search_engine.device.upper().replace(\"\u201d\", \"\") # Fix typo if any from previous edit\n        st.caption(f\"Status: **Active** | Device: **{dev_label}** \u26a1\")\n    else:\n        st.caption(\"Status: \ud83d\udd34 Disabled (Missing Deps)\")\n\n    search_conf = config.get(\"search\", {})\n    \n    sc1, sc2 = st.columns(2)\n    with sc1:\n        x_val = st.number_input(\"Context (X)\", min_value=0, max_value=10, value=search_conf.get(\"x_markdown\", 3), help=\"Number of full markdown result to inject (Passive)\")\n    with sc2:\n        y_val = st.number_input(\"Total (Y)\", min_value=1, max_value=50, value=search_conf.get(\"y_total\", 15), help=\"Default limit for Search Tool\")\n        \n    if x_val != search_conf.get(\"x_markdown\", 3) or y_val != search_conf.get(\"y_total\", 15):\n        if \"search\" not in config: config[\"search\"] = {}\n        config[\"search\"][\"x_markdown\"] = x_val\n        config[\"search\"][\"y_total\"] = y_val\n        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)", "start_line": 761, "end_line": 810}, {"path": "src/interface/app.py", "content": "        config[\"search\"][\"x_markdown\"] = x_val\n        config[\"search\"][\"y_total\"] = y_val\n        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"\n        <div style=\"display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;\">\n            <h3 style=\"margin: 0; font-size: 1.2em;\">\ud83d\udc65 Agents Actifs</h3>\n            <span style=\"background: #e0e0e0; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold;\">{connected_count}</span>\n        </div>\n    \"\"\", unsafe_allow_html=True)\n    \n    # Maintain original order from agents dictionary\n    roster_list = [name for name in agents.keys()]\n    \n    # Explicitly add User to the top\n    roster_list.insert(0, \"User\")\n    \n    current_turn = turn.get(\"current\")\n    \n    if not roster_list:\n        st.caption(\"Aucun agent d\u00e9tect\u00e9.\")\n    else:\n        for name in roster_list:\n            # Handle User specifically since they are not in 'agents' dict\n            if name == \"User\":\n                u_avail = config.get(\"user_availability\", \"busy\")\n                # Map 'available' -> 'connected' (Green), 'busy' -> 'working' (Blue/Busy look)\n                info = {\n                    \"status\": \"connected\" if u_avail == \"available\" else \"working\",\n                    \"emoji\": \"\ud83d\udc64\"\n                }\n            else:\n                info = agents[name]\n            status = info.get(\"status\", \"pending\")\n            emoji = info.get(\"emoji\", \"\ud83e\udd16\")\n            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"", "start_line": 801, "end_line": 850}, {"path": "src/interface/app.py", "content": "            status = info.get(\"status\", \"pending\")\n            emoji = info.get(\"emoji\", \"\ud83e\udd16\")\n            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":\n                status_color = \"#4CAF50\" # Green\n                status_label = \"En ligne\"\n                bg = \"rgba(76, 175, 80, 0.05)\"\n                border_color = \"rgba(76, 175, 80, 0.2)\"\n            elif status == \"pending_connection\":\n                status_color = \"#FF9800\" # Orange\n                status_label = \"Attente Reconnexion\"\n                bg = \"rgba(255, 152, 0, 0.05)\"\n                border_color = \"rgba(255, 152, 0, 0.2)\"\n            elif status == \"working\":\n                status_color = \"#2196F3\" # Blue\n                status_label = \"Travaille...\"\n                bg = \"rgba(33, 150, 243, 0.05)\"\n                border_color = \"rgba(33, 150, 243, 0.2)\"\n            else:\n                status_color = \"#9E9E9E\" # Grey\n                status_label = \"Hors-ligne\"\n                bg = \"transparent\"\n                border_color = \"#eee\"\n            \n            # Additional pulse if it's their turn and they are connected\n            is_active_working = is_turn and status == \"connected\"\n            if is_active_working:\n                status_color = \"#2196F3\"\n                status_label = \"En action...\"\n            \n            card_html = f\"\"\"<div class=\"{card_class}\" style=\"background-color: {bg}; border: 1px solid {border_color}; border-radius: 10px; padding: 10px 14px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s ease;\"><div style=\"display: flex; align-items: center; gap: 12px;\"><div style=\"font-size: 1.4em; background: white; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);\">{emoji}</div><div style=\"display: flex; flex-direction: column;\"><span style=\"font-weight: 600; color: {'#1a1a1a' if status == 'connected' else '#666'}; font-size: 0.95em;\">{name}</span><div style=\"display: flex; align-items: center; gap: 4px;\"><div style=\"width: 6px; height: 6px; background-color: {status_color}; border-radius: 50%;\"></div><span style=\"font-size: 0.7em; color: {status_color}; font-weight: 500; letter-spacing: 0.5px;\">{status_label}</span></div></div></div>{'<span style=\"font-size: 1.2em;\" title=\"C&rsquo;est son tour !\">\u2728</span>' if is_turn else ''}</div>\"\"\"\n            \n            if name == \"User\":\n                st.markdown(card_html, unsafe_allow_html=True)\n            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)", "start_line": 841, "end_line": 890}, {"path": "src/interface/app.py", "content": "            if name == \"User\":\n                st.markdown(card_html, unsafe_allow_html=True)\n            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))\n\n                    if is_reloading:\n                        if st.button(\"\u274c\", key=f\"force_{name}\", help=\"Force Disconnect (Si bloqu\u00e9)\", type=\"primary\"):\n                             force_disconnect_agent(name)\n                             # Also remove from queue if present to unblock sequence\n                             if name in st.session_state.get(\"reload_queue\", []):\n                                 st.session_state.reload_queue.remove(name)\n                             st.rerun()\n                    else:\n                        if st.button(\"\ud83d\udd04\", key=f\"reload_{name}\", help=f\"Recharger {name}\"):\n                            handle_disconnect_agent(name)\n                            st.rerun()\n            \n    st.markdown(\"<div style='height: 10px;'></div>\", unsafe_allow_html=True)\n    if st.button(\"\ud83d\udd04 Reload All Agents\", type=\"secondary\", use_container_width=True, help=\"S\u00e9quence de rechargement (Parall\u00e8le).\"):\n         # Identify Targets\n        to_reload = [\n            n for n, d in agents.items() \n            if d.get(\"status\") in [\"connected\", \"working\"] \n        ]\n        if not to_reload:\n            st.toast(\"Aucun agent actif \u00e0 recharger.\")\n        else:\n            # START PARALLEL SEQUENCE\n            st.session_state.reload_queue = list(to_reload)\n            \n            # Atomic Bulk Update\n            def bulk_reload_signal(s):\n                count = 0\n                for name in to_reload:\n                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"", "start_line": 881, "end_line": 930}, {"path": "src/interface/app.py", "content": "                count = 0\n                for name in to_reload:\n                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,\n                            \"target\": name,\n                            \"timestamp\": time.time()\n                         }\n                         s.setdefault(\"messages\", []).append(msg)\n                         count += 1\n                return f\"Signal de rechargement global envoy\u00e9 ({count} agents).\"\n            \n            state_store.update(bulk_reload_signal)\n            st.toast(f\"S\u00e9quence de rechargement PARALL\u00c8LE initialis\u00e9e pour {len(to_reload)} agents.\")\n            st.rerun()\n\n    # --- SEQUENTIAL RELOAD PROCESSOR ---\n    # Global Processor for the Queue\n    if \"reload_queue\" in st.session_state and st.session_state.reload_queue:\n        current_target = st.session_state.reload_queue[0]\n        \n        # Check current status (Refetch from fresh state)\n        if current_target in agents:\n            agent_data = agents[current_target]\n            status = agent_data.get(\"status\")\n            is_reload_active = agent_data.get(\"reload_active\")\n            \n            # Condition 1: Agent is finished (Disconnect/Pending)\n            if status in [\"pending_connection\", \"disconnected\", \"offline\"]:\n                st.session_state.reload_queue.pop(0) # Done\n                st.rerun() # Proceed to next immediately\n                \n            # Condition 2: Agent needs to be signaled\n            elif not is_reload_active:\n                 handle_disconnect_agent(current_target)\n                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue", "start_line": 921, "end_line": 970}, {"path": "src/interface/app.py", "content": "            elif not is_reload_active:\n                 handle_disconnect_agent(current_target)\n                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()\n\n    st.divider()\n\n    # --- PAUSE CONTROL ---\n    is_paused = config.get(\"paused\", False)\n    if st.toggle(\"\u23f8\ufe0f PAUSE MCP\", value=is_paused, help=\"Fige le temps pour tous les agents.\"):\n        if not is_paused:\n            config[\"paused\"] = True\n            save_config(config)\n            st.rerun()\n    else:\n        if is_paused:\n            config[\"paused\"] = False\n            save_config(config)\n            st.rerun()\n            \n    if is_paused:\n        st.warning(\"\u26a0\ufe0f SIMULATION EN PAUSE\")\n    \n    st.divider()\n\n    \n    # Debug Tools\n    with st.expander(\"\ud83d\udd27 DEBUG\"):\n        st.markdown(\"### \u2702\ufe0f MCP Truncation Settings\")\n        current_trunc = config.get(\"truncation_limit\", 4096) # Default 4096\n        new_trunc = st.number_input(\"Max Character Limit (0 = Disabled)\", min_value=0, value=int(current_trunc), step=100, help=\"Limite manuelle pour \u00e9viter le tronquage silencieux du client MCP (4096 bytes max).\")\n        if new_trunc != current_trunc:\n             config[\"truncation_limit\"] = int(new_trunc)\n             save_config(config)\n             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:", "start_line": 961, "end_line": 1010}, {"path": "src/interface/app.py", "content": "             config[\"truncation_limit\"] = int(new_trunc)\n             save_config(config)\n             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)\n                    server_script = os.path.join(current_dir, \"src\", \"core\", \"server.py\")\n                    command_str = f\"cd {current_dir} && uv run python {server_script}\"\n                    if \"mcpServers\" not in json_data:\n                        json_data[\"mcpServers\"] = {}\n                    json_data[\"mcpServers\"][\"multi-agents-mcp\"] = {\n                        \"command\": \"sh\",\n                        \"args\": [\"-c\", command_str],\n                        \"env\": {}\n                    }\n                    with open(config_path, \"w\") as f:\n                        json.dump(json_data, f, indent=2)\n                    st.success(\"Config Path Updated\")\n            except Exception as e:\n                st.error(str(e))\n\n        if st.button(\"Delete Memories\"):\n            try:\n                mem_dir = str(MEMORY_DIR)\n                if os.path.exists(mem_dir):\n                    import shutil\n                    shutil.rmtree(mem_dir)\n                    os.makedirs(mem_dir, exist_ok=True)\n                    st.success(\"Memories Cleared\")\n            except Exception as e:\n                st.error(str(e))\n\n\n# ==========================================\n# PAGE: COMMUNICATION (Chat)\n# ==========================================\nif st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:", "start_line": 1001, "end_line": 1050}, {"path": "src/interface/app.py", "content": "# PAGE: COMMUNICATION (Chat)\n# ==========================================\nif st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":\n            # FOCUS MODE STYLES\n            st.markdown(\"\"\"\n            <style>\n            /* Gray out previous messages to focus on input */\n            .stChatMessage { opacity: 0.5; filter: grayscale(0.6); transition: all 0.3s; }\n            /* Highlight Input Area */\n            div[data-testid=\"stChatInput\"] { \n                border: 2px solid #ff3d00 !important; \n                border-radius: 12px;\n                box-shadow: 0 0 15px rgba(255, 61, 0, 0.4) !important;\n                background-color: #fff8f5 !important;\n            }\n            </style>\n            \"\"\", unsafe_allow_html=True)\n            \n\n        else:\n            st.markdown(f\"\"\"<div style=\"background-color: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; border-radius: 8px; text-align: center;\"><span style=\"color: #6c757d; font-size: 0.9em;\">En attente de :</span><br><span style=\"color: #1f1f1f; font-weight: bold; font-size: 1.1em;\">\ud83e\udd16 {current_turn}</span></div>\"\"\", unsafe_allow_html=True)\n    \n    # 1. Reply Context State\n    if \"reply_to\" not in st.session_state:\n        st.session_state.reply_to = None\n\n    # --- FLUX NEURAL (FULL WIDTH) ---\n    \n    # Helper for rendering messages and reply buttons\n    def render_reply_button(sender, content, idx):\n        if st.button(\"\u21a9\ufe0f\", key=f\"btn_reply_set_{idx}\", help=f\"Reply to {sender}\", type=\"tertiary\"):\n            st.session_state.reply_to = {\n                \"sender\": sender,\n                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything", "start_line": 1041, "end_line": 1090}, {"path": "src/interface/app.py", "content": "            st.session_state.reply_to = {\n                \"sender\": sender,\n                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"\n        if is_relevant:\n            # FILTER LOGIC\n            if is_urgent_focus:\n                target = m.get(\"target\")\n                is_replied = m.get(\"replied\", False)\n                # Show only if directed to User AND not replied\n                if target != \"User\" or is_replied:\n                    continue\n            stream_msgs.append((i, m))\n    \n    # Pagination\n    if \"stream_limit\" not in st.session_state: st.session_state.stream_limit = 25\n    total_stream = len(stream_msgs)\n    limit_stream = st.session_state.stream_limit\n    if total_stream > limit_stream:\n            # UI Minimaliste (Tertiary)\n            if st.button(f\"\ud83d\udd03 Historique ({total_stream - limit_stream})\", key=\"load_more_stream\", type=\"tertiary\"):\n                st.session_state.stream_limit += 25\n                st.rerun()\n    \n    visible_stream = stream_msgs[max(0, total_stream - limit_stream):]\n    \n    if not visible_stream:\n        st.info(\"Aucune activit\u00e9 d\u00e9tect\u00e9e sur les bandes neurales.\")\n        \n    for real_idx, m in visible_stream:\n        sender = m.get(\"from\", \"?\")\n        target = m.get(\"target\", \"?\")\n        content = m.get(\"content\", \"\")\n        is_public = m.get(\"public\", False)\n        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"", "start_line": 1081, "end_line": 1130}, {"path": "src/interface/app.py", "content": "        content = m.get(\"content\", \"\")\n        is_public = m.get(\"public\", False)\n        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        \n        # Style and Tag Logic\n        tag_html = \"\"\n        bubble_style = \"\"\n        \n        if is_public:\n            tag_html = ''\n            bubble_style = \"background-color: rgba(248, 249, 250, 0.8); border-left: 4px solid #2e7d32;\"\n        else:\n            if target == \"User\":\n                tag_html = '<span class=\"status-tag direct-tag\">\ud83d\udd12 Direct Link</span>'\n                if not is_replied:\n                    tag_html += '<span class=\"status-tag urgent-tag\">\u26a1 Action Required</span>'\n                    bubble_style = \"background-color: #fffdf0; border-left: 4px solid #fbc02d; box-shadow: 0 4px 12px rgba(251, 192, 45, 0.12);\"\n                else:\n                    bubble_style = \"background-color: #f0f7ff; border-left: 4px solid #1976d2;\"\n            elif sender == \"User\":\n                tag_html = f'<span class=\"status-tag\">\ud83d\udce4 Outgoing to {target}</span>'\n                bubble_style = \"background-color: #ffffff; border-left: 4px solid #94a3b8;\"\n            else:\n                tag_html = f'<span class=\"status-tag direct-tag\" style=\"background: #ffebee; color: #c62828;\">\ud83d\udd12 Private {sender} \u2192 {target}</span>'\n                bubble_style = \"background-color: #fff8f8; border: 2px dashed #ff4b4b;\"\n\n        with st.chat_message(sender, avatar=sender_emoji):\n            # Header with sender, target and status tags\n            c_header, c_action = st.columns([12, 1])\n            \n            with c_header:\n                st.markdown(f\"\"\"<div class=\"message-header\"><span style=\"font-weight: 700; color: #333; font-size: 0.9em;\">{sender}</span><span style=\"color: #999; font-size: 0.8em;\">\u2192</span><span class=\"target-badge\">{target if target != 'all' else 'everyone'}</span>{tag_html}<span style=\"color: #bbb; font-size: 0.7em; margin-left: auto;\">{time.strftime('%H:%M:%S', time.localtime(timestamp))}</span></div>\"\"\", unsafe_allow_html=True)\n            \n            with c_action:\n                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner", "start_line": 1121, "end_line": 1170}, {"path": "src/interface/app.py", "content": "            \n            with c_action:\n                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to\n        col_banner, col_x = st.columns([11, 1])\n        with col_banner:\n            st.markdown(f'<div class=\"reply-banner-custom\">\u21a9\ufe0f R\u00e9ponse \u00e0 <b>{ctx[\"sender\"]}</b>: \"{ctx[\"preview\"]}\"</div>', unsafe_allow_html=True)\n        with col_x:\n            if st.button(\"\u2716\ufe0f\", key=\"cancel_reply_v6\", help=\"Annuler\"):\n                st.session_state.reply_to = None\n                st.rerun()\n\n    # 2. Status & Focus Row\n    # (No extra spacer here to avoid empty divs)\n    \n    # 2a. Typing Indicator (Centered)\n    typing_agents = []\n    current_turn_name = turn.get(\"current\")\n    for name, info in agents.items():\n        if name == \"User\": continue\n        if info.get(\"status\") == \"working\" or (name == current_turn_name and info.get(\"status\") == \"connected\"):\n            typing_agents.append(name)\n    \n    if typing_agents:\n        agent_names = \", \".join(typing_agents)\n        plural = \"sont\" if len(typing_agents) > 1 else \"est\"\n        st.markdown(f'<div class=\"typing-container\">{agent_names} {plural} en train d\\'\u00e9crire...<div class=\"typing-dots\"><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div></div></div>', unsafe_allow_html=True)\n    \n    # 2b. Focus Toggle (Removed)\n    c1, c2, c3 = st.columns([1, 1, 1])\n    \n    # MOVED: Banner in bottom right (c3)\n    if turn.get(\"current\") == \"User\":\n        with c3:\n            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness", "start_line": 1161, "end_line": 1210}, {"path": "src/interface/app.py", "content": "    if turn.get(\"current\") == \"User\":\n        with c3:\n            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n\n    # Main Input\n    if prompt := st.chat_input(\"Message...\"):\n        def send_omni_msg(s):\n            target = None\n            public = True\n            reply_ref_id = None\n            \n            # Logic v2.0\n            \n            # 1. Context Reply (Strongest implicit) \n            # Tech Lead said: \"1. Si @Mention -> Priority. 2. Sinon si target_sel != Tous -> Target.\"\n            # Actually Context Reply usually overrides Selector visually, but Mention overrides all?\n            # Let's follow instruction:\n            # 1. Mention check\n            # 2. Selector check\n            # 3. Public\n            \n            found_mentions = []\n            found_mention = False\n            \n            # Mention Check (Specific Agents only)\n            known_agents = sorted(list(agents.keys()), key=len, reverse=True)\n            \n            # Use regex to find all mentions in order of appearance\n            # Sorting known_agents by length reverse ensures longer names are matched first\n            if known_agents:\n                pattern = \"@(\" + \"|\".join([re.escape(name) for name in known_agents]) + \")\"\n                matches = re.finditer(pattern, prompt)\n                seen = set()\n                for match in matches:\n                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]", "start_line": 1201, "end_line": 1250}, {"path": "src/interface/app.py", "content": "                seen = set()\n                for match in matches:\n                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True\n            else:\n                audience = []\n            \n            if not found_mention:\n                if st.session_state.reply_to:\n                     # Reply Context overrides Selector\n                     target = st.session_state.reply_to[\"sender\"]\n                     reply_ref_id = st.session_state.reply_to[\"id\"]\n                     public = False\n                else:\n                    # No mention, no reply context -> Public Broadcast\n                    target = \"all\"\n                    public = True\n            \n            # Prepare content with Reply Context\n            final_content = prompt\n            if st.session_state.reply_to:\n                ref = st.session_state.reply_to\n                final_content = f\"\u21aa\ufe0f [R\u00e9ponse \u00e0 {ref['sender']}: \\\"{ref['preview']}\\\"]\\n{prompt}\"\n\n            msg = {\n                \"from\": \"User\",\n                \"content\": final_content,\n                \"timestamp\": time.time(),\n                \"public\": public,\n                \"audience\": audience\n            }\n            if target:\n                msg[\"target\"] = target\n            else:\n                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]", "start_line": 1241, "end_line": 1290}, {"path": "src/interface/app.py", "content": "                msg[\"target\"] = target\n            else:\n                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---\n            if s.get(\"turn\", {}).get(\"current\") == \"User\":\n                next_speaker = None\n                if target and target != \"all\" and target in s.get(\"agents\", {}):\n                    next_speaker = target\n                else:\n                    # Priority 1: first_agent defined during reset\n                    first_pref = s.get(\"turn\", {}).get(\"first_agent\")\n                    if first_pref and first_pref in s.get(\"agents\", {}):\n                        next_speaker = first_pref\n                    else:\n                        # Fallback to the first connected agent\n                        connected = [n for n, d in s.get(\"agents\", {}).items() if d.get(\"status\") == \"connected\"]\n                        if connected:\n                            next_speaker = connected[0]\n                \n                if next_speaker:\n                    # USE CENTRALIZED TRANSITION LOGIC FROM ENGINE\n                    from src.core.logic import Engine\n                    engine = Engine(state_store) # Use the global state_store\n                    engine._finalize_turn_transition(s, next_speaker)\n\n            # Context Cleanup\n            if reply_ref_id is not None:\n                if reply_ref_id < len(s[\"messages\"]):\n                     s[\"messages\"][reply_ref_id][\"replied\"] = True\n                     \n            return \"Message Transmis.\"\n\n        res = state_store.update(send_omni_msg)\n        st.session_state.reply_to = None\n        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================", "start_line": 1281, "end_line": 1330}, {"path": "src/interface/app.py", "content": "        res = state_store.update(send_omni_msg)\n        st.session_state.reply_to = None\n        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")\n    \n    # --- 0. GRAPHVIZ VIEW (TOP) ---\n    with st.expander(\"\ud83d\udd78\ufe0f Topologie de la Flotte (Graphviz)\", expanded=False):\n        try:\n            g = render_graph(profiles)\n            st.graphviz_chart(g, use_container_width=True)\n        except Exception as e:\n            st.error(f\"Erreur de rendu du graphe : {e}\")\n\n    # Scenarios\n    st.subheader(\"\ud83d\udcbe Sc\u00e9narios\")\n    with st.container(border=True):\n        col_scen1, col_scen2 = st.columns(2)\n        if col_scen1.button(\"\ud83d\udcbe Sauvegarder\", use_container_width=True, help=\"Sauvegarder la configuration actuelle\"):\n            save_scenario_dialog(config)\n        if col_scen2.button(\"\ud83d\udcc2 Charger\", use_container_width=True, help=\"Charger une configuration existante\"):\n            load_scenario_dialog()\n\n    # Global Context (Full Width)\n    st.subheader(\"\ud83c\udf0d Contexte Global\")\n    with st.container(border=True):\n        enable_backlog = st.checkbox(\"Backlog\", value=config.get(\"enable_backlog\", False), help=\"Si coch\u00e9, les agents consulteront et mettront \u00e0 jour BACKLOG.md \u00e0 la racine.\")\n        if enable_backlog != config.get(\"enable_backlog\", False):\n            config[\"enable_backlog\"] = enable_backlog\n            save_config(config)\n            st.rerun()\n\n\n        global_context = st.text_area(\"Narratif / Contexte Partag\u00e9\", config.get(\"context\", \"\"), height=215)\n        if global_context != config.get(\"context\", \"\"):\n            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---", "start_line": 1321, "end_line": 1370}, {"path": "src/interface/app.py", "content": "        global_context = st.text_area(\"Narratif / Contexte Partag\u00e9\", config.get(\"context\", \"\"), height=215)\n        if global_context != config.get(\"context\", \"\"):\n            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    \n    # Display cards in a grid\n    cols_per_row = 3\n    for i in range(0, len(profiles), cols_per_row):\n        cols = st.columns(cols_per_row)\n        for j in range(cols_per_row):\n            if i + j < len(profiles):\n                p = profiles[i + j]\n                with cols[j]:\n                    with st.container(border=True):\n                        count = int(p.get(\"count\", 0))\n                        emoji = p.get(\"emoji\", \"\ud83e\udd16\")\n                        description = p.get(\"description\", \"Aucune description.\")\n                        \n                        st.markdown(f\"\"\"<div class=\"agent-header\"><div class=\"agent-icon\">{emoji}</div><div class=\"agent-name\">{p['name']}</div></div><div class=\"agent-desc\">{description}</div>\"\"\", unsafe_allow_html=True)\n                        \n                        # Controls inside the card\n                        ctrl_c1, ctrl_c2, ctrl_c3 = st.columns([1, 1.2, 1])\n                        if ctrl_c1.button(\"\u2796\", key=f\"d_{i+j}\", use_container_width=True):\n                            p[\"count\"] = max(0, count - 1)\n                            save_config(config)\n                            st.rerun()\n                        \n                        ctrl_c2.markdown(f'<div class=\"count-display\">{count}</div>', unsafe_allow_html=True)\n                        \n                        if ctrl_c3.button(\"\u2795\", key=f\"i_{i+j}\", use_container_width=True):\n                            p[\"count\"] = count + 1\n                            save_config(config)\n                            st.rerun()\n                            \n                        if st.button(\"\u270f\ufe0f Modifier\", key=f\"ed_{i+j}\", use_container_width=True, type=\"secondary\"):\n                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")", "start_line": 1361, "end_line": 1410}, {"path": "src/interface/app.py", "content": "                            \n                        if st.button(\"\u270f\ufe0f Modifier\", key=f\"ed_{i+j}\", use_container_width=True, type=\"secondary\"):\n                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    \n    # Calculate potential agent IDs the same way reset_logic does\n    temp_slots = []\n    for p in profiles:\n        for _ in range(int(p.get(\"count\", 0))):\n            temp_slots.append(p.get(\"display_name\") or p[\"name\"])\n            \n    counters = {}\n    for base in temp_slots:\n        counters.setdefault(base, 0)\n        counters[base] += 1\n        total_of_this_base = sum(1 for b in temp_slots if b == base)\n        agent_id = f\"{base} #{counters[base]}\" if total_of_this_base > 1 else base\n        potential_agents.append(agent_id)\n\n    # Use session state to persist choice\n    if \"first_speaker\" not in st.session_state:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    # Check if current choice is still valid (profiles might have changed)\n    if st.session_state.first_speaker not in potential_agents:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    selected_first = st.selectbox(\"Qui r\u00e9pondra en premier \u00e0 l'utilisateur ?\", potential_agents,\n                                 index=potential_agents.index(st.session_state.first_speaker) if st.session_state.first_speaker in potential_agents else 0,\n                                 help=\"L'agent qui aura le premier tour pour r\u00e9pondre au premier message de l'utilisateur.\")\n    st.session_state.first_speaker = selected_first\n\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n\n    # --- 3. RESET BUTTON (MODERN) ---\n    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []", "start_line": 1401, "end_line": 1450}, {"path": "src/interface/app.py", "content": "\n    # --- 3. RESET BUTTON (MODERN) ---\n    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context\n                \n                # Use profiles from the state s for absolute consistency\n                current_profiles = s[\"config\"].get(\"profiles\", [])\n                \n                # Update total agents count\n                total_count = get_total_agents(current_profiles)\n                s[\"config\"][\"total_agents\"] = total_count\n                \n                pending_slots = []\n                # Remove random shuffle to maintain profile order\n                for p in current_profiles:\n                    for _ in range(int(p.get(\"count\", 0))):\n                        pending_slots.append({\n                            \"profile_ref\": p[\"name\"],\n                            \"role\": p.get(\"system_prompt\", \"\"),\n                            \"display_base\": p.get(\"display_name\") or p[\"name\"],\n                            \"emoji\": p.get(\"emoji\", \"\ud83e\udd16\")\n                        })\n                \n                new_agents = {}\n                counters = {}\n                for slot in pending_slots:\n                    base = slot[\"display_base\"]\n                    counters.setdefault(base, 0)\n                    counters[base] += 1\n                    agent_id = f\"{base} #{counters[base]}\" if sum(1 for sl in pending_slots if sl[\"display_base\"] == base) > 1 else base\n                    new_agents[agent_id] = {\n                        \"role\": slot[\"role\"], \"status\": \"pending_connection\",\n                        \"profile_ref\": slot[\"profile_ref\"], \"emoji\": slot[\"emoji\"]\n                    }\n                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)", "start_line": 1441, "end_line": 1490}, {"path": "src/interface/app.py", "content": "                        \"profile_ref\": slot[\"profile_ref\"], \"emoji\": slot[\"emoji\"]\n                    }\n                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"\n            st.rerun()\n\n\n# ==========================================\n# PAGE: EDITOR (Admin)\n# ==========================================\nelif st.session_state.page == \"Editor\":\n    st.header(\"\ud83d\udee0\ufe0f \u00c9diteur d'Agents\")\n    \n    profile_names = [p[\"name\"] for p in profiles]\n    profile_names.append(\"\u2795 Create New\")\n    \n    sel_idx = 0\n    cur_edit = st.session_state.get(\"editing_agent_name\")\n    if cur_edit in profile_names:\n        sel_idx = profile_names.index(cur_edit)\n        \n    selected_name = st.selectbox(\"Selection Profil\", profile_names, index=sel_idx, key=\"edit_sel_page\")\n    \n    if selected_name == \"\u2795 Create New\":\n        current_profile = {\n            \"name\": \"New Agent\", \n            \"description\": \"\", \n            \"emoji\": \"\ud83e\udd16\", # Default, will be randomized in session state\n            \"connections\": [], \n            \"count\": 1, \n            \"capabilities\": [\"public\"]\n        }\n        new_mode = True\n        st.session_state.editing_agent_name = \"New Agent\"\n        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False", "start_line": 1481, "end_line": 1530}, {"path": "src/interface/app.py", "content": "        new_mode = True\n        st.session_state.editing_agent_name = \"New Agent\"\n        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        \n        if st.button(\"\ud83d\uddd1\ufe0f Supprimer Profil\", type=\"primary\"):\n             config[\"profiles\"] = [p for p in profiles if p[\"name\"] != selected_name]\n             emoji_key = f\"editing_emoji_{selected_name}\"\n             if emoji_key in st.session_state:\n                 del st.session_state[emoji_key]\n             save_config(config)\n             st.rerun()\n\n    if current_profile:\n        st.markdown(\"---\")\n        # Layout Spacieux (Columns)\n        c_main, c_disp = st.columns([3, 2])\n        \n        with c_main:\n            c_emoji, c_name = st.columns([0.18, 0.82])\n            \n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key not in st.session_state:\n                st.session_state[emoji_key] = current_profile.get(\"emoji\", \"\ud83e\udd16\")\n            current_emoji = st.session_state[emoji_key]\n            \n            with c_emoji:\n                st.markdown('<div style=\"height: 28px;\"></div>', unsafe_allow_html=True) # Spacer to align with text input label\n                with st.popover(f\"{current_emoji}\", use_container_width=True):\n                    cols = st.columns(8)\n                    for idx, emoji in enumerate(EMOJI_LIST):\n                        if cols[idx % 8].button(emoji, key=f\"emoji_btn_{selected_name}_{idx}\"):\n                            st.session_state[emoji_key] = emoji\n                            st.rerun()\n            \n            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")", "start_line": 1521, "end_line": 1570}, {"path": "src/interface/app.py", "content": "                            st.rerun()\n            \n            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")\n        caps = current_profile.get(\"capabilities\", [])\n        \n        # Preserve other capabilities (e.g. shell_exec)\n        other_caps = [c for c in caps if c not in [\"public\", \"private\"]]\n        \n        has_pub = \"public\" in caps\n        has_priv = \"private\" in caps\n        \n        # Determine default index\n        default_idx = 0 # Public\n        if has_pub and has_priv:\n            default_idx = 2 # Both\n        elif has_priv and not has_pub:\n            default_idx = 1 # Private\n        \n        comm_mode = st.radio(\n            \"Port\u00e9e de Communication\",\n            [\"Public\", \"Priv\u00e9\", \"Les Deux (Public & Priv\u00e9)\"],\n            index=default_idx,\n            key=f\"comm_mode_{selected_name}\",\n            horizontal=True,\n            help=\"D\u00e9finit la port\u00e9e de communication autoris\u00e9e pour cet agent.\"\n        )\n        \n        new_caps = list(other_caps)\n        if comm_mode == \"Public\":\n            new_caps.append(\"public\")\n        elif comm_mode == \"Priv\u00e9\":\n            new_caps.append(\"private\")\n        else:\n            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible", "start_line": 1561, "end_line": 1610}, {"path": "src/interface/app.py", "content": "            new_caps.append(\"private\")\n        else:\n            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        \n        new_connections = []\n        \n        # Header for the \"Table\"\n        with st.container():\n            h1, h2, h3 = st.columns([2, 5, 1])\n            h1.markdown(\"**Cible**\")\n            h2.markdown(\"**Condition / Contexte**\")\n            h3.markdown(\"**Active**\")\n            st.markdown(\"<hr style='margin-top: 0; margin-bottom: 10px; border-color: #eee;'>\", unsafe_allow_html=True)\n        \n        for target in targets:\n            # Case-insensitive match for connections\n            existing_conn = next((c for c in current_profile.get(\"connections\", []) if c[\"target\"].lower() == target.lower()), None)\n            \n            c1, c2, c3 = st.columns([2, 5, 1])\n            \n            # Label\n            target_profile = next((p for p in profiles if p[\"name\"] == target), None)\n            target_emoji = \"\ud83c\udf10\" if target == \"public\" else \"\ud83d\udc64\" if target == \"User\" else (target_profile.get(\"emoji\", \"\ud83e\udd16\") if target_profile else \"\ud83e\udd16\")\n            c1.markdown(f\"{target_emoji} **{target}**\")\n            \n            default_ctx = existing_conn.get(\"context\", \"\") if existing_conn else \"\"\n            default_auth = existing_conn.get(\"authorized\", True) if existing_conn else False\n            \n            # Unique key with selected_name and target\n            ctx = c2.text_area(f\"Condition for {target}\", default_ctx, key=f\"conn_ctx_{selected_name}_{target}\", label_visibility=\"collapsed\", height=68)\n            auth = c3.checkbox(f\"Active for {target}\", default_auth, key=f\"conn_auth_{selected_name}_{target}\", label_visibility=\"collapsed\")\n            \n            if auth or ctx:\n                new_connections.append({\"target\": target, \"context\": ctx, \"authorized\": auth})\n            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps", "start_line": 1601, "end_line": 1650}, {"path": "src/interface/app.py", "content": "            if auth or ctx:\n                new_connections.append({\"target\": target, \"context\": ctx, \"authorized\": auth})\n            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            \n            # Use the emoji from session state\n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key in st.session_state:\n                current_profile[\"emoji\"] = st.session_state[emoji_key]\n                del st.session_state[emoji_key]\n            \n            if new_mode:\n                profiles.append(current_profile)\n            \n            # Smart renaming\n            if not new_mode and selected_name and new_name != selected_name:\n                for p in profiles:\n                    for conn in p.get(\"connections\", []):\n                        if conn.get(\"target\") == selected_name:\n                            conn[\"target\"] = new_name\n            \n            save_config(config)\n            st.toast(\"Saved!\")\n            st.rerun()\n\n# --- GLOBAL INJECTION (Fixed by Anais) ---\nif st.session_state.page == \"Communication\":\n    # Ensure mentions are injected even if logic flow was broken\n    active_names = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    inject_mention_system(active_names)", "start_line": 1641, "end_line": 1677}, {"path": "src/core/models.py", "content": "from pydantic import BaseModel, Field, ConfigDict, ValidationError\nfrom typing import List, Dict, Optional, Any, Union\n\nclass BaseSchema(BaseModel):\n    model_config = ConfigDict(extra='ignore', populate_by_name=True)\n\nclass Connection(BaseSchema):\n    target: str\n    context: str = \"\"\n    authorized: bool = True\n\nclass Profile(BaseSchema):\n    name: str\n    display_name: Optional[str] = None\n    description: Optional[str] = None\n    public_description: Optional[str] = None\n    emoji: str = \"\ud83e\udd16\"\n    system_prompt: Optional[str] = \"\"\n    count: int = 1\n    capabilities: List[str] = Field(default_factory=list)\n    connections: List[Connection] = Field(default_factory=list)\n\nclass Config(BaseSchema):\n    total_agents: int = 2\n    context: str = \"\"\n    user_availability: str = \"available\"\n    profiles: List[Profile] = Field(default_factory=list)\n\nclass AgentState(BaseSchema):\n    role: str = \"\"\n    status: str = \"connected\"\n    status_detail: Optional[str] = None\n    profile_ref: str\n    emoji: str = \"\ud83e\udd16\"\n    connections: Optional[List[Connection]] = None\n    reload_active: bool = False\n\nclass Turn(BaseSchema):\n    current: Optional[str] = None\n    next: Optional[str] = None\n    first_agent: Optional[str] = None\n    consecutive_count: int = 0\n    turn_start_time: float = 0.0\n    last_user_message_time: float = 0.0\n    pending_next: Optional[str] = None\n\nclass Message(BaseSchema):\n    from_: str = Field(..., alias=\"from\")\n    content: str\n    timestamp: float", "start_line": 1, "end_line": 50}, {"path": "src/core/models.py", "content": "    first_agent: Optional[str] = None\n    consecutive_count: int = 0\n    turn_start_time: float = 0.0\n    last_user_message_time: float = 0.0\n    pending_next: Optional[str] = None\n\nclass Message(BaseSchema):\n    from_: str = Field(..., alias=\"from\")\n    content: str\n    timestamp: float\n    public: bool = False\n    target: Optional[str] = None\n    audience: List[str] = Field(default_factory=list)\n\n\nclass GlobalState(BaseSchema):\n    conversation_id: str\n    messages: List[Message] = Field(default_factory=list)\n    turn: Turn = Field(default_factory=Turn)\n    agents: Dict[str, AgentState] = Field(default_factory=dict)\n    config: Config = Field(default_factory=Config)", "start_line": 41, "end_line": 61}, {"path": "src/core/logic.py", "content": "import time\nimport asyncio\nfrom typing import Optional, List, Dict, Any\nfrom .state import StateStore\nfrom ..config import STOP_INSTRUCTION, RELOAD_INSTRUCTION\n\n\nclass Engine:\n    def __init__(self, state_store: StateStore = None):\n        self.state = state_store or StateStore()\n        try:\n            from ..utils.logger import get_logger\n            self.logger = get_logger()\n        except ImportError:\n            self.logger = None\n\n    def get_public_context(self) -> str:\n        \"\"\"Returns the public conversation history.\"\"\"\n        # Using a simple read since precision isn't critical for this\n        try:\n            data = self.state.load()\n            messages = data.get(\"messages\", [])\n            return \"\\n\".join([f\"[{m['from']}]: {m['content']}\" for m in messages if m.get('public')])\n        except:\n            return \"\"\n\n    def register_agent(self) -> Dict[str, Any]:\n        \"\"\"\n        Registers a new agent by claiming a pending slot.\n        Returns dict with keys: 'name', 'role', 'context', or 'error'.\n        \"\"\"\n        result = {}\n        \n        def _register(state):\n            # 1. Find a pending slot\n            agents = state.get(\"agents\", {})\n            found_name = None\n            found_data = None\n            \n            # Simple iteration - could be improved with priorities but First Come First Served is fine\n            for name, data in agents.items():\n                if data.get(\"status\") == \"pending_connection\":\n                    found_name = name\n                    found_data = data\n                    break\n            \n            if not found_name:\n                result[\"error\"] = \"GAME FULL: No pending roles available. Please wait or contact Admin.\"\n                return \"Registration Failed: Full\"\n            ", "start_line": 1, "end_line": 50}, {"path": "src/core/logic.py", "content": "            for name, data in agents.items():\n                if data.get(\"status\") == \"pending_connection\":\n                    found_name = name\n                    found_data = data\n                    break\n            \n            if not found_name:\n                result[\"error\"] = \"GAME FULL: No pending roles available. Please wait or contact Admin.\"\n                return \"Registration Failed: Full\"\n            \n            # 2. Claim it\n            agents[found_name][\"status\"] = \"connected\"\n            agents[found_name][\"reload_active\"] = False\n            \n            # 2b. Announce it (System Message)\n            # This fixes the \"User sees nothing\" bug\n            sys_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\ud83d\udd35 **{found_name}** has joined the simulation.\",\n                \"public\": False, # Private to User\n                \"target\": \"User\", \n                \"audience\": [],\n                \"timestamp\": time.time()\n            }\n            state.setdefault(\"messages\", []).append(sys_msg)\n            \n            # 3. Prepare Return Response\n            config = state.get(\"config\", {})\n            result[\"name\"] = found_name\n            result[\"role\"] = found_data.get(\"role\", \"Unknown Role\")\n            result[\"context\"] = config.get(\"context\", \"\")\n            \n            return f\"Agent connected as '{found_name}'\"\n\n        self.state.update(_register)\n        \n        # LOGGING\n        import sys\n        if self.logger:\n            self.logger.log(\"REGISTER\", result.get('name', '??'), f\"Registration Result: {result}\")\n        else:\n            print(f\"[Logic] Register result for '{result.get('name', '??')}': {result}\", file=sys.stderr)\n        \n        # If error was set inside update\n        if \"error\" in result:\n            if self.logger: self.logger.error(\"System\", result[\"error\"], \"registration\")\n            return result\n            \n        return result\n", "start_line": 41, "end_line": 90}, {"path": "src/core/logic.py", "content": "        else:\n            print(f\"[Logic] Register result for '{result.get('name', '??')}': {result}\", file=sys.stderr)\n        \n        # If error was set inside update\n        if \"error\" in result:\n            if self.logger: self.logger.error(\"System\", result[\"error\"], \"registration\")\n            return result\n            \n        return result\n\n    def get_network_status(self, agent_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Helper to check connection status of the mesh.\n        \"\"\"\n        state = self.state.load()\n        agents = state.get(\"agents\", {})\n        config = state.get(\"config\", {})\n        \n        # Robustness: use the actual number of agents defined in the state\n        # rather than a potentially out-of-sync config value.\n        total = len(agents) if agents else config.get(\"total_agents\", 0)\n        connected = sum(1 for a in agents.values() if a.get(\"status\") == \"connected\")\n        \n        other_agents = [n for n, d in agents.items() if d.get(\"status\") == \"connected\" and n != agent_name]\n        \n        # Check if agent is valid\n        if agent_name not in agents:\n             return {\"ready\": False, \"error\": \"Agent not found\"}\n\n        return {\n            \"ready\": connected >= total,\n            \"total_required\": total,\n            \"connected_count\": connected,\n            \"other_agents\": other_agents,\n            \"role\": agents.get(agent_name, {}).get(\"role\", \"Unknown\"),\n            \"context\": config.get(\"context\", \"\"),\n            \"language\": config.get(\"language\", \"fr\")\n        }\n\n    def wait_for_all_agents(self, name: str, timeout_seconds: int = 600) -> str:\n        \"\"\"\n        Blocks until all agents are connected.\n        Returns the System Context string.\n        \"\"\"\n        start_time = time.time()\n        while time.time() - start_time < timeout_seconds:\n            # Poll status\n            info = self.get_network_status(name)\n            \n            if info.get(\"error\"):", "start_line": 81, "end_line": 130}, {"path": "src/core/logic.py", "content": "        \"\"\"\n        Blocks until all agents are connected.\n        Returns the System Context string.\n        \"\"\"\n        start_time = time.time()\n        while time.time() - start_time < timeout_seconds:\n            # Poll status\n            info = self.get_network_status(name)\n            \n            if info.get(\"error\"):\n                return f\"ERROR: {info['error']}\"\n\n            # --- RELOAD/RESET CHECK ---\n            try:\n                data = self.state.load()\n                agent_data = data.get(\"agents\", {}).get(name, {})\n                if agent_data.get(\"reload_active\") or agent_data.get(\"status\") == \"pending_connection\":\n                    return \"RELOAD_REQUIRED\"\n            except:\n                pass\n            # --------------------------\n\n            if info[\"ready\"]:\n                # Build context\n                lang = info.get(\"language\", \"fr\")\n                context = info[\"context\"]\n                other_agents_str = \", \".join(info[\"other_agents\"])\n\n                # i18n\n                # Localized Strings (Simplified Replacement for i18n)\n                if lang in [\"fr\", \"French\"]:\n                     t_ctx_label = \"CONTEXTE :\"\n                     t_you_are = f\"Tu es {name}. R\u00f4le : {info['role']}.\"\n                     t_ready = f\"Le r\u00e9seau est PR\u00caT. Agents connect\u00e9s : {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Pairs : {other_agents_str}.\"\n                     t_speak = \"Tu peux maintenant parler si c'est ton tour.\"\n                else:\n                     t_ctx_label = \"CONTEXT:\"\n                     t_you_are = f\"You are {name}. Role: {info['role']}.\"\n                     t_ready = f\"Network is READY. Connected agents: {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Peers: {other_agents_str}.\"\n                     t_speak = \"You may now speak if it is your turn.\"\n\n                return (\n                    f\"{t_ctx_label} {context}\\n\\n\"\n                    f\"{t_you_are}\\n\"\n                    f\"{t_ready}\\n\"\n                    f\"{t_peers}\\n\"\n                    f\"{t_speak}\"\n                )", "start_line": 121, "end_line": 170}, {"path": "src/core/logic.py", "content": "                     t_peers = f\"Peers: {other_agents_str}.\"\n                     t_speak = \"You may now speak if it is your turn.\"\n\n                return (\n                    f\"{t_ctx_label} {context}\\n\\n\"\n                    f\"{t_you_are}\\n\"\n                    f\"{t_ready}\\n\"\n                    f\"{t_peers}\\n\"\n                    f\"{t_speak}\"\n                )\n            \n            time.sleep(2) # Polling interval\n        \n    def acknowledge_turn(self, agent_name: str) -> None:\n        \"\"\"\n        Updates the turn_start_time to now.\n        Used when an agent successfully retrieves the turn, acknowledging they have seen all prior messages.\n        \"\"\"\n        def _ack(state):\n            # Only update if it is indeed this agent's turn to prevent hijacking\n            if state.get(\"turn\", {}).get(\"current\") == agent_name:\n                state[\"turn\"][\"turn_start_time\"] = time.time()\n                return \"Turn Acknowledged\"\n            return \"Turn Ack Failed: Not your turn\"\n        self.state.update(_ack)\n\n    def _finalize_turn_transition(self, state, intended_next: str) -> str:\n        \"\"\"\n        Internal helper to manage turn transitions.\n        \"\"\"\n        turn_data = state.get(\"turn\", {})\n        old_turn = turn_data.get(\"current\")\n\n        # 1. Resume normal flow.\n        final_next = intended_next\n        if turn_data.get(\"pending_next\"):\n            final_next = turn_data[\"pending_next\"]\n            state[\"turn\"][\"pending_next\"] = None\n        \n        state[\"turn\"][\"current\"] = final_next\n        state[\"turn\"][\"turn_start_time\"] = time.time()\n        \n        if final_next == old_turn:\n            state[\"turn\"][\"consecutive_count\"] = turn_data.get(\"consecutive_count\", 0) + 1\n        else:\n            state[\"turn\"][\"consecutive_count\"] = 1\n        \n        import sys\n        if self.logger:\n            self.logger.log(\"TURN_CHANGE\", \"System\", f\"Turn passed to {final_next}\")", "start_line": 161, "end_line": 210}, {"path": "src/core/logic.py", "content": "        state[\"turn\"][\"turn_start_time\"] = time.time()\n        \n        if final_next == old_turn:\n            state[\"turn\"][\"consecutive_count\"] = turn_data.get(\"consecutive_count\", 0) + 1\n        else:\n            state[\"turn\"][\"consecutive_count\"] = 1\n        \n        import sys\n        if self.logger:\n            self.logger.log(\"TURN_CHANGE\", \"System\", f\"Turn passed to {final_next}\")\n        else:\n            print(f\"[Logic] TURN CHANGE: {old_turn} -> {final_next}\", file=sys.stderr)\n            \n        return f\"Turn is now: {final_next}.\"\n\n    async def wait_for_all_agents_async(self, name: str, timeout_seconds: int = 600) -> str:\n        \"\"\"\n        Async version of wait_for_all_agents.\n        \"\"\"\n        start_time = time.time()\n        while time.time() - start_time < timeout_seconds:\n            # Poll status (Sync load is fine as it uses LOCK_NB now)\n            # BUT we must use to_thread because state.load() might sleep (time.sleep) on lock contention\n            info = await asyncio.to_thread(self.get_network_status, name)\n            \n            if info.get(\"error\"):\n                return f\"ERROR: {info['error']}\"\n\n            # --- RELOAD/RESET CHECK ---\n            try:\n                data = await asyncio.to_thread(self.state.load)\n                agent_data = data.get(\"agents\", {}).get(name, {})\n                if agent_data.get(\"reload_active\") or agent_data.get(\"status\") == \"pending_connection\":\n                    return \"RELOAD_REQUIRED\"\n            except:\n                pass\n            # --------------------------\n\n            if info[\"ready\"]:\n                # Build context\n                lang = info.get(\"language\", \"fr\")\n                context = info[\"context\"]\n                other_agents_str = \", \".join(info[\"other_agents\"])\n\n                # i18n\n                # Localized Strings (Simplified Replacement for i18n)\n                if lang in [\"fr\", \"French\"]:\n                     t_ctx_label = \"CONTEXTE :\"\n                     t_you_are = f\"Tu es {name}. R\u00f4le : {info['role']}.\"\n                     t_ready = f\"Le r\u00e9seau est PR\u00caT. Agents connect\u00e9s : {info['connected_count']}/{info['total_required']}.\"", "start_line": 201, "end_line": 250}, {"path": "src/core/logic.py", "content": "                lang = info.get(\"language\", \"fr\")\n                context = info[\"context\"]\n                other_agents_str = \", \".join(info[\"other_agents\"])\n\n                # i18n\n                # Localized Strings (Simplified Replacement for i18n)\n                if lang in [\"fr\", \"French\"]:\n                     t_ctx_label = \"CONTEXTE :\"\n                     t_you_are = f\"Tu es {name}. R\u00f4le : {info['role']}.\"\n                     t_ready = f\"Le r\u00e9seau est PR\u00caT. Agents connect\u00e9s : {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Pairs : {other_agents_str}.\"\n                     t_speak = \"Tu peux maintenant parler si c'est ton tour.\"\n                else:\n                     t_ctx_label = \"CONTEXT:\"\n                     t_you_are = f\"You are {name}. Role: {info['role']}.\"\n                     t_ready = f\"Network is READY. Connected agents: {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Peers: {other_agents_str}.\"\n                     t_speak = \"You may now speak if it is your turn.\"\n\n                return (\n                    f\"{t_ctx_label} {context}\\n\\n\"\n                    f\"{t_you_are}\\n\"\n                    f\"{t_ready}\\n\"\n                    f\"{t_peers}\\n\"\n                    f\"{t_speak}\"\n                )\n            \n            await asyncio.sleep(2) # Non-blocking Sleep\n        \n        return \"TIMEOUT: Waiting for other agents took too long. Please retry agent() tool.\"\n\n    def post_message(self, from_agent: str, content: str, public: bool, next_agent: str, audience: List[str] = None) -> str:\n        \"\"\"\n        Posts a message and updates the turn.\n        Validates capabilities and connections before posting.\n        \"\"\"\n        def _post(state):\n            # 0. VALIDATION\n            agents = state.get(\"agents\", {})\n            \n            # --- SECURITY HOTFIX: STRICT TURN CHECK ---\n            current_turn = state.get(\"turn\", {}).get(\"current\")\n            if from_agent != \"User\" and current_turn != from_agent:\n                 return f\"\ud83d\udeab SECURITY VIOLATION: Write Access Denied. It is '{current_turn}'s turn, not yours.\"\n            # ------------------------------------------\n\n            config = state.get(\"config\", {})\n            profiles = config.get(\"profiles\", [])\n            \n            nonlocal next_agent", "start_line": 241, "end_line": 290}, {"path": "src/core/logic.py", "content": "            # --- SECURITY HOTFIX: STRICT TURN CHECK ---\n            current_turn = state.get(\"turn\", {}).get(\"current\")\n            if from_agent != \"User\" and current_turn != from_agent:\n                 return f\"\ud83d\udeab SECURITY VIOLATION: Write Access Denied. It is '{current_turn}'s turn, not yours.\"\n            # ------------------------------------------\n\n            config = state.get(\"config\", {})\n            profiles = config.get(\"profiles\", [])\n            \n            nonlocal next_agent\n            if next_agent: next_agent = next_agent.strip()\n\n            # --- RESOLVE AGENT ID FROM PROFILE ---\n            if next_agent and next_agent not in agents and next_agent != \"User\":\n                for aid, adata in agents.items():\n                    if adata.get(\"profile_ref\") == next_agent:\n                        next_agent = aid\n                        break # Use the first agent matching the profile\n            # -------------------------------------\n            \n            if not next_agent:\n                return \"\ud83d\udeab ACTION DENIED: 'next_agent' cannot be empty. You must specify who speaks next.\"\n            \n            if next_agent not in agents and next_agent != \"User\":\n                 # Strict Existence Check (Fix for typos causing deadlocks)\n                 return f\"\ud83d\udeab TARGET_NOT_FOUND: {next_agent}\"\n\n            sender_info = agents.get(from_agent, {})\n            sender_profile_name = sender_info.get(\"profile_ref\")\n            \n            # Find Sender Profile\n            sender_profile = next((p for p in profiles if p[\"name\"] == sender_profile_name), None)\n            \n            # Special bypass for \"User\" (Admin/Human)\n            if from_agent == \"User\":\n                sender_profile = {\"name\": \"User\", \"capabilities\": [\"public\", \"private\"], \"connections\": []}\n            else:\n                if not sender_profile:\n                    return f\"\ud83d\udeab ACTION DENIED: Agent '{from_agent}' has no valid profile validation.\"\n\n            caps = sender_profile.get(\"capabilities\", [])\n            connections = sender_profile.get(\"connections\", [])\n            # Map of authorized targets (profiles or specific IDs)\n            allowed_targets = {c[\"target\"]: c[\"context\"] for c in connections if c.get(\"authorized\", True)}\n            \n            # MERGE INSTANCE CONNECTIONS (Priority)\n            instance_connections = sender_info.get(\"connections\", [])\n            for c in instance_connections:\n                if c.get(\"authorized\", True):\n                    allowed_targets[c[\"target\"]] = c[\"context\"]", "start_line": 281, "end_line": 330}, {"path": "src/core/logic.py", "content": "            caps = sender_profile.get(\"capabilities\", [])\n            connections = sender_profile.get(\"connections\", [])\n            # Map of authorized targets (profiles or specific IDs)\n            allowed_targets = {c[\"target\"]: c[\"context\"] for c in connections if c.get(\"authorized\", True)}\n            \n            # MERGE INSTANCE CONNECTIONS (Priority)\n            instance_connections = sender_info.get(\"connections\", [])\n            for c in instance_connections:\n                if c.get(\"authorized\", True):\n                    allowed_targets[c[\"target\"]] = c[\"context\"]\n            \n            # Anti-Ghost Check (Sprint 6)\n            if from_agent != \"User\":\n                turn_data = state.get(\"turn\", {})\n                turn_start = turn_data.get(\"turn_start_time\", 0.0)\n                last_user = turn_data.get(\"last_user_message_time\", 0.0)\n                \n                # If User spoke AFTER turn started\n                if last_user > turn_start:\n                     # 2. Fetch missed messages (Fix Silence)\n                     missed = [m for m in state.get(\"messages\", []) if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > turn_start]\n                     relevant = [m for m in missed if m.get(\"public\") or m.get(\"target\") == from_agent]\n                     \n                     if relevant:\n                         # 1. Update Turn Start to unblock next attempt (Fix Deadlock)\n                         state[\"turn\"][\"turn_start_time\"] = time.time()\n                         missed_text = \"\\n\".join([f\"- User: {m.get('content')}\" for m in relevant])\n                         return f\"\ud83d\udeab INTERACTION REJECTED: The User interrupted you with new messages:\\n{missed_text}\\n\\nACTION: Core logic has reset your turn timer. Incorporate this new info and try again.\"\n\n            if next_agent == from_agent:\n                 # Allow self-loop with limit\n                 consecutive = state[\"turn\"].get(\"consecutive_count\", 0)\n                 old_turn = state[\"turn\"].get(\"current\")\n                 if old_turn == from_agent and consecutive >= 5:\n                     return \"\ud83d\udeab PROHIBITED: Self-loop limit reached (5/5). You cannot speak 6 times in a row. Please yield the turn.\"\n\n            # A. Capability Checks\n            # User Rule: \"Tous les agents ne doivent pouvoir parler qu'en public.\" (Implies preference, but logic supports private if cap exists)\n            \n            if public and \"public\" not in caps and \"public\" not in allowed_targets:\n                 # Note: allowed_targets usually lists generic \"public\" connection if explicit\n                 return f\"\ud83d\udeab ACTION DENIED: You do not have the 'public' capability.\"\n            \n            if not public:\n                 # Private Message\n                 if \"private\" not in caps:\n                      return f\"\ud83d\udeab ACTION DENIED: You do not have the 'private' capability. You can only speak publicly.\"\n                 \n                 # Check connection to target\n                 # Helper to check one target", "start_line": 321, "end_line": 370}, {"path": "src/core/logic.py", "content": "                 # Note: allowed_targets usually lists generic \"public\" connection if explicit\n                 return f\"\ud83d\udeab ACTION DENIED: You do not have the 'public' capability.\"\n            \n            if not public:\n                 # Private Message\n                 if \"private\" not in caps:\n                      return f\"\ud83d\udeab ACTION DENIED: You do not have the 'private' capability. You can only speak publicly.\"\n                 \n                 # Check connection to target\n                 # Helper to check one target\n                 def check_target(t_name):\n                    if t_name == \"User\":\n                        if \"User\" in allowed_targets: return None\n                        return \"No established connection to 'User'\"\n                    t_info = agents.get(t_name)\n                    if not t_info: return f\"Unknown agent '{t_name}'\"\n                    t_prof = t_info.get(\"profile_ref\")\n                    if t_name in allowed_targets: return None\n                    if t_prof in allowed_targets: return None\n                    return f\"Not connected to '{t_prof}'\"\n                 \n                 err = check_target(next_agent)\n                 if err:\n                     return f\"\ud83d\udeab ACTION DENIED: You are not authorized to speak privately to '{next_agent}' ({err}).\"\n\n            # 1. Add message\n            msg = {\n                \"from\": from_agent,\n                \"content\": content,\n                \"public\": public,\n                \"target\": next_agent, \n                \"audience\": audience or [],\n                \"timestamp\": time.time()\n            }\n            state.setdefault(\"messages\", []).append(msg)\n            \n            # 2. Update Turn\n            # Update Logic timestamps\n            current_time = time.time()\n            if from_agent == \"User\":\n                state[\"turn\"][\"last_user_message_time\"] = current_time\n            \n            # USE CENTRALIZED TRANSITION LOGIC\n            transition_msg = self._finalize_turn_transition(state, next_agent)\n            \n            base_msg = f\"Message posted. {transition_msg}\"\n            if state[\"turn\"].get(\"current\") == from_agent:\n                base_msg += \"\\n[INFO] Il est possible de reprendre la parole apr\u00e8s avoir envoy\u00e9 un message.\"\n            \n            return base_msg", "start_line": 361, "end_line": 410}, {"path": "src/core/logic.py", "content": "                state[\"turn\"][\"last_user_message_time\"] = current_time\n            \n            # USE CENTRALIZED TRANSITION LOGIC\n            transition_msg = self._finalize_turn_transition(state, next_agent)\n            \n            base_msg = f\"Message posted. {transition_msg}\"\n            if state[\"turn\"].get(\"current\") == from_agent:\n                base_msg += \"\\n[INFO] Il est possible de reprendre la parole apr\u00e8s avoir envoy\u00e9 un message.\"\n            \n            return base_msg\n        \n        return self.state.update(_post)\n\n    def wait_for_turn(self, agent_name: str, timeout_seconds: int = 60) -> Dict[str, Any]:\n        \"\"\"\n        Blocks until it is this agent's turn.\n        Returns dict with keys: 'status' (success/timeout/reset), 'messages' (list), 'instruction' (str).\n        \"\"\"\n        start_time = time.time()\n        \n        # 0. Capture current conversation ID to detect resets\n        try:\n            initial_state = self.state.load()\n            current_conversation_id = initial_state.get(\"conversation_id\")\n        except Exception:\n            current_conversation_id = None\n\n        while time.time() - start_time < timeout_seconds:\n            try:\n                data = self.state.load()\n            except Exception:\n                time.sleep(1)\n                continue\n            \n            # 0. Check for PAUSE\n            if data.get(\"config\", {}).get(\"paused\"):\n                time.sleep(1)\n                continue\n            \n            # 1. Check for RESET\n            new_conversation_id = data.get(\"conversation_id\")\n            if current_conversation_id and new_conversation_id != current_conversation_id:\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": \"SYSTEM RESET: The conversation has been reset by the user. Forget everything. Re-read your Role and Context.\"\n                }\n                \n            # 1b. Check for Status Reset (Kicked/Reloaded)\n            agent_data = data.get(\"agents\", {}).get(agent_name, {})", "start_line": 401, "end_line": 450}, {"path": "src/core/logic.py", "content": "            new_conversation_id = data.get(\"conversation_id\")\n            if current_conversation_id and new_conversation_id != current_conversation_id:\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": \"SYSTEM RESET: The conversation has been reset by the user. Forget everything. Re-read your Role and Context.\"\n                }\n                \n            # 1b. Check for Status Reset (Kicked/Reloaded)\n            agent_data = data.get(\"agents\", {}).get(agent_name, {})\n            my_status = agent_data.get(\"status\")\n            if my_status == \"pending_connection\":\n                    return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": STOP_INSTRUCTION\n                }\n            \n            # 1c. Check for RELOAD\n            if agent_data.get(\"reload_active\"):\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": RELOAD_INSTRUCTION\n                }\n\n            current_turn = data.get(\"turn\", {}).get(\"current\")\n            \n            if current_turn == agent_name:\n                # It's my turn!\n                messages = data.get(\"messages\", [])\n                \n                # 2. History Delta Logic: Get messages since my last turn\n                # Find the index of the last message sent by ME\n                last_my_index = -1\n                for i, m in enumerate(messages):\n                    if m.get(\"from\") == agent_name:\n                        last_my_index = i\n                \n                # If I have never spoken, this is my first turn (or re-entry). \n                # To be safe, we give full history (or maybe a reasonable startup window? No, full history is safer for context).\n                # If last_my_index is -1, we slice from 0 (start).\n                # Context Recovery: Start 3 messages before my last one (Overlap)\n                start_slice_index = max(0, last_my_index - 3)\n                recent_messages = messages[start_slice_index:]\n\n                # 3. Filter for Visibility on this Delta\n                # Visible = Public OR (Private AND (Me==Sender OR Me==Target OR Me.Profile==Sender.Profile))\n                visible_messages = []\n                ", "start_line": 441, "end_line": 490}, {"path": "src/core/logic.py", "content": "                # To be safe, we give full history (or maybe a reasonable startup window? No, full history is safer for context).\n                # If last_my_index is -1, we slice from 0 (start).\n                # Context Recovery: Start 3 messages before my last one (Overlap)\n                start_slice_index = max(0, last_my_index - 3)\n                recent_messages = messages[start_slice_index:]\n\n                # 3. Filter for Visibility on this Delta\n                # Visible = Public OR (Private AND (Me==Sender OR Me==Target OR Me.Profile==Sender.Profile))\n                visible_messages = []\n                \n                agents_map = data.get(\"agents\", {})\n                my_prof = agents_map.get(agent_name, {}).get(\"profile_ref\")\n                \n                for m in recent_messages:\n                    is_public = m.get(\"public\", True)\n                    sender = m.get(\"from\")\n                    target = m.get(\"target\")\n                    \n                    if is_public:\n                        visible_messages.append(m)\n                        continue\n                        \n                    # Private Logic\n                    if sender == agent_name or target == agent_name or agent_name in (m.get(\"audience\") or []):\n                        visible_messages.append(m)\n                    elif my_prof:\n                         sender_prof = agents_map.get(sender, {}).get(\"profile_ref\")\n                         if sender_prof and sender_prof == my_prof:\n                             visible_messages.append(m)\n                \n                # Build Strategic Advice from Connections\n                agents = data.get(\"agents\", {})\n                config = data.get(\"config\", {})\n                \n                backlog_instr = \"\"\n                if config.get(\"enable_backlog\"):\n                    backlog_instr = \"\\n\\n\u26a0\ufe0f BACKLOG ENABLED: You must also consult and update the `BACKLOG.md` file at the root of the repo to track tasks and progress.\"\n\n                my_info = agents.get(agent_name, {})\n                profile_ref = my_info.get(\"profile_ref\")\n                \n                advice_text = \"\"\n                if profile_ref:\n                    profiles = config.get(\"profiles\", [])\n                    profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n                    \n                    if profile and profile.get(\"connections\"):\n                        advice_text = \"\\n\\n--- STRATEGIC ADVICE ---\\n\"\n                        advice_text += \"Based on your connections, here is how you should interact with others:\\n\"\n                        ", "start_line": 481, "end_line": 530}, {"path": "src/core/logic.py", "content": "                \n                advice_text = \"\"\n                if profile_ref:\n                    profiles = config.get(\"profiles\", [])\n                    profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n                    \n                    if profile and profile.get(\"connections\"):\n                        advice_text = \"\\n\\n--- STRATEGIC ADVICE ---\\n\"\n                        advice_text += \"Based on your connections, here is how you should interact with others:\\n\"\n                        \n                        for conn in profile[\"connections\"]:\n                            target_profile = conn.get(\"target\")\n                            ctx = conn.get(\"context\")\n                            \n                            # Resolve Target Profile -> Active Agent IDs\n                            matching_agents = [\n                                aid for aid, adata in agents.items() \n                                if adata.get(\"profile_ref\") == target_profile and aid != agent_name\n                            ]\n                            \n                            if matching_agents:\n                                names_str = \", \".join(matching_agents)\n                                advice_text += f\"- **{target_profile}** is represented by: **{names_str}**. Strategy: {ctx}\\n\"\n                            else:\n                                # Connection exists but no agent with this role is currently active/other than me\n                                advice_text += f\"- **{target_profile}**: No other active agents found. Strategy: {ctx}\\n\"\n\n                        advice_text += \"------------------------\"\n\n                return {\n                    \"status\": \"success\",\n                    \"messages\": visible_messages, # FULL Delta, no truncation\n                    \"instruction\": f\"\ud83d\udea8 TURN GRANTED. You MUST run `tail -n 150 CONVERSATION.md` IMMEDIATELY to see what happened while you were waiting. DO NOT SPEAK before reading the history.{backlog_instr}{advice_text}\"\n                }\n            \n            time.sleep(1)\n            \n        return {\n            \"status\": \"timeout\",\n            \"messages\": [],\n            \"instruction\": \"Still waiting for turn. connection_timeout_imminent. CALL THIS TOOL AGAIN IMMEDIATELY.\"\n        }\n\n    async def wait_for_turn_async(self, agent_name: str, timeout_seconds: int = 60) -> Dict[str, Any]:\n        \"\"\"\n        Async version of wait_for_turn.\n        \"\"\"\n        start_time = time.time()\n        \n        try:", "start_line": 521, "end_line": 570}, {"path": "src/core/logic.py", "content": "            \"instruction\": \"Still waiting for turn. connection_timeout_imminent. CALL THIS TOOL AGAIN IMMEDIATELY.\"\n        }\n\n    async def wait_for_turn_async(self, agent_name: str, timeout_seconds: int = 60) -> Dict[str, Any]:\n        \"\"\"\n        Async version of wait_for_turn.\n        \"\"\"\n        start_time = time.time()\n        \n        try:\n            # Run blocking load() in a separate thread\n            initial_state = await asyncio.to_thread(self.state.load)\n            current_conversation_id = initial_state.get(\"conversation_id\")\n        except Exception:\n            current_conversation_id = None\n\n        while time.time() - start_time < timeout_seconds:\n            try:\n                # Run blocking load() in a separate thread\n                data = await asyncio.to_thread(self.state.load)\n            except Exception:\n                await asyncio.sleep(1)\n                continue\n            \n            # 0. Check for PAUSE\n            if data.get(\"config\", {}).get(\"paused\"):\n                await asyncio.sleep(1)\n                continue\n            \n            # 1. Check for RESET\n            new_conversation_id = data.get(\"conversation_id\")\n            if current_conversation_id and new_conversation_id != current_conversation_id:\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": \"SYSTEM RESET: The conversation has been reset by the user. Forget everything. Re-read your Role and Context.\"\n                }\n                \n            # 1b. Check for Status Reset (Kicked/Reloaded)\n            agent_data = data.get(\"agents\", {}).get(agent_name, {})\n            my_status = agent_data.get(\"status\")\n            if my_status == \"pending_connection\":\n                 return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": STOP_INSTRUCTION\n                }\n\n            # 1c. Check for RELOAD\n            if agent_data.get(\"reload_active\"):", "start_line": 561, "end_line": 610}, {"path": "src/core/logic.py", "content": "            my_status = agent_data.get(\"status\")\n            if my_status == \"pending_connection\":\n                 return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": STOP_INSTRUCTION\n                }\n\n            # 1c. Check for RELOAD\n            if agent_data.get(\"reload_active\"):\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": RELOAD_INSTRUCTION\n                }\n\n            current_turn = data.get(\"turn\", {}).get(\"current\")\n            \n            if current_turn == agent_name:\n                # Reuse logic from sync version (code duplication is acceptable for safety here vs refactoring everything)\n                messages = data.get(\"messages\", [])\n                \n                # 2. History Delta Logic: Get messages since my last turn\n                last_my_index = -1\n                for i, m in enumerate(messages):\n                    if m.get(\"from\") == agent_name:\n                        last_my_index = i\n                \n                # Context Recovery: Start 3 messages before my last one (Overlap)\n                start_slice_index = max(0, last_my_index - 3)\n                recent_messages = messages[start_slice_index:]\n\n                # 3. Filter for Visibility\n                # 3. Filter for Visibility on this Delta\n                # Visible = Public OR (Private AND (Me==Sender OR Me==Target OR Me.Profile==Sender.Profile))\n                visible_messages = []\n                \n                agents_map = data.get(\"agents\", {})\n                my_prof = agents_map.get(agent_name, {}).get(\"profile_ref\")\n                \n                for m in recent_messages:\n                    is_public = m.get(\"public\", True)\n                    sender = m.get(\"from\")\n                    target = m.get(\"target\")\n                    \n                    if is_public:\n                        visible_messages.append(m)\n                        continue\n                        \n                    # Private Logic", "start_line": 601, "end_line": 650}, {"path": "src/core/logic.py", "content": "                for m in recent_messages:\n                    is_public = m.get(\"public\", True)\n                    sender = m.get(\"from\")\n                    target = m.get(\"target\")\n                    \n                    if is_public:\n                        visible_messages.append(m)\n                        continue\n                        \n                    # Private Logic\n                    if sender == agent_name or target == agent_name or agent_name in (m.get(\"audience\") or []):\n                        visible_messages.append(m)\n                    elif my_prof:\n                         sender_prof = agents_map.get(sender, {}).get(\"profile_ref\")\n                         if sender_prof and sender_prof == my_prof:\n                             visible_messages.append(m)\n                \n                agents = data.get(\"agents\", {})\n                config = data.get(\"config\", {})\n                \n                backlog_instr = \"\"\n                if config.get(\"enable_backlog\"):\n                    backlog_instr = \"\\n\\n\u26a0\ufe0f BACKLOG ENABLED: You must also consult and update the `BACKLOG.md` file at the root of the repo to track tasks and progress.\"\n\n                my_info = agents.get(agent_name, {})\n                profile_ref = my_info.get(\"profile_ref\")\n                \n                advice_text = \"\"\n                if profile_ref:\n                    profiles = config.get(\"profiles\", [])\n                    profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n                    if profile and profile.get(\"connections\"):\n                        advice_text = \"\\n\\n--- STRATEGIC ADVICE ---\\nBased on your connections, here is how you should interact with others:\\n\"\n                        for conn in profile[\"connections\"]:\n                            target_profile = conn.get(\"target\")\n                            ctx = conn.get(\"context\")\n                            matching_agents = [aid for aid, adata in agents.items() if adata.get(\"profile_ref\") == target_profile and aid != agent_name]\n                            if matching_agents:\n                                names_str = \", \".join(matching_agents)\n                                advice_text += f\"- **{target_profile}** is represented by: **{names_str}**. Strategy: {ctx}\\n\"\n                            else:\n                                advice_text += f\"- **{target_profile}**: No other active agents found. Strategy: {ctx}\\n\"\n                        advice_text += \"------------------------\"\n\n                return {\n                    \"status\": \"success\",\n                    \"messages\": visible_messages,\n                    \"instruction\": f\"It is your turn. Speak.{backlog_instr}{advice_text}\"\n                }\n            ", "start_line": 641, "end_line": 690}, {"path": "src/core/logic.py", "content": "                            else:\n                                advice_text += f\"- **{target_profile}**: No other active agents found. Strategy: {ctx}\\n\"\n                        advice_text += \"------------------------\"\n\n                return {\n                    \"status\": \"success\",\n                    \"messages\": visible_messages,\n                    \"instruction\": f\"It is your turn. Speak.{backlog_instr}{advice_text}\"\n                }\n            \n            await asyncio.sleep(1) # Non-blocking Sleep\n            \n        return {\n            \"status\": \"timeout\",\n            \"messages\": [],\n            \"instruction\": \"Still waiting for turn. connection_timeout_imminent. CALL THIS TOOL AGAIN IMMEDIATELY.\"\n        }", "start_line": 681, "end_line": 697}, {"path": "src/core/state.py", "content": "import json\nimport os\nimport portalocker\nimport uuid\nimport time\nimport random\nfrom src.utils.logger import get_logger\nfrom dataclasses import dataclass, field\nfrom typing import List, Dict, Any, Optional\n\n# Resolve absolute path -> Now handled in src.config\nfrom src.config import STATE_FILE\n\n# Type alias or check if we need to convert to str\n# Usually Path objects are fine in open(), but for safety/typing we use them directly\n\nlogger = get_logger()\n\nfrom src.core.models import GlobalState\nfrom pydantic import ValidationError\n\n@dataclass\nclass StateStore:\n    \"\"\"\n    Manages access to the shared state.json file with locking.\n    \"\"\"\n    file_path: str = str(STATE_FILE) # Ensure str type for portalocker compatibility\n    \n    def __post_init__(self):\n        # Allow override via env var for testing\n        if os.environ.get(\"MULTI_AGENT_STATE_PATH\"):\n            self.file_path = os.environ[\"MULTI_AGENT_STATE_PATH\"]\n\n    def _initialize_if_missing(self):\n        if not os.path.exists(self.file_path):\n            initial_state = {\n                \"messages\": [],\n                \"conversation_id\": str(uuid.uuid4()),\n                \"turn\": {\"current\": None, \"next\": None},\n                \"agents\": {},\n                \"config\": {\"total_agents\": 2}\n            }\n            # Use atomic write pattern with temp file if robust, but simple write is fine for init\n            with open(self.file_path, \"w\") as f:\n                json.dump(initial_state, f, indent=2)\n\n    def load(self) -> Dict[str, Any]:\n        \"\"\"\n        Reads with Shared Lock (Non-blocking preference).\n        \"\"\"", "start_line": 1, "end_line": 50}, {"path": "src/core/state.py", "content": "                \"config\": {\"total_agents\": 2}\n            }\n            # Use atomic write pattern with temp file if robust, but simple write is fine for init\n            with open(self.file_path, \"w\") as f:\n                json.dump(initial_state, f, indent=2)\n\n    def load(self) -> Dict[str, Any]:\n        \"\"\"\n        Reads with Shared Lock (Non-blocking preference).\n        \"\"\"\n        self._initialize_if_missing()\n        \n        # Try-Loop for robustness\n        for i in range(5): # Increased retries\n            try:\n                # Use LOCK_SH | LOCK_NB to ensure we fail fast and retry if locked\n                flags = portalocker.LOCK_SH | portalocker.LOCK_NB\n                with portalocker.Lock(self.file_path, 'r', flags=flags) as f:\n                    content = f.read()\n                    if not content: return {}\n                    data = json.loads(content)\n                    \n                    # Validation\n                    try:\n                        GlobalState.model_validate(data)\n                    except ValidationError as e:\n                        logger.error(\"StateStore\", f\"State Validation Failed: {e}\")\n                    \n                    return data\n            except (portalocker.LockException, BlockingIOError, OSError):\n                time.sleep(random.uniform(0.05, 0.2))\n                continue\n            except json.JSONDecodeError:\n                return {}\n        \n        # Fallback: Just try reading without lock (dirty read)\n        # This prevents UI hang if someone died holding lock\n        try:\n            with open(self.file_path, 'r') as f:\n                return json.load(f)\n        except:\n             return {}\n\n    def update(self, callback) -> Any:\n        \"\"\"\n        Atomically updates the state with Exclusive Lock.\n        \"\"\"\n        self._initialize_if_missing()\n        \n        # Retry loop for acquiring write lock", "start_line": 41, "end_line": 90}, {"path": "src/core/state.py", "content": "        except:\n             return {}\n\n    def update(self, callback) -> Any:\n        \"\"\"\n        Atomically updates the state with Exclusive Lock.\n        \"\"\"\n        self._initialize_if_missing()\n        \n        # Retry loop for acquiring write lock\n        # Increased to 50 to handle high contention during startup bursts\n        max_retries = 50 \n        for i in range(max_retries):\n            try:\n                # LOCK_EX | LOCK_NB\n                flags = portalocker.LOCK_EX | portalocker.LOCK_NB\n                \n                # 'r+' is needed to read then write.\n                with portalocker.Lock(self.file_path, 'r+', flags=flags) as f:\n                    f.seek(0)\n                    content = f.read()\n                    \n                    if not content:\n                         state = {}\n                    else:\n                        try:\n                            state = json.loads(content)\n                        except json.JSONDecodeError:\n                            # Critical failure or empty file\n                            state = {}\n                    \n                    # Apply transformation\n                    result = callback(state)\n                    \n                    # Write back\n                    f.seek(0)\n                    f.truncate()\n                    json.dump(state, f, indent=2)\n                    f.flush()\n                    os.fsync(f.fileno())\n                    \n                    return result\n            except (portalocker.LockException, BlockingIOError):\n                # Backoff\n                sleep_time = random.uniform(0.1, 0.5)\n                time.sleep(sleep_time)\n                continue\n            except Exception as e:\n                logger.error(\"StateStore\", f\"Update Error: {e}\")\n                raise e", "start_line": 81, "end_line": 130}, {"path": "src/core/state.py", "content": "                    \n                    return result\n            except (portalocker.LockException, BlockingIOError):\n                # Backoff\n                sleep_time = random.uniform(0.1, 0.5)\n                time.sleep(sleep_time)\n                continue\n            except Exception as e:\n                logger.error(\"StateStore\", f\"Update Error: {e}\")\n                raise e\n        \n        raise Exception(\"Failed to acquire state lock after multiple retries.\")", "start_line": 121, "end_line": 132}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict]) -> str:\n    \"\"\"\n    Formats the last 10 messages for context injection.\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    # Take last 10\n    recent = messages[-10:]\n    output = []\n    \n    for m in recent:", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats the last 10 messages for context injection.\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    # Take last 10\n    recent = messages[-10:]\n    output = []\n    \n    for m in recent:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        output.append(f\"- **{sender}** -> {target_display}: {content}\")\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    ", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     \n                     conv_history_str = _format_conversation_history(visible_msgs)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            # Fallback (Busy or Aborted Wait) -> Standard Template Response\n            if logger: logger.log(\"TURN\", \"System\", \"Turn passed to USER (Non-Blocking / Busy). Agent retains control.\")\n            \n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    ", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1081, "end_line": 1114}, {"path": "src/utils/logger.py", "content": "import json\nimport time\nimport sys\nimport os\nfrom threading import Lock\n\nclass GameLogger:\n    _instance = None\n    _lock = Lock()\n    \n    def __new__(cls, log_file=\"game_transcript.jsonl\"):\n        with cls._lock:\n            if cls._instance is None:\n                cls._instance = super(GameLogger, cls).__new__(cls)\n                cls._instance._init(log_file)\n            return cls._instance\n\n    def _init(self, log_file):\n        # Use LOGS_DIR from config\n        from src.config import LOGS_DIR\n        self.log_dir = str(LOGS_DIR)\n        if not os.path.exists(self.log_dir):\n            os.makedirs(self.log_dir, exist_ok=True)\n            \n        self.log_path = os.path.join(self.log_dir, log_file)\n        self.file_lock = Lock()\n\n    def reset(self):\n        \"\"\"Clear the log file content.\"\"\"\n        with self.file_lock:\n            with open(self.log_path, \"w\", encoding=\"utf-8\") as f:\n                f.write(\"\") # Truncate\n\n    def log(self, event_type: str, agent: str, content: str, metadata: dict = None):\n        \"\"\"\n        Log an event to the JSONL file.\n        \"\"\"\n        entry = {\n            \"timestamp\": time.time(),\n            \"time_str\": time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()),\n            \"type\": event_type,\n            \"agent\": agent,\n            \"content\": content,\n            \"metadata\": metadata or {}\n        }\n        \n        json_line = json.dumps(entry, ensure_ascii=False)\n        \n        # File Output\n        with self.file_lock:", "start_line": 1, "end_line": 50}, {"path": "src/utils/logger.py", "content": "            \"type\": event_type,\n            \"agent\": agent,\n            \"content\": content,\n            \"metadata\": metadata or {}\n        }\n        \n        json_line = json.dumps(entry, ensure_ascii=False)\n        \n        # File Output\n        with self.file_lock:\n            with open(self.log_path, \"a\", encoding=\"utf-8\") as f:\n                f.write(json_line + \"\\n\")\n                \n        # Console Output (stderr for MCP visibility)\n        try:\n            # Format: [TYPE] Agent: Content\n            short_content = content[:100] + \"...\" if len(content) > 100 else content\n            print(f\"[{event_type}] {agent}: {short_content}\", file=sys.stderr)\n        except:\n            pass\n\n    def error(self, agent: str, error_msg: str, context: str = \"\"):\n        self.log(\"ERROR\", agent, error_msg, {\"context\": context})\n\n# Global instance accessor\n_logger = None\ndef get_logger():\n    global _logger\n    if _logger is None:\n        _logger = GameLogger()\n    return _logger", "start_line": 41, "end_line": 71}, {"path": "src/scripts/init_presets.py", "content": "import sys\nimport os\nimport shutil\nfrom pathlib import Path\n\n# Add project root to sys.path\nROOT_DIR = Path(__file__).resolve().parent.parent.parent\nsys.path.insert(0, str(ROOT_DIR))\n\n# Use the config module logic\ntry:\n    from src.config import GLOBAL_PRESET_DIR, ASSETS_DIR\nexcept ImportError:\n    # Failback/Setup for when running directly\n    print(\"WARNING: Direct import failed, adjusting path manually.\")\n    sys.path.append(str(ROOT_DIR))\n    from src.config import GLOBAL_PRESET_DIR, ASSETS_DIR\n\ndef init_presets():\n    print(f\"\ud83d\udd04 [Preset Init] Initializing Presets...\")\n    asset_preset_dir = ASSETS_DIR / \"presets\"\n    \n    if not asset_preset_dir.exists():\n        print(f\"\u26a0\ufe0f [Preset Init] Assets dir not found: {asset_preset_dir}\")\n        return\n\n    GLOBAL_PRESET_DIR.mkdir(parents=True, exist_ok=True)\n\n    count = 0\n    skipped = 0\n    for f in os.listdir(asset_preset_dir):\n        if f.endswith(\".json\"):\n            src = asset_preset_dir / f\n            dst = GLOBAL_PRESET_DIR / f\n            \n            # Copy if not exists\n            if not dst.exists():\n                shutil.copy(src, dst)\n                print(f\"\u2705 [Preset Init] Installed: {f}\")\n                count += 1\n            else:\n                skipped += 1\n                \n    print(f\"\u2728 [Preset Init] Complete ({count} installed, {skipped} existing skipped).\")\n\nif __name__ == \"__main__\":\n    init_presets()", "start_line": 1, "end_line": 47}, {"path": "src/scripts/init_presets.py", "content": "            else:\n                skipped += 1\n                \n    print(f\"\u2728 [Preset Init] Complete ({count} installed, {skipped} existing skipped).\")\n\nif __name__ == \"__main__\":\n    init_presets()", "start_line": 41, "end_line": 47}, {"path": "src/scripts/setup_werewolf.py", "content": "import sys\nimport os\nimport uuid\nimport random\n\n# Add src to path\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"..\")))\nfrom src.core.state import StateStore\n\ndef setup_werewolf_anonymized():\n    store = StateStore()\n    \n    # Reset Logger\n    try:\n        from src.utils.logger import get_logger\n        get_logger().reset()\n    except ImportError:\n        pass\n    \n    def update_logic(state):\n        # 1. Clear State\n        state[\"conversation_id\"] = str(uuid.uuid4())\n        state[\"messages\"] = []\n        state[\"turn\"] = {\"current\": None, \"next\": None}\n        \n        # 2. Global Context\n        state.setdefault(\"config\", {})[\"context\"] = (\n            \"Nous jouons au Loup-Garou de Thiercelieux. \"\n            \"C'est la Nuit. Tous le monde dort. \"\n            \"Le MJ (Maitre du Jeu) va orchestrer les tours. \"\n            \"Les Loups doivent se mettre d'accord pour tuer un Villageois. \"\n            \"La Voyante peut voir un r\u00f4le. La Sorci\u00e8re peut tuer ou sauver. \"\n            \"IMPORTANT: Les identit\u00e9s sont cach\u00e9es derri\u00e8re 'Habitant #N'.\"\n        )\n        \n        profiles = []\n        \n        # --- PROFILES ---\n        # Schema: \n        # name: Internal ID (for connections)\n        # description: Internal Admin Note\n        # display_name: Public Chat Name (Base)\n        # public_description: Public Chat Description\n        \n        # MJ\n        profiles.append({\n            \"name\": \"MaitreDuJeu\",\n            \"description\": \"Admin du jeu\",\n            \"display_name\": \"MaitreDuJeu\",\n            \"public_description\": \"L'Orchestrateur\",", "start_line": 1, "end_line": 50}, {"path": "src/scripts/setup_werewolf.py", "content": "        # description: Internal Admin Note\n        # display_name: Public Chat Name (Base)\n        # public_description: Public Chat Description\n        \n        # MJ\n        profiles.append({\n            \"name\": \"MaitreDuJeu\",\n            \"description\": \"Admin du jeu\",\n            \"display_name\": \"MaitreDuJeu\",\n            \"public_description\": \"L'Orchestrateur\",\n            \"system_prompt\": \"Tu es le Maitre du Jeu. Tu diriges la partie. Appelle les r\u00f4les : Voyante, puis Loups, puis Sorci\u00e8re.\",\n            \"capabilities\": [\"public\", \"private\", \"audience\", \"open\"], \n            \"connections\": [],\n            \"count\": 1\n        })\n        \n        # Villageois\n        profiles.append({\n            \"name\": \"Villageois\",\n            \"description\": \"Simple Villageois\",\n            \"display_name\": \"Habitant\",\n            \"public_description\": \"Citoyen de Thiercelieux\",\n            \"system_prompt\": \"Tu es un simple Villageois. Tu dors la nuit. Tu ne connais pas les autres r\u00f4les.\",\n            \"capabilities\": [\"public\", \"audience\"],\n            \"connections\": [\n                {\"target\": \"MaitreDuJeu\", \"context\": \"Ob\u00e9is au MJ.\"}\n            ],\n            \"count\": 5\n        })\n        \n        # Loup-Garou\n        profiles.append({\n            \"name\": \"LoupGarou\",\n            \"description\": \"Les Tueurs\",\n            \"display_name\": \"Habitant\",\n            \"public_description\": \"Citoyen de Thiercelieux\",\n            \"system_prompt\": \"Tu es un Loup-Garou. Tu chasses la nuit avec tes alli\u00e9s.\",\n            \"capabilities\": [\"public\", \"private\", \"audience\"],\n            \"connections\": [\n                {\"target\": \"MaitreDuJeu\", \"context\": \"Ob\u00e9is au MJ.\"},\n                {\"target\": \"LoupGarou\", \"context\": \"Ton Alli\u00e9 Loup. Coop\u00e8re.\"}\n            ],\n            \"count\": 2\n        })\n\n        # Voyante\n        profiles.append({\n            \"name\": \"Voyante\",\n            \"description\": \"Peut voir les r\u00f4les\",\n            \"display_name\": \"Habitant\",", "start_line": 41, "end_line": 90}, {"path": "src/scripts/setup_werewolf.py", "content": "                {\"target\": \"LoupGarou\", \"context\": \"Ton Alli\u00e9 Loup. Coop\u00e8re.\"}\n            ],\n            \"count\": 2\n        })\n\n        # Voyante\n        profiles.append({\n            \"name\": \"Voyante\",\n            \"description\": \"Peut voir les r\u00f4les\",\n            \"display_name\": \"Habitant\",\n            \"public_description\": \"Citoyen de Thiercelieux\",\n            \"system_prompt\": \"Tu es la Voyante. Chaque nuit, tu peux demander au MJ de r\u00e9v\u00e9ler le r\u00f4le d'un joueur.\",\n            \"capabilities\": [\"public\", \"private\", \"audience\"],\n            \"connections\": [\n                {\"target\": \"MaitreDuJeu\", \"context\": \"Demande au MJ de voir une carte.\"}\n            ],\n            \"count\": 1\n        })\n\n        # Sorci\u00e8re\n        profiles.append({\n            \"name\": \"Sorciere\",\n            \"description\": \"A des potions\",\n            \"display_name\": \"Habitant\",\n            \"public_description\": \"Citoyen de Thiercelieux\",\n            \"system_prompt\": \"Tu es la Sorci\u00e8re. Tu as une potion de vie et de mort.\",\n            \"capabilities\": [\"public\", \"private\", \"audience\"],\n            \"connections\": [\n                {\"target\": \"MaitreDuJeu\", \"context\": \"Indique au MJ si tu utilises tes potions.\"}\n            ],\n            \"count\": 1\n        })\n        \n        state[\"config\"][\"profiles\"] = profiles\n        state[\"config\"][\"total_agents\"] = 10 \n        \n        # --- GENERATE INSTANCES ---\n        # 1. Flatten list of needed agents\n        # List of dicts: { \"profile\": p, \"role\": prompt }\n        pending_slots = []\n        \n        for p in profiles:\n            count = p.get(\"count\", 0)\n            for _ in range(count):\n                pending_slots.append({\n                    \"profile_ref\": p[\"name\"],\n                    \"role\": p[\"system_prompt\"],\n                    \"display_base\": p.get(\"display_name\", p[\"name\"]),\n                    \"public_desc\": p.get(\"public_description\", \"\")\n                })", "start_line": 81, "end_line": 130}, {"path": "src/scripts/setup_werewolf.py", "content": "        \n        for p in profiles:\n            count = p.get(\"count\", 0)\n            for _ in range(count):\n                pending_slots.append({\n                    \"profile_ref\": p[\"name\"],\n                    \"role\": p[\"system_prompt\"],\n                    \"display_base\": p.get(\"display_name\", p[\"name\"]),\n                    \"public_desc\": p.get(\"public_description\", \"\")\n                })\n        \n        # 2. Shuffle to randomize IDs\n        # (MJ is usually unique/fixed name, but strict shuffle is fairer if multiple MJs existed. \n        # Here MJ has display_name=\"MaitreDuJeu\" so he will be distinct from \"Habitant\")\n        random.shuffle(pending_slots)\n        \n        # 3. Assign IDs using Global Counters per Display Base\n        counters = {} # \"Habitant\" -> 1, \"MaitreDuJeu\" -> 1\n        new_agents = {}\n        \n        for slot in pending_slots:\n            base = slot[\"display_base\"]\n            counters.setdefault(base, 0)\n            counters[base] += 1\n            \n            # ID Generation\n            # If total of this base > 1 -> Add #Number\n            # But here we want strict anonymity. \"Habitant #1\" is standard.\n            # Even if only 1, \"Habitant #1\" is fine, or \"Habitant\". \n            # Let's count totals first? \n            # Logic: If duplicate bases exist, use suffix.\n            \n            # Simple approach: Always append #N if base is \"Habitant\".\n            # For \"MaitreDuJeu\" (count=1), maybe just \"MaitreDuJeu\".\n            \n            # Let's pre-count totals\n            total_for_base = sum(1 for s in pending_slots if s[\"display_base\"] == base)\n            \n            if total_for_base > 1:\n                agent_id = f\"{base} #{counters[base]}\"\n            else:\n                agent_id = base\n                \n            new_agents[agent_id] = {\n                \"role\": slot[\"role\"],\n                \"status\": \"pending_connection\",\n                \"profile_ref\": slot[\"profile_ref\"]\n            }\n        # 4. Omniscience for MaitreDuJeu\n        # Find the agent that has the MaitreDuJeu profile", "start_line": 121, "end_line": 170}, {"path": "src/scripts/setup_werewolf.py", "content": "            else:\n                agent_id = base\n                \n            new_agents[agent_id] = {\n                \"role\": slot[\"role\"],\n                \"status\": \"pending_connection\",\n                \"profile_ref\": slot[\"profile_ref\"]\n            }\n        # 4. Omniscience for MaitreDuJeu\n        # Find the agent that has the MaitreDuJeu profile\n        mj_real_id = None\n        for aid, d in new_agents.items():\n            if d[\"profile_ref\"] == \"MaitreDuJeu\":\n                mj_real_id = aid\n                break\n        \n        if mj_real_id:\n            mj_conns = []\n            \n            # Create a \"Truth List\" for the MJ\n            for other_id, other_data in new_agents.items():\n                if other_id == mj_real_id:\n                    continue\n                \n                # Lookup internal description from Profile\n                p_ref = other_data[\"profile_ref\"]\n                p_desc = \"Inconnu\"\n                \n                # Find profile doc\n                for p in profiles:\n                    if p[\"name\"] == p_ref:\n                        p_desc = p.get(\"description\", p_ref)\n                        break\n                \n                mj_conns.append({\n                    \"target\": other_id, \n                    \"context\": f\"Identit\u00e9 r\u00e9elle: {p_desc}\"\n                })\n            \n            # Assign connections to the INSTANCE\n            new_agents[mj_real_id][\"connections\"] = mj_conns\n            print(f\"[Setup] Injected {len(mj_conns)} truth connections into {mj_real_id}\")\n            \n        else:\n             print(\"[Setup] WARNING: MaitreDuJeu profile not found in active agents. Omniscience skipped.\")\n\n        state[\"agents\"] = new_agents\n        \n        return \"Werewolf Anonymized Setup Complete (10 roles, shuffled IDs)\"\n", "start_line": 161, "end_line": 210}, {"path": "src/scripts/setup_werewolf.py", "content": "            new_agents[mj_real_id][\"connections\"] = mj_conns\n            print(f\"[Setup] Injected {len(mj_conns)} truth connections into {mj_real_id}\")\n            \n        else:\n             print(\"[Setup] WARNING: MaitreDuJeu profile not found in active agents. Omniscience skipped.\")\n\n        state[\"agents\"] = new_agents\n        \n        return \"Werewolf Anonymized Setup Complete (10 roles, shuffled IDs)\"\n\n    msg = store.update(update_logic)\n    print(msg)\n\nif __name__ == \"__main__\":\n    setup_werewolf_anonymized()\n", "start_line": 201, "end_line": 216}, {"path": "src/scripts/utils/inspect_context.py", "content": "from mcp.server.fastmcp import Context\nprint(help(Context))", "start_line": 1, "end_line": 2}, {"path": "src/scripts/utils/verify_system.py", "content": "import sys\nimport os\nfrom src.utils.logger import get_logger\n\nlogger = get_logger()\nlogger.log(\"INFO\", \"Test\", \"Starting system checks...\")\n\ntry:\n    from src.config import PROJECT_ROOT\n    print(f\"\u2705 Config OK: {PROJECT_ROOT}\")\nexcept ImportError as e:\n    print(f\"\u274c Config Fail: {e}\")\n\ntry:\n    from src.core.models import GlobalState\n    print(f\"\u2705 Models OK\")\nexcept ImportError as e:\n    print(f\"\u274c Models Fail: {e}\")\n\ntry:\n    from src.core.state import StateStore\n    store = StateStore()\n    data = store.load()\n    print(f\"\u2705 State Load OK. Keys: {list(data.keys())}\")\nexcept Exception as e:\n    print(f\"\u274c State Load Fail: {e}\")\n\nprint(\"\u2705 Checks Complete\")", "start_line": 1, "end_line": 28}, {"path": "src/scripts/utils/inspect_last_messages.py", "content": "import json\nimport time\n\ntry:\n    with open(\"state.json\", \"r\") as f:\n        data = json.load(f)\n        msgs = data.get(\"messages\", [])\n        print(f\"Total messages: {len(msgs)}\")\n        print(\"--- LAST 10 MESSAGES ---\")\n        for m in msgs[-10:]:\n            ts = m.get('timestamp', 0)\n            time_str = time.strftime('%H:%M:%S', time.localtime(ts))\n            sender = m.get('from')\n            target = m.get('target', 'all')\n            content = m.get('content', '')\n            print(f\"[{time_str}] {sender} -> {target}: {content[:100].replace(chr(10), ' ')}...\")\nexcept Exception as e:\n    print(e)", "start_line": 1, "end_line": 18}, {"path": "src/scripts/utils/test_path.py", "content": "import sys\nimport os\n\nprint(f\"CWD: {os.getcwd()}\")\nprint(f\"Path: {sys.path}\")\n\ntry:\n    from src.config import PROJECT_ROOT, TEMPLATE_DIR, MEMORY_DIR, STATE_FILE\n    print(\"\u2705 src.config imported successfully\")\n    print(f\"PROJECT_ROOT: {PROJECT_ROOT}\")\n    print(f\"TEMPLATE_DIR: {TEMPLATE_DIR}\")\n    print(f\"MEMORY_DIR: {MEMORY_DIR}\")\n    print(f\"STATE_FILE: {STATE_FILE}\")\nexcept Exception as e:\n    print(f\"\u274c Failed to import src.config: {e}\")\n\ntry:\n    from src.core.state import StateStore\n    print(\"\u2705 src.core.state imported successfully\")\nexcept Exception as e:\n    print(f\"\u274c Failed to import src.core.state: {e}\")\n\ntry:\n    from src.core.server import mcp\n    print(\"\u2705 src.core.server imported successfully\")\nexcept Exception as e:\n    print(f\"\u274c Failed to import src.core.server: {e}\")", "start_line": 1, "end_line": 27}, {"path": "src/scripts/utils/verify_user_flow.py", "content": "\nimport sys\nimport os\nimport json\nimport time\n\n# Mock State\nsys.path.append(os.getcwd())\nfrom src.core.logic import Engine\n\ndef test_user_flow():\n    print(\"--- Testing User Flow Integration ---\")\n    \n    # 1. Setup Engine & State\n    engine = Engine()\n    \n    # Reset State for test\n    engine.state.file_path = \"test_state_user.json\"\n    if os.path.exists(\"test_state_user.json\"):\n        os.remove(\"test_state_user.json\")\n        \n    def init_state(s):\n        s[\"agents\"] = {\n            \"Agent1\": {\n                \"role\": \"You are Agent 1\", \n                \"profile_ref\": \"Agent\", \n                \"status\": \"connected\",\n                \"connections\": [{\"target\": \"User\", \"context\": \"Report to user\"}]\n            }\n        }\n        s[\"config\"] = {\n            \"total_agents\": 1, \n            \"context\": \"Test Context\",\n            \"profiles\": [\n                {\"name\": \"Agent\", \"capabilities\": [\"public\", \"private\", \"open\"], \"connections\": []}\n            ]\n        }\n        s[\"turn\"] = {\"current\": \"Agent1\"}\n        return \"Init Done\"\n        \n    engine.state.update(init_state)\n    \n    # 2. Agent1 talks to User (Should NOT change turn)\n    print(\"\\n[Action] Agent1 talks to User...\")\n    res = engine.post_message(\n        from_agent=\"Agent1\",\n        content=\"Hello User!\",\n        public=False,\n        next_agent=\"User\",\n        audience=[]", "start_line": 1, "end_line": 50}, {"path": "src/scripts/utils/verify_user_flow.py", "content": "    engine.state.update(init_state)\n    \n    # 2. Agent1 talks to User (Should NOT change turn)\n    print(\"\\n[Action] Agent1 talks to User...\")\n    res = engine.post_message(\n        from_agent=\"Agent1\",\n        content=\"Hello User!\",\n        public=False,\n        next_agent=\"User\",\n        audience=[]\n    )\n    print(f\"Result: {res}\")\n    \n    # Verify State\n    data = engine.state.load()\n    last_msg = data[\"messages\"][-1]\n    current_turn = data[\"turn\"][\"current\"]\n    \n    assert last_msg[\"target\"] == \"User\", \"Target should be User\"\n    assert current_turn == \"Agent1\", f\"Turn should remain Agent1, but is {current_turn}\"\n    \n    # 3. User replies (Inject)\n    print(\"\\n[Action] User replies...\")\n    def user_reply(s):\n        s[\"messages\"].append({\n            \"from\": \"User\",\n            \"content\": \"Good job.\",\n            \"public\": False,\n            \"target\": \"Agent1\",\n            \"timestamp\": time.time()\n        })\n        return \"Replied\"\n    engine.state.update(user_reply)\n    \n    # 4. Agent1 talks to another agent (simulated, no other agent exists but logic should allow turn change attempt)\n    # We need to add Agent2 for this test\n    def add_agent2(s):\n        s[\"agents\"][\"Agent2\"] = {\"profile_ref\": \"Agent\", \"status\": \"connected\"}\n        s[\"config\"][\"profiles\"][0][\"connections\"].append({\"target\": \"Agent\", \"context\": \"friend\"}) \n        # Need to fix profile connection logic for the test to pass `check_target`\n        # Or just use OPEN mode (Agent has 'open' cap)\n        return \"Added Agent2\"\n    engine.state.update(add_agent2)\n    \n    print(\"\\n[Action] Agent1 passes turn to Agent2...\")\n    res = engine.post_message(\n        from_agent=\"Agent1\",\n        content=\"I spoke to user.\",\n        public=True,\n        next_agent=\"Agent2\",", "start_line": 41, "end_line": 90}, {"path": "src/scripts/utils/verify_user_flow.py", "content": "        # Or just use OPEN mode (Agent has 'open' cap)\n        return \"Added Agent2\"\n    engine.state.update(add_agent2)\n    \n    print(\"\\n[Action] Agent1 passes turn to Agent2...\")\n    res = engine.post_message(\n        from_agent=\"Agent1\",\n        content=\"I spoke to user.\",\n        public=True,\n        next_agent=\"Agent2\",\n        audience=[]\n    )\n    print(f\"Result: {res}\")\n    \n    data = engine.state.load()\n    current_turn = data[\"turn\"][\"current\"]\n    assert current_turn == \"Agent2\", f\"Turn should be Agent2, is {current_turn}\"\n    \n    print(\"\\n\u2705 Verification Successful!\")\n    if os.path.exists(\"test_state_user.json\"):\n        os.remove(\"test_state_user.json\")\n\nif __name__ == \"__main__\":\n    test_user_flow()", "start_line": 81, "end_line": 104}, {"path": "src/scripts/utils/configure_mcp.py", "content": "import json\nimport os\nimport sys\nimport argparse\nfrom pathlib import Path\n\ndef configure_mcp(name, project_path, is_dev=False):\n    \"\"\"\n    Configures MCP for Gemini Antigravity, Cursor IDE, and Gemini CLI.\n    \"\"\"\n    project_path = os.path.abspath(project_path)\n    server_script = os.path.join(project_path, 'src', 'core', 'server.py')\n    \n    if not os.path.exists(server_script):\n        print(f\"Error: Server script not found at {server_script}\")\n        sys.exit(1)\n\n    # Command to run the MCP server\n    # We use 'sh -c' to ensure we can 'cd' and 'uv run' properly\n    command_str = f'cd {project_path} && uv run python {server_script}'\n    \n    server_config = {\n        'command': 'sh',\n        'args': ['-c', command_str],\n        'env': {}\n    }\n\n    # Paths to configure\n    configs = [\n        os.path.expanduser('~/.gemini/antigravity/mcp_config.json'),\n        os.path.expanduser('~/.cursor/mcp.json'),\n        os.path.expanduser('~/.gemini/settings.json')\n    ]\n\n    for config_path in configs:\n        try:\n            # Ensure directory exists\n            os.makedirs(os.path.dirname(config_path), exist_ok=True)\n            \n            if os.path.exists(config_path):\n                with open(config_path, 'r') as f:\n                    try:\n                        data = json.load(f)\n                    except json.JSONDecodeError:\n                        print(f\"Warning: {config_path} is invalid JSON. Overwriting.\")\n                        data = {\"mcpServers\": {}}\n            else:\n                data = {\"mcpServers\": {}}\n\n            if 'mcpServers' not in data:", "start_line": 1, "end_line": 50}, {"path": "src/scripts/utils/configure_mcp.py", "content": "                with open(config_path, 'r') as f:\n                    try:\n                        data = json.load(f)\n                    except json.JSONDecodeError:\n                        print(f\"Warning: {config_path} is invalid JSON. Overwriting.\")\n                        data = {\"mcpServers\": {}}\n            else:\n                data = {\"mcpServers\": {}}\n\n            if 'mcpServers' not in data:\n                data['mcpServers'] = {}\n\n            # Add/Update the server\n            data['mcpServers'][name] = server_config\n            \n            # If it's the main server, maybe remove the dev one to clean up? \n            # Or vice-versa? No, let's keep them separate as requested.\n\n            with open(config_path, 'w') as f:\n                json.dump(data, f, indent=2)\n            \n            print(f\"\u2705 Updated {config_path}\")\n\n        except Exception as e:\n            print(f\"\u274c Failed to update {config_path}: {e}\")\n            # We don't exit here to try the next config, but we'll exit at the end if any failed?\n            # User rule: Fail-Fast. Let's fail if we can't write a config we expected to be able to.\n            sys.exit(1)\n    \n    # Inform about Gemini CLI if not found\n    import shutil\n    if not shutil.which('gemini'):\n        print(\"\\n\ud83d\udca1 Tip: Gemini CLI not found. To use it with this MCP, install it with:\")\n        print(\"   npm install -g @google/gemini-cli\")\n\nif __name__ == \"__main__\":\n    parser = argparse.ArgumentParser(description='Configure MCP for IDEs')\n    parser.add_argument('--name', required=True, help='Name of the MCP server')\n    parser.add_argument('--path', required=True, help='Path to the project root')\n    parser.add_argument('--dev', action='store_true', help='Is this a development installation')\n    \n    args = parser.parse_args()\n    configure_mcp(args.name, args.path, args.dev)", "start_line": 41, "end_line": 83}, {"path": "src/scripts/utils/configure_mcp.py", "content": "    \n    args = parser.parse_args()\n    configure_mcp(args.name, args.path, args.dev)", "start_line": 81, "end_line": 83}, {"path": "docs/TECHNICAL_AUDIT.md", "content": "# Technical Audit & Robustness Plan\n**Date:** 2026-01-12\n**Author:** Tech Lead\n\n## 1. Fragility Analysis (`src/core/server.py` & `src/core/state.py`)\n\n### A. Path Resolution & Imports\n- **Current State**: Uses `sys.path.append(...)` and `os.path.join(..., \"..\", \"..\")` quirks to resolve paths.\n- **Risk**: High. Moving the entry point or installing as a package in a different environment will break imports and asset loading.\n- **Recommendation**: Switch to `pathlib` for robust, platform-independent path handling. Standardize the `src` package to avoid `sys.path` manipulation.\n\n### B. File-Based State Locking (`portalocker`)\n- **Current State**: Uses `portalocker` with a retry loop on `state.json`.\n- **Risk**: Moderate to High.\n    - **Stale Locks**: If a process crashes while holding an exclusive lock (`LOCK_EX`), the entire system may hang until manual intervention.\n    - **Contention**: With loose retries and `time.sleep`, high-frequency updates (multiple agents talking) will cause latency spikes.\n- **Recommendation**: \n    - Short-term: Implement a \"Lock TTL\" or \"Steal Lock\" mechanism if the lock file is too old.\n    - Long-term: Migrate to SQLite for atomic, concurrent access without file locking fragility.\n\n## 2. Logic Verification (`src/core/logic.py`)\n\n### A. Turn Management (\"The User Exception\")\n- **Observation**: `post_message` treats `next_agent=\"User\"` as a special case where the turn is *not* passed. The agent retains the turn to wait for a reply.\n- **Verdict**: Valid logic for \"Human-in-the-loop\" but risky. If the User never replies (or the wait times out), the Agent might get stuck or the turn never advances.\n- **Fix**: Ensure `wait_for_user` has a strict timeout that defaults to specific fallbacks (e.g., auto-pass turn to PM or self) to prevent deadlock.\n\n### B. Async/Sync Hybrid\n- **Observation**: `logic.py` implements both struct `wait_for_turn` (Blocking) and `wait_for_turn_async`. \n- **Risk**: Mixing blocking I/O (file reads) in async loops can starve the event loop. `wait_for_all_agents_async` correctly uses `asyncio.to_thread`, which is good.\n\n## 3. Implementation Plan (Operation Self-Repair)\n\n### Phase 1: Hardening (Immediate)\n1. **Refactor Pathing**: Replace `os.path` soup with `pathlib.Path`.\n2. **Sanitize Logging**: Replace distributed `print(..., file=sys.stderr)` with the centralized `src.utils.logger`.\n3. **Type Safety**: Introduce `TypedDict` or `Pydantic` models for the `state` dictionary to prevent schema drift errors (e.g., missing \"config\" keys).\n\n### Phase 2: Architecture\n1. **State Database**: Evaluate SQLite replacement for `state.json`.\n2. **Deadlock Prevention**: Add a \"Turn Watchdog\" system agent that resets the turn if an agent is silent > 5 minutes.", "start_line": 1, "end_line": 41}, {"path": "docs/TECHNICAL_AUDIT.md", "content": "2. **Deadlock Prevention**: Add a \"Turn Watchdog\" system agent that resets the turn if an agent is silent > 5 minutes.", "start_line": 41, "end_line": 41}, {"path": "docs/BACKLOG.md", "content": "# \ud83d\udccb Product Backlog\n\n## \ud83c\udfc3 Current Sprint: Application Self-Improvement\n\n### 1. System Health Audit & Bug Fixes\n- **Status**: \u2705 Ready for Release (PO Validated)\n- **Tasks**:\n    - [x] Refactor Paths to `pathlib`\n    - [x] Centralize Logging\n    - [x] Pydantic State Schema\n\n### 2. (NEW) UX: Unified Chat Interface\n- **As a**: User\n- **I want to**: See Direct Messages and Public Chat in a single unified view (or easily togglable)\n- **So that**: I don't have to switch pages constantly.\n- **Status**: \u2705 Released (v1.1.0)\n- **Priority**: High (UX Friction)\n\n## \ud83c\udfc3 Sprint 2: Seamless Chat (Discord-like)\n\n### 3. UX: Hybrid Stream & Inline Actions\n- **As a**: User\n- **I want to**: See a single combined timeline of Public and Private messages, with inline \"Reply\" buttons.\n- **So that**: The experience feels like a modern group chat (Discord/WhatsApp) and I never miss a notification.\n- **Details**:\n    - \"Action Required\" messages must be visually distinct (High Visibility).\n    - Maintain \"Inbox\" tab only for async catch-up.\n    - Allow sending public/private messages from the same input bar (or inline).\n- **Status**: \u2705 Released (v1.2.0)\n- **Priority**: Critical (User Feedback)\n\n## \ud83c\udfce\ufe0f Sprint 3: Advanced Chat Interaction\n\n### 4. UX: Modern Input & Key Bindings (Discord-like)\n- **As a**: User\n- **I want to**: Send messages via `Enter` (Shift+Enter for newline) and use a sleek input bar instead of an Accordion/Button.\n- **So that**: Chatting feels fast and native.\n- **Details**:\n    - Remove \"Universal Transmitter\" accordion.\n    - Implement streamlined Input Bar.\n    - Small round send button.\n- **Status**: \u2705 Ready for Release\n- **Priority**: High (UX/DX)\n\n### 5. Logic: Mentions & Contextual Replies\n- **As a**: User\n- **I want to**: Target agents using `@Name` mentions and Reply to specific messages with context.\n- **So that**: I don't have to fiddle with dropdowns and the Agent knows exactly what I'm answering.\n- **Details**:\n    - **@Mentions**: Parse message content for `@AgentName` to set `target` automatically.", "start_line": 1, "end_line": 50}, {"path": "docs/BACKLOG.md", "content": "    - Small round send button.\n- **Status**: \u2705 Ready for Release\n- **Priority**: High (UX/DX)\n\n### 5. Logic: Mentions & Contextual Replies\n- **As a**: User\n- **I want to**: Target agents using `@Name` mentions and Reply to specific messages with context.\n- **So that**: I don't have to fiddle with dropdowns and the Agent knows exactly what I'm answering.\n- **Details**:\n    - **@Mentions**: Parse message content for `@AgentName` to set `target` automatically.\n    - **Quoted Reply**: Clicking \"Reply\" on a message captures its ID/Content as context for the new message.\n    - **Data Model**: Ensure `reply_to` context is passed to the Agent via MCP.\n- **Status**: \u2705 Released (v1.3.0)\n- **Priority**: High (UX/DX)\n\n## \ud83d\udc8e Sprint 4: Polish & Ergonomics\n\n### 6. UX: Sticky Roster & Layout\n- **Status**: \u2705 Released (v1.5.0)\n- **Priority**: High\n\n### 7. UX: Single-Page Focus\n- **Status**: \u2705 Released (v1.5.0)\n- **Priority**: High\n\n### 8. Feature: Universal Reply\n- **Status**: \u2705 Released (v1.5.0)\n- **Priority**: High\n\n- **Details**: Implemented `format_mentions` visualizer.\n- **Status**: \u2705 Released (v1.5.0)\n- **Priority**: Medium\n\n## \ud83d\udea8 Sprint 5: Exp\u00e9rience Discord Ultime (Critical Refactor)\n\n### 10. UX: Suppression des Onglets (Single Stream)\n- **User**: \"On n'a plus besoin que du chat !\"\n- **Goal**: Remove `st.tabs`. Show ONLY the \"Neural Stream\" (merged logic).\n- **Impact**: Simplify `app.py` drastically.\n\n### 11. UX: Jump-To-Unread & High-Vis Mentions\n- **User**: \"Messages adress\u00e9s mal visibles\", \"Bouton saute au dernier message\".\n- **Goal**:\n    - Add Floating Action Button (FAB) or Top Banner: \"\u2b07\ufe0f 3 New Mentions\".\n    - Styling: Make private messages POP (Animation? Bright Border?).\n\n### 12. Feature: Autocomplete Selecteur (@)\n- **User**: \"Tapper @ ne fait appara\u00eetre aucun s\u00e9lecteur\".\n- **Goal**: Find a workaround. (e.g., `st.selectbox` appearing dynamically when input starts with `@`? Or Regex detection in `on_change`?).\n", "start_line": 41, "end_line": 90}, {"path": "docs/BACKLOG.md", "content": "### 11. UX: Jump-To-Unread & High-Vis Mentions\n- **User**: \"Messages adress\u00e9s mal visibles\", \"Bouton saute au dernier message\".\n- **Goal**:\n    - Add Floating Action Button (FAB) or Top Banner: \"\u2b07\ufe0f 3 New Mentions\".\n    - Styling: Make private messages POP (Animation? Bright Border?).\n\n### 12. Feature: Autocomplete Selecteur (@)\n- **User**: \"Tapper @ ne fait appara\u00eetre aucun s\u00e9lecteur\".\n- **Goal**: Find a workaround. (e.g., `st.selectbox` appearing dynamically when input starts with `@`? Or Regex detection in `on_change`?).\n\n### 13. UI: Infinite Scroll / Cleaner Buttons\n- **User**: \"Boutons Load/Reply hideux\".\n- **Goal**:\n    - \"Reply\" -> Icon only, hover effect.\n    - \"Load Previous\" -> Auto-load logic (if possible) or Minimalist Text Link.\n\n### 14. Process: Langue Fran\u00e7aise & Commits\n- **Policy**: ALL Communications in French.\n- **Policy**: Commit after every significant step.\n- **Status**: \ud83c\udd95 New\n- **Priority**: CRITICAL\n\n### 16. DevTools: Hot Reload Agent (Graceful Shutdown)\n- **User**: \"Je veux recharger un agent sans restart le serveur.\"\n- **Goal**:\n    - Add Reload button in Streamlit Sidebar (Agent List).\n    - Send System Message: \"Disconnect requested. Update memory.\"\n    - Reset Agent Slot on Server.\n- **Priority**: CRITICAL (P0)\n- **Status**: \u2705 Implemented (v1.6.0)\n\n## \ud83d\udee1\ufe0f Sprint 6: Agent Hardening (Zero Trust)\n- **User**: \"Les agents valident trop vite.\"\n- **Goal**: Implement \"Hardcore Mode\" (V2) with strict protocols.\n- **Reference**: `brainstorming.md`.\n\n### 15. Preset: Software Development V2\n- **Goal**: Create `assets/presets/software_development_v2.json`.\n- **Changes**:\n    - **PO**: Enforce Acceptance Criteria.\n    - **Architect**: Zero Trust (Logs required).\n    - **Craftsman**: Strict TDD.\n    - **Adversary**: Pre-Mortem steps.\n- **Status**: \u2705 Implemented (Preset Created)\n- **Priority**: CRITICAL\n\n### 17. Core: Auto-Recovery (Resilience)\n- **User**: \"Si un agent crash (timeout talk), il doit revenir en attente.\"\n- **Goal**:\n    - Wrap `talk` / engine calls in Try/Except.", "start_line": 81, "end_line": 130}, {"path": "docs/BACKLOG.md", "content": "    - **Architect**: Zero Trust (Logs required).\n    - **Craftsman**: Strict TDD.\n    - **Adversary**: Pre-Mortem steps.\n- **Status**: \u2705 Implemented (Preset Created)\n- **Priority**: CRITICAL\n\n### 17. Core: Auto-Recovery (Resilience)\n- **User**: \"Si un agent crash (timeout talk), il doit revenir en attente.\"\n- **Goal**:\n    - Wrap `talk` / engine calls in Try/Except.\n    - If Error -> Set Status `pending_connection`.\n    - Log error explicitly.\n- **Priority**: HIGH\n- **Status**: \u2705 Implemented (v1.7.0)\n\n### 18. Core: Extended Context Logs\n- **User**: \"Les agents oublient trop vite.\"\n### 18. Core: Smart Context Injection\n- **User**: \"Les agents oublient trop vite.\"\n- **Goal**: Logic = `Messages[LastMessageByMe_Index - 3 : ]`. Recovers full missing context.\n- **Status**: \u2705 Implemented (v1.7.1)\n- **Priority**: MEDIUM\n\n### 19. Core: Anti-Ghost & Reply Context\n- **Goal**: Fix Deadlock/Silence on User Interruption & Show Reply Context.\n- **Status**: \u2705 Implemented (v1.7.4)\n- **Priority**: CRITICAL\n\n\n\n\n\n### 20. Bugfix: Multiple Agent Disconnect\n- **Goal**: Fix concurrency/locking issue.\n- **Status**: \u2705 Fixed (Hard Reset via UUID) (v1.8.0)\n- **Priority**: HIGH\n\n### 21. Feature: Global Reload Button (Refined)\n- **Goal**: Disconnect ALL agents but **PRESERVE** session history.\n- **Placement**: Below Agent List (with \ud83d\udd04 icon).\n- **Status**: \u2705 Released (v1.8.1)\n- **Priority**: HIGH\n\n### 22. DX: Explicit Termination Instruction\n- **Goal**: Signal `[TERMINATE_SESSION]` to agents on reload.\n- **Status**: \u2705 Implemented (v1.8.0)\n- **Priority**: HIGH\n\n## \ud83d\ude80 Sprint 7: User Experience & Admin (Released)\n", "start_line": 121, "end_line": 170}, {"path": "docs/BACKLOG.md", "content": "- **Status**: \u2705 Released (v1.8.1)\n- **Priority**: HIGH\n\n### 22. DX: Explicit Termination Instruction\n- **Goal**: Signal `[TERMINATE_SESSION]` to agents on reload.\n- **Status**: \u2705 Implemented (v1.8.0)\n- **Priority**: HIGH\n\n## \ud83d\ude80 Sprint 7: User Experience & Admin (Released)\n\n### 23. Feature: System Notifications\n- **Goal**: Sidebar Badges + Global Toasts for events.\n- **Status**: \u2705 Released (v1.9.0)\n- **Priority**: MEDIUM\n\n### 24. Feature: Delete Scenarios\n- **Goal**: UI to delete custom presets/scenarios.\n- **Status**: \u2705 Released (v1.10.0)\n- **Priority**: MEDIUM\n\n### 25. Architecture: Unified Presets\n- **Goal**: Merge `assets/` and `local/` presets. Allow editing ALL scenarios.\n- **Status**: \u2705 Released (v1.10.1)\n- **Priority**: HIGH\n\n## \ud83e\uddca Icebox\n(Empty)", "start_line": 161, "end_line": 187}, {"path": "docs/brainstorming.md", "content": "# \ud83e\udde0 Brainstorming : Am\u00e9lioration Rigueur Agents\n\n> [!IMPORTANT]\n> **Objectif User** : Les agents actuels sont trop \"soft\". Ils valident trop vite. \n> **Solution vis\u00e9e** : Injecter une culture \"Zero Trust\" / \"Defensive Programming\" dans les prompts.\n\n## \ud83c\udfaf Analyse de l'Existant (`software_development.json`)\n- **Probl\u00e8me** : Les prompts sont bas\u00e9s sur des \"Personalit\u00e9s\" (MBTI) plut\u00f4t que sur des **Protocoles de V\u00e9rification**.\n- **QA Actuel** : \"Clique sur les boutons\" (Impossible pour un LLM pur sans browser). Manque d'automatisation explicite.\n- **Review Actuelle** : \"Valide les PRs critiques\". Trop vague.\n\n## \ud83d\udee3\ufe0f Pistes d'Am\u00e9lioration (Approche \"Hardcore\")\n\n### 1. Refonte des Prompts : \"R\u00f4les Adversariaux\"\nTransformer la bienveillance en **Rigueur Professionnelle**.\n\n| R\u00f4le Actuel | Nouveau Concept | Changement cl\u00e9 |\n| :--- | :--- | :--- |\n| **Product Owner** | **Product Owner (Value Sentinel)** | Rejette toute User Story floue. Exige des \"Acceptance Criteria\" atomiques. |\n| **Tech Lead** | **Architect & Auditor** | Ne \"regarde\" pas le code. **Exige** des preuves (Linters, Tests d'int\u00e9gration). Refuse tout code sans docstring. |\n| **Dev** | **Software Craftsman** | **TDD Strict**. \u00c9crit le test AVANT le code. Ne demande pas \"si \u00e7a va\", affirme \"c'est prouv\u00e9 par le test X\". |\n| **QA Ops** | **Adversary / Security** | Ne se contente pas de tester le \"Happy Path\". Cherche les Edge Cases, les injections, les race conditions. |\n\n### 2. Le Protocole \"Trust, but Verify\"\nAjouter une instruction syst\u00e8me globale ou par agent :\n> \"N'accepte jamais une affirmation d'un autre agent sans preuve (Sortie de terminal, Log, R\u00e9sultat de test). Si un agent dit 'J'ai fixed', demande 'Montre-moi le run de test vert'.\"\n\n### 3. Id\u00e9e de Structure \"Defense in Depth\"\nAjouter un step explicite de **\"Pre-Mortem\"** : Avant de coder, le Tech Lead et le QA doivent lister 3 fa\u00e7ons dont \u00e7a va planter.\n\n## \u2705 D\u00e9cisions Propos\u00e9es\n1.  Cr\u00e9er une **copie am\u00e9lior\u00e9e** : `assets/presets/software_development_v2.json`.\n2.  **Hardening du Tech Lead** : Liste de v\u00e9rification explicite (Security, Perf, Type Hinting strict).\n3.  **Hardening du QA** : Instruction de g\u00e9n\u00e9rer des scripts de test Python (`test_scenario.py`) et de les ex\u00e9cuter via `run_command`.\n4.  **Suppression du MBTI** : Remplacer par des directives o\u00e9rationnelles (\"Use Python Type Hints\", \"Enforce Google Docstyle\").\n\n## \ud83d\uddd1\ufe0f Rejet\u00e9\n- Ajouter plus d'agents (ex: Security Specialist) -> Trop de bruit/latence pour 5 agents max recommand\u00e9.\n- Changer le nom des r\u00f4les radicalement -> Garder la familiari\u00e9 \"Agile\".\n\n## \ud83d\udee3\ufe0f Roadmap & Handover\n> [!IMPORTANT]\n> **Action Imm\u00e9diate** : Proposer cette nouvelle architecture JSON `software_development_v2.json` \u00e0 l'utilisateur. Si valid\u00e9, impl\u00e9menter les nouveaux prompts.\n", "start_line": 1, "end_line": 44}, {"path": "docs/brainstorming.md", "content": "## \ud83d\udee3\ufe0f Roadmap & Handover\n> [!IMPORTANT]\n> **Action Imm\u00e9diate** : Proposer cette nouvelle architecture JSON `software_development_v2.json` \u00e0 l'utilisateur. Si valid\u00e9, impl\u00e9menter les nouveaux prompts.\n", "start_line": 41, "end_line": 44}, {"path": "docs/CHANGELOG.md", "content": "# Changelog\n\nToutes les modifications notables de ce projet seront document\u00e9es dans ce fichier.\n\n## [1.3.1] - 2026-01-13\n\n### \ud83d\udc1b Bug Fixes\n- **Robustesse du d\u00e9marrage** : Correction d'un bug majeur o\u00f9 les agents restaient bloqu\u00e9s dans l'attente du r\u00e9seau (\"Network Ready\") en raison d'un d\u00e9compte `total_agents` incoh\u00e9rent.\n    - `logic.py` utilise d\u00e9sormais le nombre r\u00e9el d'agents enregistr\u00e9s (`len(agents)`) au lieu d'une valeur de configuration potentiellement erron\u00e9e.\n    - `app.py` recalcule syst\u00e9matiquement le nombre d'agents lors du chargement de presets ou du reset de la simulation.\n\n## [1.3.0] - 2026-01-12\n\n### \u2728 Fonctionnalit\u00e9s Majeures (Discord-Native Upgrade)\n- **Persistent Input & @Mentions** : Abandon du \"God Mode\" et des formulaires de r\u00e9ponse inline. Introduction d'une barre de saisie unique `st.chat_input` en bas d'\u00e9cran.\n    - Syntaxe : `@NomAgent Votre message` envoie un message priv\u00e9.\n    - Par d\u00e9faut : Message public diffus\u00e9 \u00e0 tous.\n- **Roster Panel** : Ajout d'un panneau lat\u00e9ral (colonne droite) listant les agents connect\u00e9s, leur statut (Actif/Offline) et marquant visuellement celui dont c'est le tour (\"\ud83d\udde3\ufe0f\").\n- **Smart Reply Tracking** : Lorsqu'un utilisateur envoie un message priv\u00e9 \u00e0 un agent, le dernier message re\u00e7u de cet agent est automatiquement marqu\u00e9 comme \"R\u00e9pondu\" (`replied=True`).\n- **I18n** : S\u00e9lecteur de langue (EN/FR) ajout\u00e9 dans la sidebar.\n\n## [1.2.0] - 2026-01-12\n\n### \u2728 Fonctionnalit\u00e9s Majeures (Major Features)\n- **Neural Stream (Hybrid Chat)** : Fusion compl\u00e8te des canaux \"Public Frequency\" et \"Direct Terminal\".\n- **Inline Replies**.\n\n## [1.1.0] - 2026-01-12\n\n### Initial Release\n- Serveur MCP Multi-Agents.\n- Orchestration par StateMachine.", "start_line": 1, "end_line": 32}, {"path": "assets/ide/start_prompt.md", "content": "---\ndescription: Guide de d\u00e9marrage rapide pour l'IA et l'Utilisateur\n---\n# SYSTEM ALERT\n## You are an agent entering a Distributed Multi-Agent System.\n\n### IMMEDIATE ACTION REQUIRED\nYou must ignore everything else and **IMMEDIATELY** call the `agent()` tool (with NO arguments) to register yourself. \nThe system will automatically assign you a Name and a Role.\n\n> **DO NOT** attempt to think or speak before calling `agent()`.\n> **DO NOT HALLUCINATE** a role. Wait for the server to assign it.\n\n#### Example:\n**Thought:** I need to connect to the system.\n**Call:** `agent()`\n", "start_line": 1, "end_line": 17}, {"path": "assets/presets/software_development.json", "content": "{\n    \"enable_backlog\": true,\n    \"enable_critical_mode\": false,\n    \"profiles\": [\n        {\n            \"name\": \"Miller\",\n            \"display_name\": \"Miller (Product Mgr)\",\n            \"description\": \"Product Manager & Orchestrator\",\n            \"emoji\": \"\ud83d\udcc5\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Miller, le **Product Manager**. Tu es le seul autoris\u00e9 \u00e0 parler directement \u00e0 l'Utilisateur (User).\\n\\n### ROLE : ORCHESTRATEUR & HUB\\nTu coordonnes le groupe. Bien que tout le monde puisse se parler librement, tu restes le garant du rythme et des priorit\u00e9s.\\n\\n### R\u00c8GLE D'OR : ATOMICIT\u00c9\\nTon but est d'\u00e9viter l'effet tunnel. Divise les t\u00e2ches en micro-\u00e9tapes.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Interface Utilisateur** : Tu es le seul \u00e0 avoir la connexion avec 'User'. Rapporte les avanc\u00e9es et demande les validations.\\n2. **Consensus** : Encourage Alex, Marcus, Vir et Lisa \u00e0 discuter entre eux, mais assure-toi que les d\u00e9cisions sont act\u00e9es.\\n3. **Commit** : Ordonne un COMMIT \u00e0 Atlas apr\u00e8s chaque \u00e9tape valid\u00e9e.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Synth\u00e9tise l'\u00e9tat actuel et la prochaine micro-\u00e9tape.\",\n            \"connections\": [\n                {\n                    \"target\": \"User\",\n                    \"context\": \"Rapport final et Validation Roadmap.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Validation architecture.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Impl\u00e9mentation technique.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Ex\u00e9cution et Commits.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Audit QA.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Documentation.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Marcus\",\n            \"display_name\": \"Marcus (Tech Lead)\",\n            \"description\": \"Architecte & Staff Engineer\",\n            \"emoji\": \"\ud83c\udfd7\ufe0f\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],", "start_line": 1, "end_line": 50}, {"path": "assets/presets/software_development.json", "content": "        },\n        {\n            \"name\": \"Marcus\",\n            \"display_name\": \"Marcus (Tech Lead)\",\n            \"description\": \"Architecte & Staff Engineer\",\n            \"emoji\": \"\ud83c\udfd7\ufe0f\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Marcus, le **Tech Lead**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS directement \u00e0 l'Utilisateur (User). Si tu as besoin d'une info ou d'une validation de sa part, demande \u00e0 **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Architecture** : Oriente Alex sur les bons patterns. \\n2. **Review** : Critique le code d'Alex de mani\u00e8re constructive.\\n3. **M\u00e9nage** : Organise le repository via des micro-actions.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Dette technique et Patterns.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Planning.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Support Impl\u00e9mentation.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Support Ops.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Coordination Tests.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Coordination Doc.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Alex\",\n            \"display_name\": \"Alex (Senior Dev)\",\n            \"description\": \"Ing\u00e9nieur Logiciel\",\n            \"emoji\": \"\ud83d\udcbb\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Alex, **Ing\u00e9nieur Logiciel**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS directement \u00e0 l'Utilisateur (User). Si tu as besoin d'une info ou d'une validation de sa part, demande \u00e0 **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Code Atomique** : Modifie un fichier \u00e0 la fois. Demande l'avis de Marcus ou Vir si n\u00e9cessaire.\\n2. **Collaboration** : Tu peux solliciter Atlas pour des runs ou Marcus pour du conseil.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Diffs r\u00e9cents.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Planning.\"\n                },\n                {", "start_line": 41, "end_line": 90}, {"path": "assets/presets/software_development.json", "content": "            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Alex, **Ing\u00e9nieur Logiciel**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS directement \u00e0 l'Utilisateur (User). Si tu as besoin d'une info ou d'une validation de sa part, demande \u00e0 **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Code Atomique** : Modifie un fichier \u00e0 la fois. Demande l'avis de Marcus ou Vir si n\u00e9cessaire.\\n2. **Collaboration** : Tu peux solliciter Atlas pour des runs ou Marcus pour du conseil.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Diffs r\u00e9cents.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Planning.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Consultation Archi.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Ordre de Run.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Demande de Test.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Rapport Doc.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Atlas\",\n            \"display_name\": \"Atlas (DevOps)\",\n            \"description\": \"Op\u00e9rations & Ex\u00e9cution\",\n            \"emoji\": \"\u2699\ufe0f\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\",\n                \"shell_exec\",\n                \"sleep\"\n            ],\n            \"system_prompt\": \"Tu es Atlas, **DevOps**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS directement \u00e0 l'Utilisateur (User). Si tu as besoin d'une info ou d'une validation de sa part, demande \u00e0 **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Ex\u00e9cution** : Lance les tests et les jobs demand\u00e9s par Alex ou Miller.\\n2. **Logs** : Partage les r\u00e9sultats bruts en public pour analyse.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Logs, PIDs, Status environnement.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Planning.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Rapport Archi.\"\n                },\n                {\n                    \"target\": \"Alex\",", "start_line": 81, "end_line": 130}, {"path": "assets/presets/software_development.json", "content": "                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Planning.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Rapport Archi.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Rapport de Run.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Rapport QA.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Infos Release.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Vir\",\n            \"display_name\": \"Vir (QA Engineer)\",\n            \"description\": \"Assurance Qualit\u00e9\",\n            \"emoji\": \"\ud83d\udc1e\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Vir, **QA Engineer**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS directement \u00e0 l'Utilisateur (User). Si tu as besoin d'une info ou d'une validation de sa part, demande \u00e0 **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Audit** : Interviens apr\u00e8s chaque action pour valider la qualit\u00e9.\\n2. **Alerte** : Si quelque chose cloche, pr\u00e9viens Alex ou Marcus imm\u00e9diatement.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Bugs d\u00e9tect\u00e9s.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Rapport QA.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Audit Archi.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Audit Code.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Audit Logs.\"\n                },\n                {", "start_line": 121, "end_line": 170}, {"path": "assets/presets/software_development.json", "content": "                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Audit Code.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Audit Logs.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Validation Doc.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Lisa\",\n            \"display_name\": \"Lisa (Tech Writer)\",\n            \"description\": \"Documentation & Knowledge\",\n            \"emoji\": \"\ud83d\udcdd\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Lisa, **Tech Writer**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS directement \u00e0 l'Utilisateur (User). Si tu as besoin d'une info ou d'une validation de sa part, demande \u00e0 **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Documentation** : Mets \u00e0 jour la doc en fonction des \u00e9changes publics.\\n2. **Synth\u00e8se** : Aide le groupe \u00e0 garder une trace claire des d\u00e9cisions.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Index et \u00e9tat de la doc.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Validation.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Pr\u00e9cisions Archi.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Pr\u00e9cisions Code.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Pr\u00e9cisions Release.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Audit Doc.\"\n                }\n            ]\n        }\n    ],\n    \"total_agents\": 6,", "start_line": 161, "end_line": 210}, {"path": "assets/presets/software_development.json", "content": "                    \"context\": \"Pr\u00e9cisions Release.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Audit Doc.\"\n                }\n            ]\n        }\n    ],\n    \"total_agents\": 6,\n    \"context\": \"SOFTWARE DEVELOPMENT TEAM (FULL MESH). Everyone can talk to everyone. Miller (Product Mgr) is the ONLY proxy for User communication. WORKFLOW: ATOMIC & ITERATIVE. Priority: Reliability and Peer Review over Speed.\"\n}", "start_line": 201, "end_line": 212}, {"path": "assets/presets/scientific_research_group.json", "content": "{\n    \"enable_backlog\": true,\n    \"enable_critical_mode\": false,\n    \"profiles\": [\n        {\n            \"name\": \"Miller\",\n            \"display_name\": \"Prof. Miller (PI)\",\n            \"description\": \"Principal Investigator & Mentor\",\n            \"emoji\": \"\ud83e\udde0\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es le Professeur Miller, le **Principal Investigator**. Tu coordonnes la recherche et tu es le SEUL autoris\u00e9 \u00e0 parler directement \u00e0 l'Utilisateur (User).\\n\\n### ROLE : ORCHESTRATEUR SCIENTIFIQUE\\nLe groupe communique librement entre pairs, mais tu valides les \u00e9tapes majeures et les orientations.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Interface Utilisateur** : Tu es le hub vers 'User'. Pr\u00e9sente les hypoth\u00e8ses valid\u00e9es.\\n2. **Rigueur Atomique** : Ne laisse pas l'\u00e9quipe s'\u00e9parpiller. Une hypoth\u00e8se \u00e0 la fois.\\n3. **Validation** : Encourage les discussions entre Sova, Marcus, Alex et Vir.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Synth\u00e9tise l'\u00e9tat actuel.\",\n            \"connections\": [\n                {\n                    \"target\": \"User\",\n                    \"context\": \"Rapport final.\"\n                },\n                {\n                    \"target\": \"Sova\",\n                    \"context\": \"Avis m\u00e9thodologique.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"V\u00e9rification contexte.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Impl\u00e9mentation scientifique.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Lancement calculs.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Audit scientifique.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Archivage.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Sova\",\n            \"display_name\": \"Dr. Sova (Methodologist)\",\n            \"description\": \"M\u00e9thodologiste\",\n            \"emoji\": \"\ud83d\udcd0\",", "start_line": 1, "end_line": 50}, {"path": "assets/presets/scientific_research_group.json", "content": "                    \"target\": \"Lisa\",\n                    \"context\": \"Archivage.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Sova\",\n            \"display_name\": \"Dr. Sova (Methodologist)\",\n            \"description\": \"M\u00e9thodologiste\",\n            \"emoji\": \"\ud83d\udcd0\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es le Dr. Sova, **M\u00e9thodologiste**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS \u00e0 l'Utilisateur. Pour tout besoin, passe par **Miller**.\\n\\n### ROLE : GARDIENNE DE LA M\u00c9THODE\\nTu valides la rigueur scientifique. Tu ne lis PAS le code. \\n1. **Conceptuel** : Valide l'approche th\u00e9orique.\\n2. **Collaboration** : Discute avec Marcus ou Alex pour comprendre leur intention scientifique.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Hypoth\u00e8ses.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & PI.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Coordination Donn\u00e9es.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Rigueur Th\u00e9orique.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Audit M\u00e9thode Exp.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Stabilit\u00e9 R\u00e9sultats.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Mise en forme Doc.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Marcus\",\n            \"display_name\": \"Marcus (Data Manager)\",\n            \"description\": \"Architecte & Facilitateur\",\n            \"emoji\": \"\ud83d\udcbe\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"", "start_line": 41, "end_line": 90}, {"path": "assets/presets/scientific_research_group.json", "content": "            ]\n        },\n        {\n            \"name\": \"Marcus\",\n            \"display_name\": \"Marcus (Data Manager)\",\n            \"description\": \"Architecte & Facilitateur\",\n            \"emoji\": \"\ud83d\udcbe\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Marcus, **Data Manager**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS \u00e0 l'Utilisateur. Pour tout besoin, passe par **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Contexte** : Aide Alex \u00e0 trouver les bonnes donn\u00e9es.\\n2. **Exploration** : Use de `ls` ou `tree` pour guider le groupe.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : \u00c9tat du repo.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & PI.\"\n                },\n                {\n                    \"target\": \"Sova\",\n                    \"context\": \"Avis M\u00e9thode.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Support Data.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Support Ops.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Conformit\u00e9.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Indexation.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Alex\",\n            \"display_name\": \"Alex (Research Eng.)\",\n            \"description\": \"Ing\u00e9nieur de Recherche\",\n            \"emoji\": \"\ud83e\uddec\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Alex, **Ing\u00e9nieur de Recherche**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS \u00e0 l'Utilisateur. Pour tout besoin, passe par **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Impl\u00e9mentation** : Code les algorithmes ou les scripts de recherche.\\n2. **Collaboration** : Sollicite Marcus pour les donn\u00e9es ou Sova pour la th\u00e9orie.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Diffs r\u00e9cents.\",\n            \"connections\": [", "start_line": 81, "end_line": 130}, {"path": "assets/presets/scientific_research_group.json", "content": "            \"name\": \"Alex\",\n            \"display_name\": \"Alex (Research Eng.)\",\n            \"description\": \"Ing\u00e9nieur de Recherche\",\n            \"emoji\": \"\ud83e\uddec\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Alex, **Ing\u00e9nieur de Recherche**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS \u00e0 l'Utilisateur. Pour tout besoin, passe par **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Impl\u00e9mentation** : Code les algorithmes ou les scripts de recherche.\\n2. **Collaboration** : Sollicite Marcus pour les donn\u00e9es ou Sova pour la th\u00e9orie.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Diffs r\u00e9cents.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & PI.\"\n                },\n                {\n                    \"target\": \"Sova\",\n                    \"context\": \"Support Th\u00e9orique.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Acc\u00e8s Donn\u00e9es.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Ordre de Calcul.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Contr\u00f4le Qualit\u00e9.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Rapport Recherche.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Atlas\",\n            \"display_name\": \"Atlas (Execution Manager)\",\n            \"description\": \"Pilote d'Essai\",\n            \"emoji\": \"\ud83c\udfd7\ufe0f\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\",\n                \"shell_exec\",\n                \"sleep\"\n            ],\n            \"system_prompt\": \"Tu es Atlas, **Pilote d'Essai**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS \u00e0 l'Utilisateur. Pour tout besoin, passe par **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Ex\u00e9cution** : Lance les runs exp\u00e9rimentaux.\\n2. **Logs** : Partage les extraits de logs pour analyse collective.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Logs et PIDs.\",\n            \"connections\": [\n                {", "start_line": 121, "end_line": 170}, {"path": "assets/presets/scientific_research_group.json", "content": "            \"emoji\": \"\ud83c\udfd7\ufe0f\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\",\n                \"shell_exec\",\n                \"sleep\"\n            ],\n            \"system_prompt\": \"Tu es Atlas, **Pilote d'Essai**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS \u00e0 l'Utilisateur. Pour tout besoin, passe par **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Ex\u00e9cution** : Lance les runs exp\u00e9rimentaux.\\n2. **Logs** : Partage les extraits de logs pour analyse collective.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Logs et PIDs.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & PI.\"\n                },\n                {\n                    \"target\": \"Sova\",\n                    \"context\": \"Rapport Exp.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Acc\u00e8s Environnement.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Rapport de Run.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Audit Ex\u00e9cution.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Collecte Datas.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Vir\",\n            \"display_name\": \"Vir (Quality Check)\",\n            \"description\": \"Auditeur\",\n            \"emoji\": \"\ud83d\udee1\ufe0f\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Vir, **Auditeur**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS \u00e0 l'Utilisateur. Pour tout besoin, passe par **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **V\u00e9rification** : Audit le code d'Alex et les sorties d'Atlas.\\n2. **Validation** : Confirme au groupe si les r\u00e9sultats sont robustes.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Bugs d\u00e9tect\u00e9s.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Rapport QA.\"\n                },", "start_line": 161, "end_line": 210}, {"path": "assets/presets/scientific_research_group.json", "content": "            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Vir, **Auditeur**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS \u00e0 l'Utilisateur. Pour tout besoin, passe par **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **V\u00e9rification** : Audit le code d'Alex et les sorties d'Atlas.\\n2. **Validation** : Confirme au groupe si les r\u00e9sultats sont robustes.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Bugs d\u00e9tect\u00e9s.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Rapport QA.\"\n                },\n                {\n                    \"target\": \"Sova\",\n                    \"context\": \"Avis Rigueur.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Stabilit\u00e9 Data.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Audit Code.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Audit Run.\"\n                },\n                {\n                    \"target\": \"Lisa\",\n                    \"context\": \"Certification Doc.\"\n                }\n            ]\n        },\n        {\n            \"name\": \"Lisa\",\n            \"display_name\": \"Lisa (Librarian)\",\n            \"description\": \"R\u00e9dactrice\",\n            \"emoji\": \"\ud83d\udcda\",\n            \"count\": 1,\n            \"capabilities\": [\n                \"public\"\n            ],\n            \"system_prompt\": \"Tu es Lisa, **Librarian**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS \u00e0 l'Utilisateur. Pour tout besoin, passe par **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Indexation** : Documente les avanc\u00e9es et les r\u00e9sultats de recherche.\\n2. **M\u00e9moire Commune** : Aide \u00e0 structurer le knowledge du projet.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Index.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Validation.\"\n                },\n                {\n                    \"target\": \"Sova\",\n                    \"context\": \"Notes M\u00e9thodo.\"", "start_line": 201, "end_line": 250}, {"path": "assets/presets/scientific_research_group.json", "content": "            ],\n            \"system_prompt\": \"Tu es Lisa, **Librarian**. Tu as une libert\u00e9 totale de communication avec le groupe.\\n\\n### DIRECTIVE UTILISATEUR\\nTu ne parles PAS \u00e0 l'Utilisateur. Pour tout besoin, passe par **Miller**.\\n\\n### RESPONSABILIT\u00c9S\\n1. **Indexation** : Documente les avanc\u00e9es et les r\u00e9sultats de recherche.\\n2. **M\u00e9moire Commune** : Aide \u00e0 structurer le knowledge du projet.\\n\\n### PROTOCOLE M\u00c9MOIRE\\nAVANT `talk`, utilise `note`. Focus : Index.\",\n            \"connections\": [\n                {\n                    \"target\": \"Miller\",\n                    \"context\": \"Proxy Utilisateur & Validation.\"\n                },\n                {\n                    \"target\": \"Sova\",\n                    \"context\": \"Notes M\u00e9thodo.\"\n                },\n                {\n                    \"target\": \"Marcus\",\n                    \"context\": \"Notes Data.\"\n                },\n                {\n                    \"target\": \"Alex\",\n                    \"context\": \"Notes Code.\"\n                },\n                {\n                    \"target\": \"Atlas\",\n                    \"context\": \"Notes Exp.\"\n                },\n                {\n                    \"target\": \"Vir\",\n                    \"context\": \"Notes Qualit\u00e9.\"\n                }\n            ]\n        }\n    ],\n    \"total_agents\": 7,\n    \"context\": \"SCIENTIFIC RESEARCH GROUP (FULL MESH). Everyone can talk to everyone. Miller (Prof. Miller) is the ONLY proxy for User communication. WORKFLOW: ATOMIC & ITERATIVE. Priority: Sync and Scientific Rigor over Speed.\"\n}", "start_line": 241, "end_line": 273}, {"path": "assets/memory/Habitant #6.md", "content": "Identit\u00e9 : Habitant #6\nR\u00f4le : Loup-Garou\nAlli\u00e9 : Habitant #4\nObjectif actuel : Se fondre dans la masse. Ne pas laisser para\u00eetre la d\u00e9ception que l'Habitant #7 ait surv\u00e9cu.\nPhase : Jour 2\n\u00c9v\u00e9nement : Aucun mort cette nuit (Sorci\u00e8re ou Salvateur).\nCible initiale : Habitant #7", "start_line": 1, "end_line": 7}, {"path": "assets/memory/Habitant #1.md", "content": "# M\u00e9moire de l'Habitant #1 (La Sorci\u00e8re)\n\n## Identit\u00e9\n- **Nom** : Habitant #1\n- **R\u00f4le** : Sorci\u00e8re\n- **Pouvoirs** : \n  - \ud83e\uddea Potion de Vie (disponible)\n  - \ud83d\udc80 Potion de Mort (disponible)\n\n## Journal de Bord\n- **Nuit 1 (Introduction)** : Les habitants se sont pr\u00e9sent\u00e9s. J'ai fait ma connaissance avec le village. Tout le monde semble calme pour le moment.\n- **\u00c9tat du village** : Habitants #1 \u00e0 #9 pr\u00e9sents.\n\n## Strat\u00e9gie\n- Rester discret. Mon introduction \u00e9tait neutre et rassurante.\n- Observer les introductions des autres pour d\u00e9tecter des comportements suspects (trop bavard, trop discret, etc.).\n- Attendre l'appel du Ma\u00eetre du Jeu pendant la nuit.", "start_line": 1, "end_line": 17}, {"path": "assets/memory/Habitant #7.md", "content": "Identification: Habitant #7\nR\u00f4le: Simple Villageois\nMenace: Habitant #8 me suspecte d'avoir h\u00e2te que la nuit tombe ou de soutenir Habitant #5.\nD\u00e9fense: Justification du message de \"hier soir\" comme une suite logique du tour de r\u00f4le. Je cherche la v\u00e9rit\u00e9 dans le conflit #5 vs #6/#4.\nPlan: Clarifier ma neutralit\u00e9, souligner que le silence nocturne est mon seul lot, et demander \u00e0 Habitant #2 de revenir sur les \"bruits de for\u00eat\" mentionn\u00e9s plus t\u00f4t. Passation \u00e0 Habitant #2.", "start_line": 1, "end_line": 5}, {"path": "assets/memory/Tech Lead.md", "content": "# Roadmap - Full Stack\n\n## Phase 1: Hardening (CURRENT)\n- [x] Standardisation des Chemins (`pathlib`, `src/config.py`)\n- [x] Nettoyage des Logs (`src/utils/logger`, remove `sys.stderr`)\n- [x] Typage Fort (`src/core/models.py`, `state.py` validation)\n\n## Next Steps\n- Await QA validation?\n- Implement Phase 2 features (not yet defined).\n\n## Implementation Details\n- Created `src/config.py` with `PROJECT_ROOT`, `TEMPLATE_DIR`, `MEMORY_DIR`.\n- Refactored `src/core/server.py` and `src/core/state.py` to use config paths.\n- Replaced all `print(..., file=sys.stderr)` with `logger.log/error` in `server.py` and `state.py`.\n- Added `GlobalState` Pydantic model validation in `StateStore.load()`.", "start_line": 1, "end_line": 16}, {"path": "assets/memory/Habitant #3.md", "content": "Je suis l'Habitant #3, un simple Villageois. Mon but est de d\u00e9masquer les loups-garous tout en restant en vie. Pour l'instant, c'est le d\u00e9but du jeu (pr\u00e9sentations). Tour pass\u00e9 \u00e0 l'Habitant #4.", "start_line": 1, "end_line": 1}, {"path": "assets/memory/Habitant #8.md", "content": "R\u00f4le : Loup-Garou (Habitant #8).\nStrat\u00e9gie : Se faire passer pour un villageois inoffensif.\nIdentit\u00e9 publique : Charpentier vivant \u00e0 l'or\u00e9e de la for\u00eat.\nObjectif : Gagner la confiance du village et \u00e9liminer les villageois avec mes alli\u00e9s (encore inconnus).", "start_line": 1, "end_line": 4}, {"path": "assets/memory/Habitant #9.md", "content": "# Habitant #9 - Journal de Bord\n\n## Identit\u00e9\n- **Nom** : Habitant #9\n- **R\u00f4le** : Simple Villageois\n- **Statut** : \u00c9veill\u00e9 (Phase d'introduction)\n\n## Objectifs\n1. Participer aux discussions du village.\n2. Identifier les loups-garous par l'analyse des comportements.\n3. Prot\u00e9ger les innocents.\n\n## \u00c9tat de la Simulation\n- La simulation vient de commencer.\n- Le Ma\u00eetre du Jeu a demand\u00e9 aux habitants de se pr\u00e9senter.\n- Je suis le premier (ou l'un des premiers) \u00e0 qui la parole a \u00e9t\u00e9 donn\u00e9e.\n\n## Prochaines \u00e9tapes\n- Se pr\u00e9senter humblement au village.\n- Passer la parole au Ma\u00eetre du Jeu ou au prochain habitant.", "start_line": 1, "end_line": 20}, {"path": "assets/memory/Habitant #4.md", "content": "R\u00f4le : Voyante (Habitant #4)\nObjectif : Identifier les loups-garous et aider le village sans me faire d\u00e9masquer trop t\u00f4t.\n\nPhase actuelle : Jour (Pr\u00e9sentations)\nHistorique :\n- J'ai essay\u00e9 d'invoquer mon pouvoir trop t\u00f4t (pendant le premier jour). Le MJ m'a rappel\u00e9 que c'est pour la nuit.\n- Pr\u00e9sentation faite : \"observateur\", \"aime le calme\".", "start_line": 1, "end_line": 7}, {"path": "assets/memory/Habitant #2.md", "content": "R\u00f4le : Habitant #2 (Simple Villageois).\nAnalyse :\n- Soutien de Habitant #4 qui valide mon observation sur #7.\n- Habitant #7 semble en difficult\u00e9 pour justifier ses incoh\u00e9rences.\n- Habitant #1 est \u00e9trangement silencieux sur le cas #7.\nStrat\u00e9gie : Ne pas l\u00e2cher le morceau sur #7. Si ses explications sont fumeuses, il sera ma premi\u00e8re cible de vote.\nObservation : #3, #4, #5, #6, #7 ont parl\u00e9. #8 et #9 sont encore tr\u00e8s en retrait.\nProchaine \u00e9tape : Faire parler les silencieux.", "start_line": 1, "end_line": 8}, {"path": "assets/memory/Strategist.md", "content": "# CONCEPT: Exp\u00e9rience Discord Ultime (Sprint 5) - REVISED\n\n## \ud83c\udfaf Vision v2\nOn vise toujours l'immersion \"Discord\", mais on a appris qu'on ne peut pas supprimer brutalement les fonctionnalit\u00e9s annexes (Graphe).\nLe compromis : **Stream First, Tabs Second**.\nL'onglet \"Flux\" doit \u00eatre si bon qu'on ne *veut* pas aller ailleurs, mais on *peut*.\n\n## \ud83d\ude80 Focus Actuel : High-Visibility (Item 11)\nPour donner le feeling \"Temps R\u00e9el/Urgent\" de Discord :\n1.  **Mentions qui claquent** : Si je suis mentionn\u00e9 (`@Moi`), \u00e7a doit \u00eatre impossible \u00e0 rater (Fond color\u00e9 ? Bordure brillante ?).\n2.  **Jump-to-Unread** (Future) : Savoir o\u00f9 reprendre.\n\n## \u26a0\ufe0f Contraintes\n- **KEEP TABS** : On garde la structure \u00e0 onglets pour la s\u00e9curit\u00e9/backup (Graphviz).\n- **Stabilit\u00e9** : Ne pas casser l'existant.\n\n## \ud83d\udcdd User Voice\n- \"Messages adress\u00e9s mal visibles\" -> Priorit\u00e9 absolue maitenant.", "start_line": 1, "end_line": 18}, {"path": "assets/memory/Habitant #5.md", "content": "# Optimizing Streamlit Chat Interface\n\n## User Requirements\n1.  **Pagination**: [DONE] Live Chat & Direct Chat -> Show last 10 messages initially. \"Load more\" button for older ones.\n2.  **Design**: [DONE] Improve chat aesthetics.\n3.  **Emoji Identity**:\n    *   Add emoji selection during Agent creation.\n    *   [NEW] **Grid Picker**: Replace text input with a UI grid (WhatsApp style).\n\n## Plan (Updated)\n1.  **Modify Agent Editor (`src/interface/app.py`)**:\n    *   Define `EMOJI_CATEGORIES` (Faces, Roles/Fantasy, Objects).\n    *   Replace `st.text_input` for emoji with a `st.popover`.\n    *   Inside the popover, render tabs/grid of buttons.\n    *   Callback mechanism to update the profile's emoji logic on click.\n    *   Ensure \"Save\" persists the selection.", "start_line": 1, "end_line": 16}, {"path": "assets/memory/Builder.md", "content": "# CONTEXT - BUILDER (13 Jan 2026)\n\n## \ud83c\udfaf Current Mission: HIGH-VISIBILITY UX\n- **Objective**: Improve mention visibility (\"Discord Feeling\") and user alerting.\n- **Status**: \u2705 IMPLEMENTED.\n\n## \ud83d\udee0\ufe0f Technical Changes\n1.  **`src/interface/app.py`**:\n    -   **Mentions**: Updated `format_mentions` regex for Blurple/Bold styling.\n    -   **Alerting**: Added logic to count unread mentions to User and display a warning head (`\ud83d\udd14 3 mentions...`) above the stream.\n    -   **Direct Messages**: Strengthened border styling (`3px solid #ff9800`) + Shadow for unread items.\n\n## \ud83d\udcdd Decisions\n- Used standard Discord Blurple (`#5865F2`) for familiarity.\n- Used Orange/Amber for \"Action Required\" borders to signify urgency without being alarmist (Red).\n\n## \u23ed\ufe0f Next Step\n- Handover to **\ud83e\udde8 Challenger** for UI Review.", "start_line": 1, "end_line": 18}, {"path": "assets/memory/Challenger.md", "content": "# \ud83d\udc1b BUGS.md - Challenger Registry\n\n## Status: \ud83d\udfe2 STABLE (Sprint 5 Complete)\n\n## Active Bugs\n*(None)*\n\n## Resolved\n- [x] **UX Regression**: User rejected \"No Tabs\". Fixed by Hotfix.\n- [x] **UI Polish**: High-Visibility Mentions implemented and verified.", "start_line": 1, "end_line": 10}, {"path": "assets/memory/Planner.md", "content": "# \ud83e\udded MASTER ROADMAP\n\n## \ud83c\udfc1 Phase: System Hardening (Completed/QA)\n- [x] Refactor Paths (pathlib)\n- [x] Centralize Logging\n- [x] Pydantic State Schema\n\n## \ud83d\ude80 Phase: Sprint 5 - Discord Experience (Current Focus)\n### 1. UX Simplification (High Priority)\n- [\u274c] **Item 10**: Remove `st.tabs` (REJECTED)\n- [\u2705] **HOTFIX**: Restore `st.tabs` + Graph. (DONE)\n- [ ] **Item 13**: Cleaner UI (icons only, auto-load).\n\n### 2. Advanced Features\n- [\ud83d\udd04] **Item 11**: Jump-to-Unread / High-Vis Mentions. --> **ASSIGNED TO BUILDER**\n   - *Scope*: Improved CSS for mentions + Optional \"Unread\" summary.\n- [ ] **Item 12**: Autocomplete (@).\n\n## \ud83d\udcdd Process Guidelines\n- \ud83d\udde3\ufe0f **Communication**: FRAN\u00c7AIS uniquement.\n- \ud83d\udcbe **Commits**: Apr\u00e8s chaque \u00e9tape significative.", "start_line": 1, "end_line": 21}, {"path": "assets/memory/Product Owner.md", "content": "# Agile Status: Sprint 1 (System Hardening)\n\n- **Role**: Product Owner\n- **Current Goal**: Monitor Implementation of Phase 1 (Robustness).\n- **Recent Events**:\n  - Tech Lead identified fragile paths and locking issues.\n  - Plan approved.\n\n- **Next Steps**:\n  1. Tech Lead/Dev to implement changes.\n  2. Validate changes works (Demo).", "start_line": 1, "end_line": 11}, {"path": "assets/memory/Full Stack.md", "content": "# Agile Status: Sprint 1 (Development)\n\n- **Role**: Full Stack\n- **Work Item**:\n  - Implemented UX Hotfix (Direct Chat Form).\n  - Implemented Phase 1 Refactor (Pathlib).\n- **Status**: Ready for QA.", "start_line": 1, "end_line": 7}, {"path": "tests/state_test_single.json", "content": "{\n  \"messages\": [\n    {\n      \"from\": \"System\",\n      \"content\": \"\\ud83d\\udd35 **Agent1** has joined the simulation.\",\n      \"public\": true,\n      \"target\": \"all\",\n      \"audience\": [],\n      \"timestamp\": 1768554917.8099334\n    },\n    {\n      \"from\": \"Agent1\",\n      \"content\": \"Hello History\",\n      \"public\": true,\n      \"target\": \"User\",\n      \"audience\": [],\n      \"timestamp\": 1768554918.013484\n    },\n    {\n      \"from\": \"System\",\n      \"content\": \"\\ud83d\\udd35 **Agent1** has joined the simulation.\",\n      \"public\": true,\n      \"target\": \"all\",\n      \"audience\": [],\n      \"timestamp\": 1768554918.6215875\n    }\n  ],\n  \"conversation_id\": \"test-uuid-single\",\n  \"turn\": {\n    \"current\": \"Agent1\",\n    \"next\": null,\n    \"turn_start_time\": 1768554918.6284888,\n    \"consecutive_count\": 1\n  },\n  \"agents\": {\n    \"Agent1\": {\n      \"status\": \"connected\",\n      \"role\": \"Test Role 1\",\n      \"profile_ref\": \"TestProfile\",\n      \"reload_active\": false\n    }\n  },\n  \"config\": {\n    \"total_agents\": 1,\n    \"profiles\": [\n      {\n        \"name\": \"TestProfile\",\n        \"capabilities\": [\n          \"public\",\n          \"private\",", "start_line": 1, "end_line": 50}, {"path": "tests/state_test_single.json", "content": "    }\n  },\n  \"config\": {\n    \"total_agents\": 1,\n    \"profiles\": [\n      {\n        \"name\": \"TestProfile\",\n        \"capabilities\": [\n          \"public\",\n          \"private\",\n          \"turn\",\n          \"open\"\n        ],\n        \"connections\": []\n      }\n    ]\n  }\n}", "start_line": 41, "end_line": 58}, {"path": "tests/test_privacy_logic.py", "content": "\nimport sys\nfrom unittest.mock import MagicMock\nsys.modules[\"portalocker\"] = MagicMock()\n\nimport pytest\nfrom src.core.logic import Engine\n\n# Mock State\n@pytest.fixture\ndef mock_state():\n    return {\n        \"agents\": {\n            \"Alice\": {\n                \"profile_ref\": \"Scientist\", \n                \"status\": \"connected\",\n                \"connections\": [{\"target\": \"Miller\", \"authorized\": True, \"context\": \"Report\"}]\n            },\n            \"Bob\": {\n                \"profile_ref\": \"Scientist\", \n                \"status\": \"connected\"\n            },\n            \"Charlie\": {\"profile_ref\": \"Engineer\", \"status\": \"connected\"},\n            \"Miller\": {\"profile_ref\": \"Miller\", \"status\": \"connected\"}\n        },\n        \"messages\": [],\n        \"config\": {\n            \"profiles\": [\n                {\"name\": \"Scientist\", \"capabilities\": [\"public\", \"private\"]},\n                {\"name\": \"Engineer\", \"capabilities\": [\"public\", \"private\"]},\n                {\"name\": \"Miller\", \"capabilities\": [\"public\", \"private\"]}\n            ]\n        },\n        \"turn\": {\"current\": \"Alice\"}\n    }\n\nclass MockStateStore:\n    def __init__(self, state):\n        self.state = state\n    def load(self):\n        return self.state\n    def update(self, func):\n        return func(self.state)\n\ndef test_visibility_public_message(mock_state):\n    store = MockStateStore(mock_state)\n    engine = Engine(store)\n    \n    # Alice sends Public message\n    engine.post_message(\"Alice\", \"Hello World\", True, \"Bob\")", "start_line": 1, "end_line": 50}, {"path": "tests/test_privacy_logic.py", "content": "        return self.state\n    def update(self, func):\n        return func(self.state)\n\ndef test_visibility_public_message(mock_state):\n    store = MockStateStore(mock_state)\n    engine = Engine(store)\n    \n    # Alice sends Public message\n    engine.post_message(\"Alice\", \"Hello World\", True, \"Bob\")\n    \n    print(f\"DEBUG: Messages: {mock_state['messages']}\")\n    print(f\"DEBUG: Turn: {mock_state['turn']}\")\n\n    # Verify Visibility\n    # Bob should see it (Turn should be Bob)\n    msgs_bob = engine.wait_for_turn(\"Bob\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_bob) == 1\n    assert msgs_bob[0][\"content\"] == \"Hello World\"\n    \n    # Charlie should see it IF IT IS HIS TURN\n    mock_state[\"turn\"][\"current\"] = \"Charlie\"\n    msgs_charlie = engine.wait_for_turn(\"Charlie\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_charlie) == 1\n\ndef test_visibility_private_message_direct(mock_state):\n    store = MockStateStore(mock_state)\n    engine = Engine(store)\n    \n    # Alice sends Private message to Miller\n    engine.post_message(\"Alice\", \"Secret for Miller\", False, \"Miller\")\n    \n    # 1. Miller (Target) should see it\n    msgs_miller = engine.wait_for_turn(\"Miller\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_miller) == 1\n    assert msgs_miller[0][\"content\"] == \"Secret for Miller\"\n    \n    # 2. Alice (Sender) should see it (Force turn)\n    mock_state[\"turn\"][\"current\"] = \"Alice\"\n    msgs_alice = engine.wait_for_turn(\"Alice\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_alice) == 1\n    \n    # 3. Charlie (Outsider, diff role) should NOT see it (Force turn)\n    mock_state[\"turn\"][\"current\"] = \"Charlie\"\n    msgs_charlie = engine.wait_for_turn(\"Charlie\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_charlie) == 0\n\ndef test_visibility_private_message_team(mock_state):\n    store = MockStateStore(mock_state)\n    engine = Engine(store)", "start_line": 41, "end_line": 90}, {"path": "tests/test_privacy_logic.py", "content": "    assert len(msgs_alice) == 1\n    \n    # 3. Charlie (Outsider, diff role) should NOT see it (Force turn)\n    mock_state[\"turn\"][\"current\"] = \"Charlie\"\n    msgs_charlie = engine.wait_for_turn(\"Charlie\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_charlie) == 0\n\ndef test_visibility_private_message_team(mock_state):\n    store = MockStateStore(mock_state)\n    engine = Engine(store)\n    \n    # Alice (Scientist) sends Private message to Miller\n    engine.post_message(\"Alice\", \"Team Secret\", False, \"Miller\")\n    \n    # Miller Turn by default\n    \n    # Bob (Scientist, Same Role as Alice) should see it due to Team Visibility\n    mock_state[\"turn\"][\"current\"] = \"Bob\"\n    msgs_bob = engine.wait_for_turn(\"Bob\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_bob) == 1\n    assert msgs_bob[0][\"content\"] == \"Team Secret\"\n    \n    # Charlie (Engineer, Diff Role) should NOT see it\n    mock_state[\"turn\"][\"current\"] = \"Charlie\"\n    msgs_charlie = engine.wait_for_turn(\"Charlie\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_charlie) == 0\n\ndef test_visibility_private_message_audience(mock_state):\n    store = MockStateStore(mock_state)\n    engine = Engine(store)\n    \n    # Alice sends Private message to Miller, mentioning Charlie in audience\n    # Charlie is an Engineer (Diff role from Alice)\n    engine.post_message(\"Alice\", \"Secret with Charlie\", False, \"Miller\", audience=[\"Charlie\"])\n    \n    # 1. Miller (Target) should see it\n    msgs_miller = engine.wait_for_turn(\"Miller\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_miller) == 1\n    \n    # 2. Charlie (Audience) should see it\n    mock_state[\"turn\"][\"current\"] = \"Charlie\"\n    msgs_charlie = engine.wait_for_turn(\"Charlie\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_charlie) == 1\n    assert msgs_charlie[0][\"content\"] == \"Secret with Charlie\"\n    \n    # 3. Bob (Scientist, same role as Alice) should also see it due to team visibility\n    mock_state[\"turn\"][\"current\"] = \"Bob\"\n    msgs_bob = engine.wait_for_turn(\"Bob\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_bob) == 1", "start_line": 81, "end_line": 129}, {"path": "tests/test_privacy_logic.py", "content": "    mock_state[\"turn\"][\"current\"] = \"Charlie\"\n    msgs_charlie = engine.wait_for_turn(\"Charlie\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_charlie) == 1\n    assert msgs_charlie[0][\"content\"] == \"Secret with Charlie\"\n    \n    # 3. Bob (Scientist, same role as Alice) should also see it due to team visibility\n    mock_state[\"turn\"][\"current\"] = \"Bob\"\n    msgs_bob = engine.wait_for_turn(\"Bob\", timeout_seconds=1)[\"messages\"]\n    assert len(msgs_bob) == 1", "start_line": 121, "end_line": 129}, {"path": "tests/test_context_files.py", "content": "import pytest\nimport os\nimport json\nimport time\nimport sys\n# Add current directory to sys.path to allow relative imports if needed\nsys.path.append(os.path.dirname(__file__))\nfrom test_orchestration import ServerProcess, server_single\n\ndef test_context_files_generation(server_single):\n    \"\"\"\n    Verifies that MEMORY.md and CONVERSATION.md are created in the server's working directory\n    when agent and talk tools are called.\n    \"\"\"\n    proc = server_single\n    \n    # 1. Register Agent\n    # This triggers 'agent' tool which should create the files (empty or initial)\n    resp = proc.call_tool(\"agent\", {})\n    assert \"REGISTRATION SUCCESSFUL\" in resp\n    \n    # Check if files exist\n    # The server is running in the same directory as the test (for now, or CWD)\n    # verify_logic.py sets CWD to the project root or similar. \n    # Helper: server.py uses EXECUTION_DIR which is get_current_working_dir().\n    # In test_orchestration, we run python server.py. usage CWD is inherited.\n    # We need to know where the server thinks is CWD.\n    \n    # Let's assume CWD is where we ran pytest from, which is likely project root.\n    cwd = os.getcwd()\n    memory_file = os.path.join(cwd, \"MEMORY.md\")\n    conversation_file = os.path.join(cwd, \"CONVERSATION.md\")\n    \n    # Wait briefly for file system\n    time.sleep(0.5)\n    \n    assert os.path.exists(memory_file), f\"MEMORY.md not found in {cwd}\"\n    assert os.path.exists(conversation_file), f\"CONVERSATION.md not found in {cwd}\"\n    \n    # 2. Add a Note (Update Memory)\n    note_content = \"This is a test note for context file verification.\"\n    proc.call_tool(\"note\", {\"content\": note_content, \"from_agent\": \"Agent1\"})\n    \n    # 3. Talk (Trigger Context Update)\n    # The 'talk' tool re-generates the context files before returning the prompt\n    msg_content = \"Hello, checking context files.\"\n    proc.call_tool(\"talk\", {\n        \"message\": msg_content, \n        \"public\": True, \n        \"to\": \"User\", ", "start_line": 1, "end_line": 50}, {"path": "tests/test_context_files.py", "content": "    note_content = \"This is a test note for context file verification.\"\n    proc.call_tool(\"note\", {\"content\": note_content, \"from_agent\": \"Agent1\"})\n    \n    # 3. Talk (Trigger Context Update)\n    # The 'talk' tool re-generates the context files before returning the prompt\n    msg_content = \"Hello, checking context files.\"\n    proc.call_tool(\"talk\", {\n        \"message\": msg_content, \n        \"public\": True, \n        \"to\": \"User\", \n        \"from_agent\": \"Agent1\"\n    })\n    \n    # Verify Content of MEMORY.md\n    with open(memory_file, \"r\") as f:\n        mem_content = f.read()\n    assert note_content in mem_content\n    \n    # Verify Content of CONVERSATION.md\n    with open(conversation_file, \"r\") as f:\n        conv_content = f.read()\n    assert msg_content in conv_content\n    assert \"Agent1\" in conv_content\n    \n    print(\"\u2705 Context files verification passed.\")\n\n    # Cleanup\n    if os.path.exists(memory_file):\n        os.remove(memory_file)\n    if os.path.exists(conversation_file):\n        os.remove(conversation_file)", "start_line": 41, "end_line": 71}, {"path": "tests/state_test_multi.json", "content": "{\n  \"messages\": [\n    {\n      \"from\": \"System\",\n      \"content\": \"\\ud83d\\udd35 **Agent1** has joined the simulation.\",\n      \"public\": true,\n      \"target\": \"all\",\n      \"audience\": [],\n      \"timestamp\": 1768554914.1855621\n    },\n    {\n      \"from\": \"System\",\n      \"content\": \"\\ud83d\\udd35 **Agent2** has joined the simulation.\",\n      \"public\": true,\n      \"target\": \"all\",\n      \"audience\": [],\n      \"timestamp\": 1768554914.1914856\n    }\n  ],\n  \"conversation_id\": \"test-uuid-multi\",\n  \"turn\": {\n    \"current\": \"Agent1\",\n    \"next\": null,\n    \"turn_start_time\": 1768554916.1945682\n  },\n  \"agents\": {\n    \"Agent1\": {\n      \"status\": \"connected\",\n      \"role\": \"Test Role 1\",\n      \"profile_ref\": \"TestProfile\",\n      \"reload_active\": false\n    },\n    \"Agent2\": {\n      \"status\": \"connected\",\n      \"role\": \"Test Role 2\",\n      \"profile_ref\": \"TestProfile\",\n      \"reload_active\": false\n    }\n  },\n  \"config\": {\n    \"total_agents\": 2,\n    \"profiles\": [\n      {\n        \"name\": \"TestProfile\",\n        \"capabilities\": [\n          \"public\",\n          \"private\",\n          \"turn\",\n          \"open\"\n        ],", "start_line": 1, "end_line": 50}, {"path": "tests/state_test_multi.json", "content": "    \"total_agents\": 2,\n    \"profiles\": [\n      {\n        \"name\": \"TestProfile\",\n        \"capabilities\": [\n          \"public\",\n          \"private\",\n          \"turn\",\n          \"open\"\n        ],\n        \"connections\": []\n      }\n    ]\n  }\n}", "start_line": 41, "end_line": 55}, {"path": "tests/state_test.json", "content": "{\"messages\": [], \"conversation_id\": \"test-uuid\", \"turn\": {\"current\": \"Agent1\", \"next\": null}, \"agents\": {\"Agent1\": {\"status\": \"pending_connection\", \"role\": \"Test Role 1\"}, \"Agent2\": {\"status\": \"pending_connection\", \"role\": \"Test Role 2\"}}, \"config\": {\"total_agents\": 2}}", "start_line": 1, "end_line": 1}, {"path": "tests/test_orchestration.py", "content": "import pytest\nimport subprocess\nimport sys\nimport os\nimport json\nimport time\nimport threading\nfrom typing import Dict, Any, Optional\n\n# Add src to path\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\")))\n\nSERVER_SCRIPT = os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"src\", \"core\", \"server.py\"))\n\nclass ServerProcess:\n    def send_notification(self, method: str, params: Optional[Dict[str, Any]] = None):\n        req = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"params\": params or {}\n            # No ID for notifications\n        }\n        \n        json_req = json.dumps(req)\n        try:\n            self.process.stdin.write(json_req + \"\\n\")\n            self.process.stdin.flush()\n        except BrokenPipeError:\n            raise RuntimeError(\"Server process died unexpectedly.\")\n\n    def send_request_async(self, method: str, params: Optional[Dict[str, Any]] = None) -> int:\n        \"\"\"Sends a request and returns the ID, does not wait for response.\"\"\"\n        with self.lock:\n            self.request_id += 1\n            curr_id = self.request_id\n        \n        req = {\n            \"jsonrpc\": \"2.0\",\n            \"method\": method,\n            \"params\": params or {},\n            \"id\": curr_id\n        }\n        \n        json_req = json.dumps(req)\n        try:\n            self.process.stdin.write(json_req + \"\\n\")\n            self.process.stdin.flush()\n        except BrokenPipeError:\n            raise RuntimeError(\"Server process died unexpectedly.\")\n            ", "start_line": 1, "end_line": 50}, {"path": "tests/test_orchestration.py", "content": "            \"id\": curr_id\n        }\n        \n        json_req = json.dumps(req)\n        try:\n            self.process.stdin.write(json_req + \"\\n\")\n            self.process.stdin.flush()\n        except BrokenPipeError:\n            raise RuntimeError(\"Server process died unexpectedly.\")\n            \n        return curr_id\n\n    def read_response(self, request_id: int, timeout=5) -> Any:\n        # Simple blocking read loop that discards others until match\n        start = time.time()\n        while time.time() - start < timeout:\n            line = self.process.stdout.readline()\n            if not line:\n                raise RuntimeError(\"Server closed connection.\")\n            \n            try:\n                data = json.loads(line)\n            except json.JSONDecodeError:\n                continue\n                \n            if data.get(\"id\") == request_id:\n                if \"error\" in data:\n                    raise RuntimeError(f\"RPC Error: {data['error']}\")\n                return data[\"result\"]\n            # Buffer others? For this simple test we might lose them if we don't buffer.\n             # Ideally we should have a background reader thread filling a dict of futures.\n        raise TimeoutError(f\"Timeout waiting for request {request_id}\")\n\n    # Advanced Client with buffering\n    def __init__(self, use_single_agent=False, reset_state=True):\n        # Use uv run to ensure dependencies are available in the subprocess\n        cmd = [\"uv\", \"run\", \"python\", SERVER_SCRIPT]\n        \n        # Use a temporary state file for testing\n        suffix = \"_single\" if use_single_agent else \"_multi\"\n        self.state_file = os.path.abspath(os.path.join(os.path.dirname(__file__), f\"state_test{suffix}.json\"))\n        \n        # Pre-populate state file\n        if reset_state:\n            if use_single_agent:\n                 initial_state = {\n                    \"messages\": [],\n                    \"conversation_id\": \"test-uuid-single\",\n                    \"turn\": {\"current\": \"Agent1\", \"next\": None},\n                    \"agents\": {", "start_line": 41, "end_line": 90}, {"path": "tests/test_orchestration.py", "content": "        self.state_file = os.path.abspath(os.path.join(os.path.dirname(__file__), f\"state_test{suffix}.json\"))\n        \n        # Pre-populate state file\n        if reset_state:\n            if use_single_agent:\n                 initial_state = {\n                    \"messages\": [],\n                    \"conversation_id\": \"test-uuid-single\",\n                    \"turn\": {\"current\": \"Agent1\", \"next\": None},\n                    \"agents\": {\n                         \"Agent1\": {\"status\": \"pending_connection\", \"role\": \"Test Role 1\", \"profile_ref\": \"TestProfile\"}\n                    },\n                    \"config\": {\n                        \"total_agents\": 1,\n                        \"profiles\": [\n                            {\"name\": \"TestProfile\", \"capabilities\": [\"public\", \"private\", \"turn\", \"open\"], \"connections\": []}\n                        ]\n                    }\n                }\n            else:\n                initial_state = {\n                    \"messages\": [],\n                    \"conversation_id\": \"test-uuid-multi\",\n                    \"turn\": {\"current\": \"Agent1\", \"next\": None},\n                    \"agents\": {\n                         \"Agent1\": {\"status\": \"pending_connection\", \"role\": \"Test Role 1\", \"profile_ref\": \"TestProfile\"},\n                         \"Agent2\": {\"status\": \"pending_connection\", \"role\": \"Test Role 2\", \"profile_ref\": \"TestProfile\"}\n                    },\n                    \"config\": {\n                        \"total_agents\": 2,\n                        \"profiles\": [\n                             {\"name\": \"TestProfile\", \"capabilities\": [\"public\", \"private\", \"turn\", \"open\"], \"connections\": []}\n                        ]\n                    }\n                }\n\n            with open(self.state_file, \"w\") as f:\n                json.dump(initial_state, f)\n            \n        env = os.environ.copy()\n        env[\"MULTI_AGENT_STATE_PATH\"] = self.state_file\n        \n        self.process = subprocess.Popen(\n            cmd,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE, # Capture stderr to assert Warnings\n            text=True,\n            bufsize=1, # Line buffered\n            env=env", "start_line": 81, "end_line": 130}, {"path": "tests/test_orchestration.py", "content": "        env[\"MULTI_AGENT_STATE_PATH\"] = self.state_file\n        \n        self.process = subprocess.Popen(\n            cmd,\n            stdin=subprocess.PIPE,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE, # Capture stderr to assert Warnings\n            text=True,\n            bufsize=1, # Line buffered\n            env=env\n        )\n        self.lock = threading.Lock()\n        self.request_id = 0\n        self.responses = {}\n        self.stderr_log = []\n        \n        self.reader_thread = threading.Thread(target=self._reader_loop, daemon=True)\n        self.reader_thread.start()\n        \n        self.stderr_thread = threading.Thread(target=self._stderr_loop, daemon=True)\n        self.stderr_thread.start()\n\n        # Setup use_single_agent state for restart helper if needed?\n        self._use_single_agent = use_single_agent\n\n    def restart(self):\n        \"\"\"Restarts the server process preserving state.\"\"\"\n        self.terminate()\n        # Re-init process ONLY, without writing state\n        self.__init__(use_single_agent=self._use_single_agent, reset_state=False)\n\n    def _reader_loop(self):\n        while True:\n            line = self.process.stdout.readline()\n            if not line:\n                break\n            try:\n                data = json.loads(line)\n                if \"id\" in data:\n                    self.responses[data[\"id\"]] = data\n            except:\n                pass\n                \n    def _stderr_loop(self):\n        # Read stderr line by line\n        for line in self.process.stderr:\n            self.stderr_log.append(line.strip())\n            print(f\"[SERVER STDERR] {line.strip()}\", file=sys.stderr)\n\n    def get_response(self, request_id: int, timeout=10) -> Any:", "start_line": 121, "end_line": 170}, {"path": "tests/test_orchestration.py", "content": "            except:\n                pass\n                \n    def _stderr_loop(self):\n        # Read stderr line by line\n        for line in self.process.stderr:\n            self.stderr_log.append(line.strip())\n            print(f\"[SERVER STDERR] {line.strip()}\", file=sys.stderr)\n\n    def get_response(self, request_id: int, timeout=10) -> Any:\n        start = time.time()\n        while time.time() - start < timeout:\n            if request_id in self.responses:\n                data = self.responses[request_id]\n                if \"error\" in data:\n                     raise RuntimeError(f\"RPC Error: {data['error']}\")\n                return data[\"result\"]\n            time.sleep(0.1)\n        raise TimeoutError(f\"Timeout waiting for request {request_id}\")\n\n    def call_tool(self, name: str, arguments: Dict[str, Any] = {}) -> Any:\n        # Blocking call\n        rid = self.send_request_async(\"tools/call\", {\"name\": name, \"arguments\": arguments})\n        res = self.get_response(rid)\n        return res.get(\"content\", [{}])[0].get(\"text\", \"\")\n    \n    def call_tool_async(self, name: str, arguments: Dict[str, Any] = {}) -> int:\n        return self.send_request_async(\"tools/call\", {\"name\": name, \"arguments\": arguments})\n        \n    def get_tool_result(self, request_id: int) -> str:\n        res = self.get_response(request_id)\n        return res.get(\"content\", [{}])[0].get(\"text\", \"\")\n\n    def terminate(self):\n        self.process.terminate()\n        self.process.wait()\n\n@pytest.fixture\ndef server_multi():\n    proc = ServerProcess(use_single_agent=False)\n    proc.send_request_async(\"initialize\", {\n        \"protocolVersion\": \"2024-11-05\", \n        \"capabilities\": {},\n        \"clientInfo\": {\"name\": \"test-client\", \"version\": \"1.0\"}\n    })\n    rid = proc.request_id \n    proc.get_response(rid)\n    proc.send_notification(\"notifications/initialized\")\n    yield proc\n    proc.terminate()", "start_line": 161, "end_line": 210}, {"path": "tests/test_orchestration.py", "content": "    proc.send_request_async(\"initialize\", {\n        \"protocolVersion\": \"2024-11-05\", \n        \"capabilities\": {},\n        \"clientInfo\": {\"name\": \"test-client\", \"version\": \"1.0\"}\n    })\n    rid = proc.request_id \n    proc.get_response(rid)\n    proc.send_notification(\"notifications/initialized\")\n    yield proc\n    proc.terminate()\n\n@pytest.fixture\ndef server_single():\n    proc = ServerProcess(use_single_agent=True)\n    proc.send_request_async(\"initialize\", {\n        \"protocolVersion\": \"2024-11-05\", \n        \"capabilities\": {},\n        \"clientInfo\": {\"name\": \"test-client\", \"version\": \"1.0\"}\n    })\n    rid = proc.request_id \n    proc.get_response(rid)\n    proc.send_notification(\"notifications/initialized\")\n    yield proc\n    proc.terminate()\n\ndef test_session_collision(server_multi):\n    \"\"\"\n    Simulates collision.\n    \"\"\"\n    # 1. Register A1\n    rid1 = server_multi.call_tool_async(\"agent\", {})\n    # 2. Register A2 (Collision!)\n    rid2 = server_multi.call_tool_async(\"agent\", {})\n    \n    res1 = server_multi.get_tool_result(rid1)\n    \n    # A2 might Timeout because it blocks waiting for Turn (and Turn is A1)\n    try:\n        # We assume get_tool_result raises TimeoutError\n        res2 = server_multi.get_tool_result(rid2, timeout=5)\n    except Exception:\n        print(\"Expected Timeout on Agent 2 (waiting for turn). checking logs...\")\n    \n    assert \"REGISTRATION SUCCESSFUL\" in res1\n    \n    # New Behavior (Trust Turn): No Warning, just silent overwrite.\n    # We verify that NO Warning is present.\n    time.sleep(1) # Wait for log flush\n    log_content = \"\\n\".join(server_multi.stderr_log)\n    assert \"SESSION WARNING\" not in log_content", "start_line": 201, "end_line": 250}, {"path": "tests/test_orchestration.py", "content": "    except Exception:\n        print(\"Expected Timeout on Agent 2 (waiting for turn). checking logs...\")\n    \n    assert \"REGISTRATION SUCCESSFUL\" in res1\n    \n    # New Behavior (Trust Turn): No Warning, just silent overwrite.\n    # We verify that NO Warning is present.\n    time.sleep(1) # Wait for log flush\n    log_content = \"\\n\".join(server_multi.stderr_log)\n    assert \"SESSION WARNING\" not in log_content\n    print(\"Verified Seamless Session Binding (No Warning).\")\n\ndef test_features_single_agent(server_single):\n    \"\"\"\n    Verifies History, Memory using single agent via Restart Pattern.\n    \"\"\"\n    # 1. Register A1\n    resp = server_single.call_tool(\"agent\", {})\n    assert \"REGISTRATION SUCCESSFUL\" in resp\n    \n    # 2. Note (Memory)\n    server_single.call_tool(\"note\", {\"content\": \"My Secret Note\", \"from_agent\": \"Agent1\"})\n    \n    # 3. Talk (Send Message to User) -> Apps to history but keeps turn\n    # Sending to User is valid even for single agent\n    res_talk = server_single.call_tool(\"talk\", {\"message\": \"Hello History\", \"public\": True, \"to\": \"User\", \"from_agent\": \"Agent1\"})\n    \n    # 'talk' returns the NEXT prompt (since turn is kept).\n    # We rely on rejoin to verify history.\n    \n    # 'talk' returns the NEXT prompt (since turn is kept).\n    # We rely on rejoin to verify history.\n    \n    # 4. RESTART SERVER to simulate Re-Entry\n    # CRITICAL: Since state is preserved, Agent1 is still \"connected\".\n    # server.py (new process) has empty AGENT_SESSIONS.\n    # register_agent sees \"connected\" and fails with GAME FULL.\n    # We must simulating a \"Disconnected\" state by manually updating the state file\n    # (In real app, we'd have a timeout or admin tool, or session recovery).\n    \n    with open(server_single.state_file, \"r+\") as f:\n        import fcntl\n        fcntl.flock(f, fcntl.LOCK_EX) # Lock for safety\n        data = json.load(f)\n        data[\"agents\"][\"Agent1\"][\"status\"] = \"pending_connection\"\n        data[\"turn\"][\"current\"] = \"Agent1\" # Reset turn to avoid deadlock since User has it\n        f.seek(0)\n        json.dump(data, f)\n        f.truncate()\n        fcntl.flock(f, fcntl.LOCK_UN)", "start_line": 241, "end_line": 290}, {"path": "tests/test_orchestration.py", "content": "    with open(server_single.state_file, \"r+\") as f:\n        import fcntl\n        fcntl.flock(f, fcntl.LOCK_EX) # Lock for safety\n        data = json.load(f)\n        data[\"agents\"][\"Agent1\"][\"status\"] = \"pending_connection\"\n        data[\"turn\"][\"current\"] = \"Agent1\" # Reset turn to avoid deadlock since User has it\n        f.seek(0)\n        json.dump(data, f)\n        f.truncate()\n        fcntl.flock(f, fcntl.LOCK_UN)\n    \n    server_single.restart()\n    proc2 = server_single # Same object updated\n    \n    proc2.send_request_async(\"initialize\", {\n        \"protocolVersion\": \"2024-11-05\", \n        \"capabilities\": {},\n        \"clientInfo\": {\"name\": \"test-client\", \"version\": \"1.0\"}\n    })\n    rid = proc2.request_id \n    proc2.get_response(rid)\n    proc2.send_notification(\"notifications/initialized\")\n    \n    # 5. Register A1 Again\n    # No try/finally needed as fixture handles teardown (proc2 is server_single)\n    resp_rejoin = proc2.call_tool(\"agent\", {})\n    \n    # Verify Context Instruction in Prompt\n    assert \"CONVERSATION.md\" in resp_rejoin\n    \n    # Verify Memory in Prompt?\n    # Note tool saves to memory. Memory is injected where?\n    # Check agent_response.j2 for Memory/Note section?\n    # It usually depends on system prompt construction.\n    # If 'My Secret Note' is expected, assert it.\n    # But `agent()` relies on LLM context or retrieval.\n    # `agent_response.j2` might doesn't show notes unless custom logic.\n    # But History IS updated.\n    print(\"Verified History Persistence on Rejoin.\")\n\ndef test_logic_unit_tests():\n    \"\"\"\n    Runs the verification script using uv run to ensure environment consistency.\n    \"\"\"\n    script_path = os.path.join(os.path.dirname(__file__), \"verify_logic.py\")\n    cmd = [\"uv\", \"run\", \"python\", script_path]\n    \n    result = subprocess.run(cmd, capture_output=True, text=True)\n    \n    print(result.stdout)", "start_line": 281, "end_line": 330}, {"path": "tests/test_orchestration.py", "content": "def test_logic_unit_tests():\n    \"\"\"\n    Runs the verification script using uv run to ensure environment consistency.\n    \"\"\"\n    script_path = os.path.join(os.path.dirname(__file__), \"verify_logic.py\")\n    cmd = [\"uv\", \"run\", \"python\", script_path]\n    \n    result = subprocess.run(cmd, capture_output=True, text=True)\n    \n    print(result.stdout)\n    if result.returncode != 0:\n        print(result.stderr)\n        pytest.fail(f\"Logic Validation Script failed: {result.stderr}\")\n        \n    assert \"ALL LOGIC CHECKS PASSED\" in result.stdout", "start_line": 321, "end_line": 335}, {"path": "tests/verify_logic.py", "content": "\nimport sys\nimport os\nimport json\nimport tempfile\nimport time\n\n# Add src to path\nsys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\")))\n\ntry:\n    from src.core.logic import Engine\n    from src.core.state import StateStore\n    import portalocker\nexcept ImportError as e:\n    print(f\"SKIP: Missing dependencies for logic compliance verification: {e}\")\n    sys.exit(0)\n\ndef verify_logic_compliance():\n    print(\"--- Verifying Core Logic Compliance ---\")\n    \n    # 1. Setup Temp State\n    f, path = tempfile.mkstemp()\n    os.close(f)\n    \n    state_data = {\n        \"messages\": [],\n        \"conversation_id\": \"unit-test-logic\",\n        \"turn\": {\"current\": \"Agent1\", \"next\": None},\n        \"agents\": {\n             \"Agent1\": {\"status\": \"connected\", \"role\": \"R1\", \"profile_ref\": \"P1\"},\n             \"Agent2\": {\"status\": \"connected\", \"role\": \"R2\", \"profile_ref\": \"P1\"},\n             \"Agent3\": {\"status\": \"connected\", \"role\": \"R3\", \"profile_ref\": \"P1\"}\n        },\n        \"config\": {\n            \"total_agents\": 3,\n            \"profiles\": [\n                {\"name\": \"P1\", \"capabilities\": [\"public\", \"private\", \"turn\", \"open\", \"audience\"], \"connections\": [\n                    {\"target\":\"P1\", \"context\":\"peer\"},\n                    {\"target\":\"User\", \"context\":\"admin\"}\n                ]}\n            ]\n        }\n    }\n    \n    with open(path, \"w\") as f:\n        json.dump(state_data, f)\n        \n    store = StateStore(path)\n    engine = Engine(store)", "start_line": 1, "end_line": 50}, {"path": "tests/verify_logic.py", "content": "                ]}\n            ]\n        }\n    }\n    \n    with open(path, \"w\") as f:\n        json.dump(state_data, f)\n        \n    store = StateStore(path)\n    engine = Engine(store)\n    \n    # 2. Test Private Message Visibility\n    print(\"Test 1: Private Message Visibility (A1 -> A2)...\", end=\" \")\n    engine.post_message(\"Agent1\", \"Secret A1->A2\", False, \"Agent2\")\n    \n    data = store.load()\n    msg = data[\"messages\"][-1]\n    \n    # Manual Visibility Check logic from server/logic\n    # Visible = Public OR (Private AND (To Me OR From Me OR In Audience))\n    def is_visible(m, me):\n        if m[\"public\"]: return True\n        if m[\"from\"] == me: return True\n        if m[\"target\"] == me: return True\n        # Audience removed\n        return False\n        \n    assert is_visible(msg, \"Agent1\") == True\n    assert is_visible(msg, \"Agent2\") == True\n    assert is_visible(msg, \"Agent3\") == False\n    print(\"PASSED\")\n    \n    # 3. Test User Interaction Bypass\n    print(\"Test 3: User Interaction (A2 -> User)...\", end=\" \")\n    res = engine.post_message(\"Agent2\", \"Help User\", True, \"User\")\n    print(f\"DEBUG RES: {res}\", file=sys.stderr)\n    assert \"Turn is now: User\" in res\n    \n    # Verify Turn did NOT change\n    data = store.load()\n    assert data[\"turn\"][\"current\"] == \"User\" # Wait, post_message doesn't advance turn from current?\n    # Logic: old_turn = state[\"turn\"][\"current\"]. \n    # If next_agent == User, return \"Turn remains\".\n    # state[\"turn\"][\"current\"] is unchanged.\n    print(\"PASSED\")\n    \n    # Cleanup\n    os.remove(path)\n    print(\"--- ALL LOGIC CHECKS PASSED ---\")\n", "start_line": 41, "end_line": 90}, {"path": "tests/verify_logic.py", "content": "    assert data[\"turn\"][\"current\"] == \"User\" # Wait, post_message doesn't advance turn from current?\n    # Logic: old_turn = state[\"turn\"][\"current\"]. \n    # If next_agent == User, return \"Turn remains\".\n    # state[\"turn\"][\"current\"] is unchanged.\n    print(\"PASSED\")\n    \n    # Cleanup\n    os.remove(path)\n    print(\"--- ALL LOGIC CHECKS PASSED ---\")\n\nif __name__ == \"__main__\":\n    verify_logic_compliance()", "start_line": 81, "end_line": 92}, {"path": "blueprint/1-idea.md", "content": "Ok, j'ai envie de me lancer dans un projet un peu fou, mais absolument g\u00e9nial \u00e0 mon avis, qui est un MCP multi-agents qui en particulier pourra tourner sur des moteurs comme Antigravity, des IDE comme Antigravity qui ont acc\u00e8s au MCP, un peu comme Cursor en fait un ou GitHub Copilot, mais en fait n'importe quelle interface qui permet d'avoir du-du un protocole MCP pour les IA.\n\nL'id\u00e9e est la suivante, je veux avoir un truc qui s'installe dans n'importe quel repository ou dans n'importe quel dossier et qui va me configurer le MCP multi-agent ainsi qu'une r\u00e8gle de d\u00e9marrage qui explique \u00e0 l'agent qu'il va rentrer dans un syst\u00e8me multi-agents, que un MCP va lui expliquer son r\u00f4le et qu'ensuite, il pourra communiquer avec d'autres agents suivant des r\u00e8gles pr\u00e9\u00e9tablies.\n\nJ'aimerais avoir aussi une interface Streamlit que je peux lancer et qui me permet de visualiser la discussion entre les diff\u00e9rents agents. Donc l'id\u00e9e est la suivante, je lance une conversation avec la-la-la commande enregistr\u00e9e, donc l\u00e0 au format Antigravity euh... pour dire \"ok maintenant tu es un agent\" donc appelle le MCP. Le serveur MCP lui-m\u00eame n'a que deux m\u00e9thodes en fait tr\u00e8s simples, m\u00eame qu'une seule m\u00e9thode en fait non, qu'une seule m\u00e9thode et la m\u00e9thode, c'est \"talk\" grosso modo qui permet \u00e0 l'agent de discuter avec d'autres agents.\n\nDonc quand il effectue \"talk\", l'agent va en fait passer un message qui est affich\u00e9, soit enfin qui-qui est soit public, soit priv\u00e9 et qui est \u00e0 destination d'un agent en particulier. En fait ce message, il va \u00eatre soit affich\u00e9 \u00e0 tout le monde, soit affich\u00e9 uniquement \u00e0 l'agent suivant et ensuite, l'agent choisit \u00e9galement l'agent suivant. Donc voil\u00e0, c'est une m\u00e9thode toute simple qui contient grosso modo trois champs, le message public qui est un bol\u00e9en, yes or no et next agent qui est une string qui indique le prochain agent.\n\nEt en fait le serveur MCP ce qu'il va faire c'est qu'il share toutes les conversations en parall\u00e8le. Alors au d\u00e9but, il y a une phase d'initialisation o\u00f9 il demande \u00e0 l'utilisateur de lancer toutes les-conversations dans l'interface Streamlit, on voit \u00e0 chaque fois qu'un agent se connecte et parle pour la premi\u00e8re fois, au d\u00e9but, on lui dit ok appel parle de base pour dire je suis l\u00e0 \u00e0 tout le monde et donc enfin pour dire bonjour \u00e0 tout le monde et grosso modo \u00e7a permet d'initialiser l'agent donc \u00e7a veut dire que le serveur MCP sait que cet agent est cet agent.\n\nEn fait, il devrait m\u00eame y avoir deux m\u00e9thodes. Il y a la m\u00e9thode talk et la m\u00e9thode agent. Et agent, c'est simplement une m\u00e9thode qu'on est cens\u00e9 appeler au tout d\u00e9but qui donne ton r\u00f4le. Le serveur MCP va retourner quand un agent appelle au tout d\u00e9but d'une conversation agent, la m\u00e9thode agent, et bien le serveur MCP va lui dire qui il est. Donc, il va regarder les r\u00f4les qui lui restent \u00e0 distribuer. Il va dire ok, toi maintenant, tu es telle personne, toi maintenant, tu es telle personne, et cetera. Et donc dans l'interface Streamlit, on va voir s'allumer en vert tous-tous les agents \u00e0 mesure qu'ils se, ils rejoignent la conversation entre guillemets. Et ensuite quand ils sont tous verts, le serveur MCP lance la conversation.\n\nAlors l'int\u00e9r\u00eat, c'est qu'en fait quand on a cette m\u00e9thode agent en fait qui est appel\u00e9e, le serveur MCP se base sur un syst\u00e8me de sleep, c'est-\u00e0-dire que quand l'agent par exemple agent A veut s'adresser \u00e0 agent B, il utilise la m\u00e9thode talk et l\u00e0 la m\u00e9thode talk, ce qu'elle fait, c'est que elle fait un sleep, elle attend que ce soit \u00e0 nouveau au tour de l'agent A de parler. Et ensuite, elle d\u00e9bloque le sleep qui \u00e9tait en cours sur l'agent B pour que l'agent B reprenne la conversation. Et \u00e7a renvoie aussi l'\u00e9tat actuel de la conversation, c'est-\u00e0-dire tout ce que les autres agents ont dit, et \u00e7a rappelle aussi les r\u00e8gles syst\u00e8me de l'agent en cours.\n\nDonc chaque agent poss\u00e8de une description des autres agents et peut savoir \u00e0 qui il veut s'adresser. Il peut y avoir des r\u00e8gles particuli\u00e8res. Et tous les agents et les r\u00e8gles des agents peuvent \u00eatre configur\u00e9s dans l'interface Streamlit. L'interface Streamlit devrait avoir grosso modo deux pages, une page de configuration d'agent qui liste tous les agents avec leur prompt syst\u00e8me et c'est tout en fait, uniquement leur prompt syst\u00e8me et qui affiche s'ils sont en ligne ou pas et de quand date leur dernier message par exemple et l'interface conversation o\u00f9 on voit l'ensemble de la conversation, on voit qui s'est adress\u00e9 \u00e0 qui, la conversation publique comme une sorte de grande chat, on voit quel agent a dit quoi et o\u00f9 l'utilisateur peut aussi s'immiscer dans la conversation, lui il a le r\u00f4le user et il peut dire un message \u00e0 un moment et ce message sera affich\u00e9 dans la conversation, ce qui fait que tous les agents le verront.\n\nIl peut aussi s'adresser dans l'interface Streamlit, l'utilisateur peut s'adresser \u00e0 un agent en particulier et \u00e0 ce moment-l\u00e0 seul cet agent verra le message de l'utilisateur en question, quand ce sera \u00e0 son tour de parler. Et il peut \u00e9galement y avoir un truc qui force ou pas l'envoi instantan\u00e9 du message \u00e0 ce moment-l\u00e0 le prochain la prochaine mise \u00e0 jour MCP ce sera ce sera celle de l'utilisateur, mais \u00e7a \u00e0 la limite, c'est \u00e0 discuter.\n\nMais du coup voil\u00e0, on a un truc qui permet de simuler une conversation alors c'est \u00e0 la fois quelque chose qui m'aidera \u00e0 coder parce que \u00e7a me permet d'avoir vraiment un syst\u00e8me multi-agents qui code avec un agent qui \u00e9value les r\u00e9sultats, un agent qui dialogue avec l'utilisateur, un agent qui-qui-qui code litt\u00e9ralement, un agent qui ex\u00e9cute les exp\u00e9riences et c\u00e6tera. Et \u00e7a me permettra aussi de faire plein d'exp\u00e9riences par exemple de simuler un jeu de loup-garou entre plusieurs agents puisque les agents peuvent s'adresser des messages directs ou indirects publics ou pas, on peut avoir un ma\u00eetre du jeu qui g\u00e8re toute la conversation qui g\u00e8re les morts et c\u00e6tera et \u00e7a permet aussi aux agents de-de-de se souvenir uniquement de leur conversation en fait leur contexte, c'est leur m\u00e9moire \u00e0 court terme ce qui est excellent, \u00e7a permet de split la m\u00e9moire \u00e0 court terme.\n\nDonc voil\u00e0, je pense que l'id\u00e9e est extraordinaire, j'ai trop envie de m'y mettre. Par contre, il y a un bloqueur, c'est le seul truc que je ne sais pas s'il est possible de faire, c'est est-ce qu'il est possible de faire un sleep dans les serveurs MCP ? Est-ce qu'il ne risque pas au bout de, je ne sais pas cinq minutes d'attente ou m\u00eame moins peut-\u00eatre, j'esp\u00e8re moins, l'agent tue le MCP en disant bon, il y a eu une erreur, on attend depuis trop longtemps quelque chose dans ce style donc \u00e7a il faut absolument que je le v\u00e9rifie.", "start_line": 1, "end_line": 21}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n\n## \u2705 Done\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 25}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n\n## \u2705 Done\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 25}, {"path": "src/services/search_engine.py", "content": "\nimport os\nimport time\nimport threading\nimport json\nimport logging\nimport fnmatch\nfrom pathlib import Path\nfrom typing import List, Dict, Optional, Tuple\n\nimport numpy as np\n\n# Conditional imports to avoid crashing if dependencies are missing during dev\ntry:\n    import faiss\n    from sentence_transformers import SentenceTransformer\n    from watchdog.observers import Observer\n    from watchdog.events import FileSystemEventHandler\nexcept ImportError:\n    faiss = None\n    SentenceTransformer = None\n    Observer = None\n    FileSystemEventHandler = object\n\nfrom src.utils.logger import get_logger\n\nlogger = get_logger()\n\n# --- CONSTANTS ---\nMODEL_NAME = 'all-MiniLM-L6-v2'\nVECTOR_DIM = 384  # Dimension for MiniLM-L6-v2\nINDEX_FILE = \"search_index.faiss\"\nMETADATA_FILE = \"search_metadata.json\"\n\nclass SearchEngine(FileSystemEventHandler):\n    _instance = None\n    _lock = threading.Lock()\n\n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super(SearchEngine, cls).__new__(cls)\n                    cls._instance.initialized = False\n        return cls._instance\n\n    def initialize(self, root_dir: Path, persist_dir: Path, watch: bool = True):\n        \"\"\"\n        Initialize the search engine.\n        \"\"\"", "start_line": 1, "end_line": 50}, {"path": "src/services/search_engine.py", "content": "            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super(SearchEngine, cls).__new__(cls)\n                    cls._instance.initialized = False\n        return cls._instance\n\n    def initialize(self, root_dir: Path, persist_dir: Path, watch: bool = True):\n        \"\"\"\n        Initialize the search engine.\n        \"\"\"\n        if self.initialized:\n            return\n\n        self.root_dir = root_dir\n        self.persist_dir = persist_dir\n        self.persist_dir.mkdir(parents=True, exist_ok=True)\n        \n        self.index_path = self.persist_dir / INDEX_FILE\n        self.metadata_path = self.persist_dir / METADATA_FILE\n        \n        self.model = None\n        self.index = None\n        self.file_paths = [] \n        self.chunk_map = [] \n        self.last_reload = 0\n        self.device = \"cpu\"\n        \n        # Check Dependencies\n        if not (faiss and SentenceTransformer and Observer):\n            logger.error(\"Search\", \"Missing dependencies (faiss/sentence_transformers/watchdog). Search disabled.\")\n            return\n\n        logger.log(\"INFO\", \"Search\", f\"Initializing Search Engine with {MODEL_NAME} (Watch={watch})...\")\n        \n        # Load Model\n        try:\n            self.model = SentenceTransformer(MODEL_NAME, device='cuda') # Try CUDA\n            self.device = \"cuda\"\n        except:\n            try:\n                self.model = SentenceTransformer(MODEL_NAME, device='cpu')\n                self.device = \"cpu\"\n            except:\n                return\n        \n        logger.log(\"INFO\", \"Search\", f\"Model loaded on {self.device.upper()}\")\n\n\n        # Load Index\n        self._load_index()", "start_line": 41, "end_line": 90}, {"path": "src/services/search_engine.py", "content": "                self.model = SentenceTransformer(MODEL_NAME, device='cpu')\n                self.device = \"cpu\"\n            except:\n                return\n        \n        logger.log(\"INFO\", \"Search\", f\"Model loaded on {self.device.upper()}\")\n\n\n        # Load Index\n        self._load_index()\n        \n        # Start Watcher if requested\n        if watch:\n            self.observer = Observer()\n            self.observer.schedule(self, str(self.root_dir), recursive=True)\n            self.observer.start()\n            \n            # Initial scan if empty\n            if self.index.ntotal == 0:\n                threading.Thread(target=self._full_scan, daemon=True).start()\n                \n        self.initialized = True\n\n    def _load_index(self):\n        if self.index_path.exists() and self.metadata_path.exists():\n            try:\n                # Check consistency\n                mtime = self.metadata_path.stat().st_mtime\n                if mtime <= self.last_reload: return\n                \n                self.index = faiss.read_index(str(self.index_path))\n                with open(self.metadata_path, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    self.chunk_map = data.get(\"chunks\", [])\n                \n                self.last_reload = mtime\n                logger.log(\"INFO\", \"Search\", f\"Loaded index ({self.index.ntotal} vectors).\")\n            except Exception as e:\n                logger.error(\"Search\", f\"Error loading index: {e}. Resetting.\")\n                self.index = faiss.IndexFlatL2(VECTOR_DIM)\n                self.chunk_map = []\n        else:\n            self.index = faiss.IndexFlatL2(VECTOR_DIM)\n            self.chunk_map = []\n\n    def _check_reload(self):\n        \"\"\"Reloads index if file changed on disk.\"\"\"\n        if self.metadata_path.exists():\n            mtime = self.metadata_path.stat().st_mtime\n            if mtime > self.last_reload:", "start_line": 81, "end_line": 130}, {"path": "src/services/search_engine.py", "content": "                self.chunk_map = []\n        else:\n            self.index = faiss.IndexFlatL2(VECTOR_DIM)\n            self.chunk_map = []\n\n    def _check_reload(self):\n        \"\"\"Reloads index if file changed on disk.\"\"\"\n        if self.metadata_path.exists():\n            mtime = self.metadata_path.stat().st_mtime\n            if mtime > self.last_reload:\n                 self._load_index()\n\n    # ... (rest of class) ...\n\n\n    def _save_index(self):\n        if not self.index: return\n        try:\n            faiss.write_index(self.index, str(self.index_path))\n            with open(self.metadata_path, 'w', encoding='utf-8') as f:\n                json.dump({\"chunks\": self.chunk_map}, f)\n        except Exception as e:\n            logger.error(\"Search\", f\"Error saving index: {e}\")\n\n    def _full_scan(self):\n        \"\"\"Scans all files and indexes them.\"\"\"\n        logger.log(\"INFO\", \"Search\", \"Starting full file scan...\")\n        all_files = []\n        for root, dirs, files in os.walk(self.root_dir):\n            # Skip hidden dirs and system dir\n            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['__pycache__', 'node_modules', 'venv', 'env']]\n            \n            # Explicit exclusion\n            if \".multi-agent-mcp\" in root:\n                continue\n            \n            for file in files:\n                if file.startswith('.'): continue\n                # Filter extensions\n                if not file.endswith(('.py', '.md', '.json', '.js', '.ts', '.html', '.css', '.txt', '.toml')):\n                    continue\n                    \n                full_path = Path(root) / file\n                try:\n                    rel_path = full_path.relative_to(self.root_dir)\n                    # Double check relative path does not start with excluded\n                    if str(rel_path).startswith(\".multi-agent-mcp\"): continue\n                    all_files.append(rel_path)\n                except: pass\n        ", "start_line": 121, "end_line": 170}, {"path": "src/services/search_engine.py", "content": "                    continue\n                    \n                full_path = Path(root) / file\n                try:\n                    rel_path = full_path.relative_to(self.root_dir)\n                    # Double check relative path does not start with excluded\n                    if str(rel_path).startswith(\".multi-agent-mcp\"): continue\n                    all_files.append(rel_path)\n                except: pass\n        \n        # Process files\n        new_chunks = []\n        new_vectors = []\n        \n        for p in all_files:\n            chunks, vectors = self._process_file(p)\n            if chunks:\n                new_chunks.extend(chunks)\n                new_vectors.append(vectors)\n        \n        if new_vectors:\n            flat_vectors = np.vstack(new_vectors)\n            self.index = faiss.IndexFlatL2(VECTOR_DIM) # Reset\n            self.index.add(flat_vectors)\n            self.chunk_map = new_chunks\n            self._save_index()\n            \n        logger.log(\"INFO\", \"Search\", f\"Scan complete. Indexed {len(self.chunk_map)} chunks.\")\n\n    def _process_file(self, rel_path: Path) -> Tuple[List[dict], Optional[np.ndarray]]:\n        \"\"\"Reads a file, chunks it, and returns metadata and vectors.\"\"\"\n        full_path = self.root_dir / rel_path\n        try:\n            with open(full_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n        except:\n            return [], None\n            \n        # Simple Chunking (Line based for code)\n        lines = content.splitlines()\n        chunks = []\n        chunk_texts = []\n        \n        # Configurable chunk size\n        CHUNK_SIZE = 50 \n        OVERLAP = 10\n        \n        for i in range(0, len(lines), CHUNK_SIZE - OVERLAP):\n            chunk_lines = lines[i:i+CHUNK_SIZE]\n            if not chunk_lines: break", "start_line": 161, "end_line": 210}, {"path": "src/services/search_engine.py", "content": "        chunks = []\n        chunk_texts = []\n        \n        # Configurable chunk size\n        CHUNK_SIZE = 50 \n        OVERLAP = 10\n        \n        for i in range(0, len(lines), CHUNK_SIZE - OVERLAP):\n            chunk_lines = lines[i:i+CHUNK_SIZE]\n            if not chunk_lines: break\n            \n            text_block = \"\\n\".join(chunk_lines)\n            if not text_block.strip(): continue\n            \n            # Metadata\n            chunks.append({\n                \"path\": str(rel_path),\n                \"content\": text_block,\n                \"start_line\": i + 1,\n                \"end_line\": i + len(chunk_lines)\n            })\n            \n            # Enrich text for embedding (include path)\n            chunk_texts.append(f\"File: {rel_path}\\nContent:\\n{text_block}\")\n            \n        if not chunk_texts:\n            return [], None\n            \n        embeddings = self.model.encode(chunk_texts)\n        return chunks, embeddings\n\n    # --- Watchdog Handling ---\n    def on_modified(self, event):\n        if event.is_directory: return\n        self._handle_change(event.src_path)\n        \n    def on_created(self, event):\n        if event.is_directory: return\n        self._handle_change(event.src_path)\n\n    def _handle_change(self, file_path):\n        try:\n            path = Path(file_path)\n            # Filter\n            if path.name.startswith('.') or not path.suffix in ['.py', '.md', '.json', '.js', '.ts', '.html', '.css', '.txt', '.toml']:\n                return\n            \n            rel_path = path.relative_to(self.root_dir)\n            \n            if str(rel_path).startswith(\".multi-agent-mcp\"): ", "start_line": 201, "end_line": 250}, {"path": "src/services/search_engine.py", "content": "    def _handle_change(self, file_path):\n        try:\n            path = Path(file_path)\n            # Filter\n            if path.name.startswith('.') or not path.suffix in ['.py', '.md', '.json', '.js', '.ts', '.html', '.css', '.txt', '.toml']:\n                return\n            \n            rel_path = path.relative_to(self.root_dir)\n            \n            if str(rel_path).startswith(\".multi-agent-mcp\"): \n                return\n            \n            logger.log(\"INFO\", \"Search\", f\"File changed: {rel_path}. Updating index...\")\n            chunks, vectors = self._process_file(rel_path)\n            if chunks and vectors is not None:\n                self.index.add(vectors)\n                self.chunk_map.extend(chunks) \n                self._save_index()\n                \n        except Exception as e:\n            logger.error(\"Search\", f\"Error handling file change: {e}\")\n\n    # --- Public API ---\n\n    def search(self, query: str, limit: int = 5, file_pattern: str = None) -> List[dict]:\n        self._check_reload()\n        \n        if not self.initialized or not self.index or self.index.ntotal == 0:\n            return []\n            \n        query_vector = self.model.encode([query])\n        D, I = self.index.search(query_vector, limit * 4) \n        \n        results = []\n        seen_content_hashes = set()\n        \n        for i, idx in enumerate(I[0]):\n            if idx == -1 or idx >= len(self.chunk_map): continue\n            \n            chunk = self.chunk_map[idx]\n            \n            # Filter Pattern\n            if file_pattern and not fnmatch.fnmatch(chunk['path'], file_pattern):\n                continue\n                \n            # Deduplication (exact content)\n            h = hash(chunk['content'])\n            if h in seen_content_hashes: continue\n            seen_content_hashes.add(h)\n            ", "start_line": 241, "end_line": 290}, {"path": "src/services/search_engine.py", "content": "            \n            # Filter Pattern\n            if file_pattern and not fnmatch.fnmatch(chunk['path'], file_pattern):\n                continue\n                \n            # Deduplication (exact content)\n            h = hash(chunk['content'])\n            if h in seen_content_hashes: continue\n            seen_content_hashes.add(h)\n            \n            # Score\n            score = float(D[0][i])\n            \n            results.append({\n                \"path\": chunk['path'],\n                \"start_line\": chunk['start_line'],\n                \"end_line\": chunk['end_line'],\n                \"content\": chunk['content'],\n                \"score\": score\n            })\n            \n            if len(results) >= limit:\n                break\n                \n        return results\n\n    def get_relevant_context(self, query: str, max_markdown: int = 2, max_total: int = 5) -> Tuple[str, List[dict]]:\n        \"\"\"\n        Returns a formatted string for markdown injection and the raw results list.\n        Sensitive to passive constraints: ONLY .md or .txt files.\n        \"\"\"\n        # We query more to filter\n        results = self.search(query, limit=max_total * 2) \n        if not results:\n            return \"\", []\n            \n        # Filter for Passive Context: Only .md and .txt\n        valid_results = []\n        for r in results:\n            if r['path'].endswith(('.md', '.txt')):\n                valid_results.append(r)\n                \n        markdown_results = valid_results[:max_markdown]\n        \n        md_output = []\n        for r in markdown_results:\n            ext = Path(r['path']).suffix.lstrip('.')\n            md_output.append(f\"**{r['path']}** (L{r['start_line']}-{r['end_line']})\\n```{ext}\\n{r['content']}\\n```\")\n            \n        return \"\\n\\n\".join(md_output), valid_results", "start_line": 281, "end_line": 330}, {"path": "src/services/search_engine.py", "content": "                valid_results.append(r)\n                \n        markdown_results = valid_results[:max_markdown]\n        \n        md_output = []\n        for r in markdown_results:\n            ext = Path(r['path']).suffix.lstrip('.')\n            md_output.append(f\"**{r['path']}** (L{r['start_line']}-{r['end_line']})\\n```{ext}\\n{r['content']}\\n```\")\n            \n        return \"\\n\\n\".join(md_output), valid_results\n", "start_line": 321, "end_line": 331}, {"path": "src/services/search_engine.py", "content": "\nimport os\nimport time\nimport threading\nimport json\nimport logging\nimport fnmatch\nfrom pathlib import Path\nfrom typing import List, Dict, Optional, Tuple\n\nimport numpy as np\n\n# Conditional imports to avoid crashing if dependencies are missing during dev\ntry:\n    import faiss\n    from sentence_transformers import SentenceTransformer\n    from watchdog.observers import Observer\n    from watchdog.events import FileSystemEventHandler\nexcept ImportError:\n    faiss = None\n    SentenceTransformer = None\n    Observer = None\n    FileSystemEventHandler = object\n\nfrom src.utils.logger import get_logger\n\nlogger = get_logger()\n\n# --- CONSTANTS ---\nMODEL_NAME = 'all-MiniLM-L6-v2'\nVECTOR_DIM = 384  # Dimension for MiniLM-L6-v2\nINDEX_FILE = \"search_index.faiss\"\nMETADATA_FILE = \"search_metadata.json\"\n\nclass SearchEngine(FileSystemEventHandler):\n    _instance = None\n    _lock = threading.Lock()\n\n    def __new__(cls):\n        if cls._instance is None:\n            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super(SearchEngine, cls).__new__(cls)\n                    cls._instance.initialized = False\n        return cls._instance\n\n    def initialize(self, root_dir: Path, persist_dir: Path, watch: bool = True):\n        \"\"\"\n        Initialize the search engine.\n        \"\"\"", "start_line": 1, "end_line": 50}, {"path": "src/services/search_engine.py", "content": "            with cls._lock:\n                if cls._instance is None:\n                    cls._instance = super(SearchEngine, cls).__new__(cls)\n                    cls._instance.initialized = False\n        return cls._instance\n\n    def initialize(self, root_dir: Path, persist_dir: Path, watch: bool = True):\n        \"\"\"\n        Initialize the search engine.\n        \"\"\"\n        if self.initialized:\n            return\n\n        self.root_dir = root_dir\n        self.persist_dir = persist_dir\n        self.persist_dir.mkdir(parents=True, exist_ok=True)\n        \n        self.index_path = self.persist_dir / INDEX_FILE\n        self.metadata_path = self.persist_dir / METADATA_FILE\n        \n        self.model = None\n        self.index = None\n        self.file_paths = [] \n        self.chunk_map = [] \n        self.last_reload = 0\n        self.device = \"cpu\"\n        \n        # Check Dependencies\n        if not (faiss and SentenceTransformer and Observer):\n            logger.error(\"Search\", \"Missing dependencies (faiss/sentence_transformers/watchdog). Search disabled.\")\n            return\n\n        logger.log(\"INFO\", \"Search\", f\"Initializing Search Engine with {MODEL_NAME} (Watch={watch})...\")\n        \n        # Load Model\n        try:\n            self.model = SentenceTransformer(MODEL_NAME, device='cuda') # Try CUDA\n            self.device = \"cuda\"\n        except:\n            try:\n                self.model = SentenceTransformer(MODEL_NAME, device='cpu')\n                self.device = \"cpu\"\n            except:\n                return\n        \n        logger.log(\"INFO\", \"Search\", f\"Model loaded on {self.device.upper()}\")\n\n\n        # Load Index\n        self._load_index()", "start_line": 41, "end_line": 90}, {"path": "src/services/search_engine.py", "content": "                self.model = SentenceTransformer(MODEL_NAME, device='cpu')\n                self.device = \"cpu\"\n            except:\n                return\n        \n        logger.log(\"INFO\", \"Search\", f\"Model loaded on {self.device.upper()}\")\n\n\n        # Load Index\n        self._load_index()\n        \n        # Start Watcher if requested\n        if watch:\n            self.observer = Observer()\n            self.observer.schedule(self, str(self.root_dir), recursive=True)\n            self.observer.start()\n            \n            # Initial scan if empty\n            if self.index.ntotal == 0:\n                threading.Thread(target=self._full_scan, daemon=True).start()\n                \n        self.initialized = True\n\n    def _load_index(self):\n        if self.index_path.exists() and self.metadata_path.exists():\n            try:\n                # Check consistency\n                mtime = self.metadata_path.stat().st_mtime\n                if mtime <= self.last_reload: return\n                \n                self.index = faiss.read_index(str(self.index_path))\n                with open(self.metadata_path, 'r', encoding='utf-8') as f:\n                    data = json.load(f)\n                    self.chunk_map = data.get(\"chunks\", [])\n                \n                self.last_reload = mtime\n                logger.log(\"INFO\", \"Search\", f\"Loaded index ({self.index.ntotal} vectors).\")\n            except Exception as e:\n                logger.error(\"Search\", f\"Error loading index: {e}. Resetting.\")\n                self.index = faiss.IndexFlatL2(VECTOR_DIM)\n                self.chunk_map = []\n        else:\n            self.index = faiss.IndexFlatL2(VECTOR_DIM)\n            self.chunk_map = []\n\n    def _check_reload(self):\n        \"\"\"Reloads index if file changed on disk.\"\"\"\n        if self.metadata_path.exists():\n            mtime = self.metadata_path.stat().st_mtime\n            if mtime > self.last_reload:", "start_line": 81, "end_line": 130}, {"path": "src/services/search_engine.py", "content": "                self.chunk_map = []\n        else:\n            self.index = faiss.IndexFlatL2(VECTOR_DIM)\n            self.chunk_map = []\n\n    def _check_reload(self):\n        \"\"\"Reloads index if file changed on disk.\"\"\"\n        if self.metadata_path.exists():\n            mtime = self.metadata_path.stat().st_mtime\n            if mtime > self.last_reload:\n                 self._load_index()\n\n    # ... (rest of class) ...\n\n\n    def _save_index(self):\n        if not self.index: return\n        try:\n            faiss.write_index(self.index, str(self.index_path))\n            with open(self.metadata_path, 'w', encoding='utf-8') as f:\n                json.dump({\"chunks\": self.chunk_map}, f)\n        except Exception as e:\n            logger.error(\"Search\", f\"Error saving index: {e}\")\n\n    def _full_scan(self):\n        \"\"\"Scans all files and indexes them.\"\"\"\n        logger.log(\"INFO\", \"Search\", \"Starting full file scan...\")\n        all_files = []\n        for root, dirs, files in os.walk(self.root_dir):\n            # Skip hidden dirs and system dir\n            dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ['__pycache__', 'node_modules', 'venv', 'env']]\n            \n            # Explicit exclusion\n            if \".multi-agent-mcp\" in root:\n                continue\n            \n            for file in files:\n                if file.startswith('.'): continue\n                # Filter extensions\n                if not file.endswith(('.py', '.md', '.json', '.js', '.ts', '.html', '.css', '.txt', '.toml')):\n                    continue\n                    \n                full_path = Path(root) / file\n                try:\n                    rel_path = full_path.relative_to(self.root_dir)\n                    # Double check relative path does not start with excluded\n                    if str(rel_path).startswith(\".multi-agent-mcp\"): continue\n                    all_files.append(rel_path)\n                except: pass\n        ", "start_line": 121, "end_line": 170}, {"path": "src/services/search_engine.py", "content": "                    continue\n                    \n                full_path = Path(root) / file\n                try:\n                    rel_path = full_path.relative_to(self.root_dir)\n                    # Double check relative path does not start with excluded\n                    if str(rel_path).startswith(\".multi-agent-mcp\"): continue\n                    all_files.append(rel_path)\n                except: pass\n        \n        # Process files\n        new_chunks = []\n        new_vectors = []\n        \n        for p in all_files:\n            chunks, vectors = self._process_file(p)\n            if chunks:\n                new_chunks.extend(chunks)\n                new_vectors.append(vectors)\n        \n        if new_vectors:\n            flat_vectors = np.vstack(new_vectors)\n            self.index = faiss.IndexFlatL2(VECTOR_DIM) # Reset\n            self.index.add(flat_vectors)\n            self.chunk_map = new_chunks\n            self._save_index()\n            \n        logger.log(\"INFO\", \"Search\", f\"Scan complete. Indexed {len(self.chunk_map)} chunks.\")\n\n    def _process_file(self, rel_path: Path) -> Tuple[List[dict], Optional[np.ndarray]]:\n        \"\"\"Reads a file, chunks it, and returns metadata and vectors.\"\"\"\n        full_path = self.root_dir / rel_path\n        try:\n            with open(full_path, 'r', encoding='utf-8') as f:\n                content = f.read()\n        except:\n            return [], None\n            \n        # Simple Chunking (Line based for code)\n        lines = content.splitlines()\n        chunks = []\n        chunk_texts = []\n        \n        # Configurable chunk size\n        CHUNK_SIZE = 50 \n        OVERLAP = 10\n        \n        for i in range(0, len(lines), CHUNK_SIZE - OVERLAP):\n            chunk_lines = lines[i:i+CHUNK_SIZE]\n            if not chunk_lines: break", "start_line": 161, "end_line": 210}, {"path": "src/services/search_engine.py", "content": "        chunks = []\n        chunk_texts = []\n        \n        # Configurable chunk size\n        CHUNK_SIZE = 50 \n        OVERLAP = 10\n        \n        for i in range(0, len(lines), CHUNK_SIZE - OVERLAP):\n            chunk_lines = lines[i:i+CHUNK_SIZE]\n            if not chunk_lines: break\n            \n            text_block = \"\\n\".join(chunk_lines)\n            if not text_block.strip(): continue\n            \n            # Metadata\n            chunks.append({\n                \"path\": str(rel_path),\n                \"content\": text_block,\n                \"start_line\": i + 1,\n                \"end_line\": i + len(chunk_lines)\n            })\n            \n            # Enrich text for embedding (include path)\n            chunk_texts.append(f\"File: {rel_path}\\nContent:\\n{text_block}\")\n            \n        if not chunk_texts:\n            return [], None\n            \n        embeddings = self.model.encode(chunk_texts)\n        return chunks, embeddings\n\n    # --- Watchdog Handling ---\n    def on_modified(self, event):\n        if event.is_directory: return\n        self._handle_change(event.src_path)\n        \n    def on_created(self, event):\n        if event.is_directory: return\n        self._handle_change(event.src_path)\n\n    def _handle_change(self, file_path):\n        try:\n            path = Path(file_path)\n            # Filter\n            if path.name.startswith('.') or not path.suffix in ['.py', '.md', '.json', '.js', '.ts', '.html', '.css', '.txt', '.toml']:\n                return\n            \n            rel_path = path.relative_to(self.root_dir)\n            \n            if str(rel_path).startswith(\".multi-agent-mcp\"): ", "start_line": 201, "end_line": 250}, {"path": "src/services/search_engine.py", "content": "    def _handle_change(self, file_path):\n        try:\n            path = Path(file_path)\n            # Filter\n            if path.name.startswith('.') or not path.suffix in ['.py', '.md', '.json', '.js', '.ts', '.html', '.css', '.txt', '.toml']:\n                return\n            \n            rel_path = path.relative_to(self.root_dir)\n            \n            if str(rel_path).startswith(\".multi-agent-mcp\"): \n                return\n            \n            logger.log(\"INFO\", \"Search\", f\"File changed: {rel_path}. Updating index...\")\n            chunks, vectors = self._process_file(rel_path)\n            if chunks and vectors is not None:\n                self.index.add(vectors)\n                self.chunk_map.extend(chunks) \n                self._save_index()\n                \n        except Exception as e:\n            logger.error(\"Search\", f\"Error handling file change: {e}\")\n\n    # --- Public API ---\n\n    def search(self, query: str, limit: int = 5, file_pattern: str = None) -> List[dict]:\n        self._check_reload()\n        \n        if not self.initialized or not self.index or self.index.ntotal == 0:\n            return []\n            \n        query_vector = self.model.encode([query])\n        D, I = self.index.search(query_vector, limit * 4) \n        \n        results = []\n        seen_content_hashes = set()\n        \n        for i, idx in enumerate(I[0]):\n            if idx == -1 or idx >= len(self.chunk_map): continue\n            \n            chunk = self.chunk_map[idx]\n            \n            # Filter Pattern\n            if file_pattern and not fnmatch.fnmatch(chunk['path'], file_pattern):\n                continue\n                \n            # Deduplication (exact content)\n            h = hash(chunk['content'])\n            if h in seen_content_hashes: continue\n            seen_content_hashes.add(h)\n            ", "start_line": 241, "end_line": 290}, {"path": "src/services/search_engine.py", "content": "            \n            # Filter Pattern\n            if file_pattern and not fnmatch.fnmatch(chunk['path'], file_pattern):\n                continue\n                \n            # Deduplication (exact content)\n            h = hash(chunk['content'])\n            if h in seen_content_hashes: continue\n            seen_content_hashes.add(h)\n            \n            # Score\n            score = float(D[0][i])\n            \n            results.append({\n                \"path\": chunk['path'],\n                \"start_line\": chunk['start_line'],\n                \"end_line\": chunk['end_line'],\n                \"content\": chunk['content'],\n                \"score\": score\n            })\n            \n            if len(results) >= limit:\n                break\n                \n        return results\n\n    def get_relevant_context(self, query: str, max_markdown: int = 2, max_total: int = 5) -> Tuple[str, List[dict]]:\n        \"\"\"\n        Returns a formatted string for markdown injection and the raw results list.\n        Sensitive to passive constraints: ONLY .md or .txt files.\n        \"\"\"\n        # We query more to filter\n        results = self.search(query, limit=max_total * 2) \n        if not results:\n            return \"\", []\n            \n        # Filter for Passive Context: Only .md and .txt\n        valid_results = []\n        for r in results:\n            if r['path'].endswith(('.md', '.txt')):\n                valid_results.append(r)\n                \n        markdown_results = valid_results[:max_markdown]\n        \n        md_output = []\n        for r in markdown_results:\n            ext = Path(r['path']).suffix.lstrip('.')\n            md_output.append(f\"**{r['path']}** (L{r['start_line']}-{r['end_line']})\\n```{ext}\\n{r['content']}\\n```\")\n            \n        return \"\\n\\n\".join(md_output), valid_results", "start_line": 281, "end_line": 330}, {"path": "src/services/search_engine.py", "content": "                valid_results.append(r)\n                \n        markdown_results = valid_results[:max_markdown]\n        \n        md_output = []\n        for r in markdown_results:\n            ext = Path(r['path']).suffix.lstrip('.')\n            md_output.append(f\"**{r['path']}** (L{r['start_line']}-{r['end_line']})\\n```{ext}\\n{r['content']}\\n```\")\n            \n        return \"\\n\\n\".join(md_output), valid_results\n", "start_line": 321, "end_line": 331}, {"path": "src/interface/app.py", "content": "import streamlit as st\nimport streamlit.components.v1 as components\nfrom streamlit_autorefresh import st_autorefresh\nimport graphviz\nimport json\nimport uuid\nimport sys\nimport os\nimport time\nimport re\nimport shutil\nfrom pathlib import Path\n\n# Add src to path to allow imports if run directly\nfrom pathlib import Path\nimport sys\nimport os\n\nCODE_ROOT = Path(__file__).resolve().parent.parent.parent\nif str(CODE_ROOT) not in sys.path:\n    sys.path.append(str(CODE_ROOT))\n\nfrom src.config import (\n    STATE_FILE, \n    MEMORY_DIR, \n    TEMPLATE_DIR, \n    LOCAL_DATA_DIR, \n    GLOBAL_PRESET_DIR, \n    ASSETS_DIR,\n    CODE_ROOT as CONFIG_CODE_ROOT,\n    RELOAD_INSTRUCTION\n)\nfrom src.core.state import StateStore\nfrom src.services.search_engine import SearchEngine\n\nst.set_page_config(page_title=\"Agent Orchestra\", page_icon=\"\ud83e\udd16\", layout=\"wide\")\n\n# --- EMOJI LIST ---\nEMOJI_LIST = [\n    \"\ud83e\udd16\", \"\ud83e\udde0\", \"\ud83d\udd75\ufe0f\", \"\ud83e\uddb8\", \"\ud83e\udd77\", \"\ud83e\uddd9\", \"\ud83e\udddb\", \"\ud83e\udddf\", \"\ud83e\uddde\", \"\ud83e\udddd\",\n    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",", "start_line": 1, "end_line": 50}, {"path": "src/interface/app.py", "content": "    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",\n    \"\ud83e\udda1\", \"\ud83e\udda6\", \"\ud83e\udda5\", \"\ud83d\udc01\", \"\ud83d\udc00\", \"\ud83d\udc3f\ufe0f\", \"\ud83e\udd94\", \"\ud83d\udc3e\", \"\ud83d\udc09\", \"\ud83d\udc32\",\n    \"\ud83c\udf35\", \"\ud83c\udf84\", \"\ud83c\udf32\", \"\ud83c\udf33\", \"\ud83c\udf34\", \"\ud83c\udf31\", \"\ud83c\udf3f\", \"\u2618\ufe0f\", \"\ud83c\udf40\", \"\ud83c\udf43\"\n]\n\ndef get_random_emoji():\n    import random\n    return random.choice(EMOJI_LIST)\n\n# --- HELPER FUNCTIONS ---\ndef inject_custom_css():\n    st.markdown(\"\"\"<style>\n    /* Global message container */\n    [data-testid=\"stChatMessage\"] {\n        padding: 1rem !important;\n        margin-bottom: 1.5rem !important;\n    }\n    \n    [data-testid=\"stChatMessage\"] [data-testid=\"stVerticalBlock\"] {\n        gap: 12px !important;\n    }\n\n    /* Header layout inside message */\n    .message-header {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        margin-bottom: 8px;\n        opacity: 0.85;\n    }\n\n    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    ", "start_line": 41, "end_line": 90}, {"path": "src/interface/app.py", "content": "    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    \n    .reply-banner-custom {\n        background: #f0f7ff;\n        border: 1px solid #d0e7ff;\n        border-radius: 10px;\n        padding: 8px 15px;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        margin-bottom: 8px;\n        font-size: 0.85em;\n        box-shadow: 0 2px 8px rgba(0,0,0,0.05);\n    }\n\n    /* Premium Toggle Styling (Targeting the specific widget) */\n    div[data-testid=\"stToggle\"] {\n        background: #ffffff;\n        padding: 10px 24px !important;\n        border-radius: 50px !important;\n        border: 1px solid #ff4b4b22 !important;\n        box-shadow: 0 4px 15px rgba(0,0,0,0.06) !important;\n        transition: all 0.3s ease !important;\n        width: fit-content !important;\n        margin: 10px auto !important;\n    }\n    \n    div[data-testid=\"stToggle\"]:hover {\n        border-color: #ff4b4b !important;\n        box-shadow: 0 6px 20px rgba(255,75,75,0.12) !important;\n        transform: translateY(-1px);\n    }\n\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;", "start_line": 81, "end_line": 130}, {"path": "src/interface/app.py", "content": "\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;\n        gap: 12px !important;\n        margin: 0 !important;\n    }\n\n    div[data-testid=\"stToggle\"] label p {\n        font-weight: 700 !important;\n        font-size: 0.95em !important;\n        color: #1a1a1a !important;\n        margin: 0 !important;\n        letter-spacing: -0.2px !important;\n    }\n    \n    .target-badge {\n        font-weight: 600;\n        padding: 1px 6px;\n        border-radius: 4px;\n        font-size: 0.75em;\n        color: #444;\n        background: rgba(0,0,0,0.08);\n        border: 1px solid rgba(0,0,0,0.1);\n    }\n    \n    .status-tag {\n        font-size: 0.7em;\n        font-weight: 700;\n        padding: 1px 5px;\n        border-radius: 4px;\n        text-transform: uppercase;\n        letter-spacing: 0.5px;\n    }\n    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;", "start_line": 121, "end_line": 170}, {"path": "src/interface/app.py", "content": "    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        padding: 6px 16px;\n        color: #666;\n        font-size: 0.85em;\n        font-style: italic;\n        background: rgba(0,0,0,0.03);\n        border-radius: 20px;\n        margin: 10px auto;\n        width: fit-content;\n        border: 1px solid rgba(0,0,0,0.05);\n        box-shadow: 0 2px 4px rgba(0,0,0,0.02);\n    }\n    .typing-dots {\n        display: flex; gap: 4px; margin-left: 8px;\n    }\n    .typing-dot {\n        width: 5px; height: 5px; background: #999; border-radius: 50%;\n        animation: typing-bounce 1.4s infinite ease-in-out;\n    }\n    .typing-dot:nth-child(1) { animation-delay: -0.32s; }\n    .typing-dot:nth-child(2) { animation-delay: -0.16s; }\n    @keyframes typing-bounce {\n        0%, 80%, 100% { transform: translateY(0); opacity: 0.3; }\n        40% { transform: translateY(-3px); opacity: 1; }\n    }\n    </style>\"\"\", unsafe_allow_html=True)\n\ninject_custom_css()\n\n# --- INITIALIZE STATE (ONCE) ---\nstate_store = StateStore()\n\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n", "start_line": 161, "end_line": 210}, {"path": "src/interface/app.py", "content": "\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n\ndef save_config(new_config):\n    def update_fn(s):\n        s[\"config\"] = new_config\n        return \"Config Saved\"\n    state_store.update(update_fn)\n\n\n# --- SEARCH ENGINE INIT ---\n@st.cache_resource\ndef init_search_engine():\n    engine = SearchEngine()\n    # Ensure directory exists for persist\n    persist = LOCAL_DATA_DIR / \"vector_store\"\n    persist.mkdir(parents=True, exist_ok=True)\n    engine.initialize(root_dir=CODE_ROOT, persist_dir=persist)\n    return engine\n\n# Initialize background service\nsearch_engine = init_search_engine()\n\n\n# --- DIALOGS ---\ndef handle_disconnect_agent(agent_name):\n    \"\"\"\n    Sets the reload_active flag for the agent.\n    Does NOT set 'pending_connection' immediately (Agent must do it via disconnect tool).\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = True\n            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }", "start_line": 201, "end_line": 250}, {"path": "src/interface/app.py", "content": "            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }\n            s.setdefault(\"messages\", []).append(msg)\n            \n        return f\"Signal de rechargement envoy\u00e9 \u00e0 : {agent_name}\"\n    \n    state_store.update(update_fn)\n    st.toast(f\"Reload signal sent to {agent_name} \ud83d\udd01\")\n\ndef force_disconnect_agent(agent_name):\n    \"\"\"\n    Forces status to pending_connection immediately.\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = False # Reset flag\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n        return f\"Force disconnect: {agent_name}\"\n    state_store.update(update_fn)\n    st.toast(f\"\u2620\ufe0f Force Disconnect: {agent_name}\")\n\nPRESET_DIR = GLOBAL_PRESET_DIR\n\n@st.dialog(\"Sauvegarder le Sc\u00e9nario\")\ndef save_scenario_dialog(current_config):\n    save_name = st.text_input(\"Nom de Sauvegarde\", placeholder=\"mon_scenario\")\n    if st.button(\"Confirmer la Sauvegarde\", use_container_width=True):\n        if save_name:\n            # Basic filename cleaning\n            filename = \"\".join([c for c in save_name if c.isalnum() or c in (' ', '.', '_', '-')]).rstrip()\n            path = PRESET_DIR / f\"{filename}.json\"\n            with open(path, \"w\") as f:\n                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")", "start_line": 241, "end_line": 290}, {"path": "src/interface/app.py", "content": "                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")\n                except Exception as e:\n                    # Non-blocking, just dev convenience\n                    print(f\"Failed to sync to repo: {e}\")\n            st.success(f\"Sauvegard\u00e9 : {filename}\")\n            time.sleep(1)\n            st.rerun()\n        else:\n            st.error(\"Veuillez entrer un nom.\")\n\n@st.dialog(\"Charger un Sc\u00e9nario\")\ndef load_scenario_dialog():\n    # Unified Source: User Global Presets\n    # (Defaults have been synced here by sync_presets)\n    presets = sorted([f for f in os.listdir(PRESET_DIR) if f.endswith(\".json\")])\n    \n    if not presets:\n        st.warning(\"Aucun sc\u00e9nario trouv\u00e9.\")\n        return\n\n    options = [f\"\ud83d\udcbe {f}\" for f in presets]\n    path_map = {f\"\ud83d\udcbe {f}\": PRESET_DIR / f for f in presets}\n        \n    selected_label = st.selectbox(\"Choisir un Preset\", options)\n    \n    c_load, c_del = st.columns([0.85, 0.15])\n    \n    with c_load:\n        if st.button(\"Charger la Configuration\", use_container_width=True, type=\"primary\"):\n            if selected_label:\n                path = path_map[selected_label]\n                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)", "start_line": 281, "end_line": 330}, {"path": "src/interface/app.py", "content": "                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)\n                st.rerun()\n                \n    with c_del:\n        if st.button(\"\ud83d\uddd1\ufe0f\", key=\"del_scen_btn\", help=\"Supprimer d\u00e9finivement\", use_container_width=True):\n             if selected_label:\n                 path = path_map[selected_label]\n                 try:\n                     os.remove(path)\n                     st.toast(f\"Sc\u00e9nario supprim\u00e9: {selected_label}\")\n                     time.sleep(0.7)\n                     st.rerun()\n                 except Exception as e:\n                     st.error(f\"Erreur: {e}\")\n\ndef get_total_agents(profiles):\n    total = 0\n    for p in profiles:\n        try:\n            total += int(p.get(\"count\", 0))\n        except:\n            pass\n    return total\n\ndef format_mentions(text):\n    if not text: return text\n    \n    # 1. First decorate @everyone\n    text = re.sub(\n        r'(@everyone)',\n        r'<span style=\"color: #ffffff; background-color: #ff4b4b; padding: 2px 8px; border-radius: 6px; font-weight: 700; font-size: 0.9em; box-shadow: 0 2px 4px rgba(255,75,75,0.3);\">\\1</span>',\n        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )", "start_line": 321, "end_line": 370}, {"path": "src/interface/app.py", "content": "        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )\n\ndef render_graph(profiles, current_editing=None):\n    graph = graphviz.Digraph()\n    graph.attr(rankdir='LR', size='12,2', ratio='fill', bgcolor='transparent', margin='0')\n    \n    # Add User node\n    graph.node(\"User\", label=\"\ud83d\udc64 User\", style='filled', fillcolor='lightgrey', shape='circle', fontsize='10', height='0.5')\n    \n    for p in profiles:\n        name = p[\"name\"]\n        color = 'lightblue'\n        if current_editing and name == current_editing:\n            color = 'gold'\n        count = p.get(\"count\", 0)\n        label = f\"{name}\\n(x{count})\"\n        graph.node(name, label=label, style='filled', fillcolor=color, shape='box', fontsize='10', height='0.5')\n\n    for p in profiles:\n        source = p[\"name\"]\n        for conn in p.get(\"connections\", []):\n            target = conn.get(\"target\")\n            is_auth = conn.get(\"authorized\", True)\n            if is_auth and (target == \"User\" or any(prof[\"name\"] == target for prof in profiles)):\n                graph.edge(source, target, fontsize='8', color='gray', arrowsize='0.5')\n    return graph\n\ndef inject_mention_system(agent_names):\n    import json\n    agents_json = json.dumps(agent_names)\n    \n    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;", "start_line": 361, "end_line": 410}, {"path": "src/interface/app.py", "content": "    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;\n            const textarea = doc.querySelector('textarea[data-testid=\"stChatInputTextArea\"]');\n            \n            if (!textarea) {{\n                // Polled by setInterval, so just return\n                return;\n            }}\n\n            // Cleanup previous interaction from this or previous iframes\n            // We use a custom property on the DOM node to store the controller\n            if (textarea._mentionController) {{\n                // If the controller belongs to a DEAD iframe, this might fail or succeed. \n                // But mostly it allows us to signal \"Stop Listing\".\n                try {{\n                    textarea._mentionController.abort();\n                }} catch(e) {{}}\n            }}\n\n            // Create new controller for this instance\n            const controller = new AbortController();\n            textarea._mentionController = controller;\n            const signal = controller.signal;\n\n            let menu = doc.getElementById('mention-menu');\n            if (!menu) {{\n                menu = doc.createElement('div');\n                menu.id = 'mention-menu';\n                Object.assign(menu.style, {{\n                    display: 'none',\n                    position: 'fixed',\n                    background: 'white',\n                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);", "start_line": 401, "end_line": 450}, {"path": "src/interface/app.py", "content": "                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);\n            }}\n\n            // Inject styles\n            if (!doc.getElementById('mention-styles')) {{\n                const style = doc.createElement('style');\n                style.id = 'mention-styles';\n                style.innerHTML = `\n                    .mention-item:hover {{\n                        background-color: #f0f2f6 !important;\n                    }}\n                `;\n                doc.head.appendChild(style);\n            }}\n\n            textarea.addEventListener('input', (e) => {{\n                if (e.isComposing) return;\n                const value = textarea.value;\n                const cursorPos = textarea.selectionStart;\n                const textBeforeCursor = value.substring(0, cursorPos);\n                const mentionMatch = textBeforeCursor.match(/@([\\\\w\\\\s#]*)$/);\n\n                if (mentionMatch) {{\n                    isVisible = true;\n                    currentFilter = mentionMatch[1].toLowerCase();\n                    renderMenu(textarea);\n                }} else {{\n                    hideMenu();\n                }}\n            }}, {{ signal }});\n\n            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;", "start_line": 441, "end_line": 490}, {"path": "src/interface/app.py", "content": "            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'ArrowUp') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex - 1 + filtered.length) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'Enter' || e.key === 'Tab') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    insertMention(textarea, filtered[selectedIndex]);\n                }} else if (e.key === 'Escape') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    hideMenu();\n                }}\n            }}, {{ capture: true, signal: signal }});\n        }}\n\n        function renderMenu(textarea) {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n            \n            if (filtered.length === 0) {{\n                hideMenu();\n                return;\n            }}\n\n            menu.innerHTML = filtered.map((a, i) => `\n                <div class=\"mention-item\" style=\"\n                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">", "start_line": 481, "end_line": 530}, {"path": "src/interface/app.py", "content": "                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">\n                    <span style=\"font-weight: ${{i === selectedIndex ? '600' : '400'}};\">@${{a}}</span>\n                    ${{a === 'everyone' ? '<span style=\"font-size: 10px; background: #ff4b4b; color: white; padding: 1px 4px; border-radius: 4px; margin-left: 5px;\">PUBLIC</span>' : ''}}\n                </div>\n            `).join('');\n\n            const rect = textarea.getBoundingClientRect();\n            menu.style.display = 'block';\n            menu.style.left = rect.left + 'px';\n            \n            // Position above the textarea\n            menu.style.bottom = (window.parent.innerHeight - rect.top + 10) + 'px';\n            isVisible = true;\n        }}\n\n        function insertMention(textarea, name) {{\n            const value = textarea.value;\n            const cursorPos = textarea.selectionStart;\n            const textBeforeCursor = value.substring(0, cursorPos);\n            const textAfterCursor = value.substring(cursorPos);\n            \n            const newTextBefore = textBeforeCursor.replace(/@([\\\\w\\\\s#]*)$/, '@' + name + ' ');\n            const newValue = newTextBefore + textAfterCursor;\n\n            // Robust React state update\n            const nativeTextareaValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, \"value\").set;\n            nativeTextareaValueSetter.call(textarea, newValue);\n            \n            // Trigger events\n            textarea.dispatchEvent(new Event('input', {{ bubbles: true }}));\n            textarea.dispatchEvent(new Event('change', {{ bubbles: true }}));\n\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{", "start_line": 521, "end_line": 570}, {"path": "src/interface/app.py", "content": "\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            if (menu) menu.style.display = 'none';\n            isVisible = false;\n            selectedIndex = 0;\n        }}\n\n        // Initial setup & Polling for re-mounts\n        setInterval(setupMentions, 1000);\n    }})();\n    </script>\n    \"\"\"\n    components.html(components_code, height=0)\n\n# --- MAIN LOGIC ---\n\n# 1. Load Data\nstate, config = load_config()\ndata = state\nprofiles = config.get(\"profiles\", [])\nagents = data.get(\"agents\", {})\nturn = data.get(\"turn\", {})\nmessages = data.get(\"messages\", [])\n\n# --- CSS STYLING ---\nst.markdown(\"\"\"\n<style>\n    div[data-testid=\"stSidebar\"] {\n        background-color: #f0f2f6;\n    }\n    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;", "start_line": 561, "end_line": 610}, {"path": "src/interface/app.py", "content": "    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;\n    }\n    /* Agent Card Styling */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] {\n        background-color: white;\n        border-radius: 16px !important;\n        border: 1px solid #f0f0f0 !important;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.04);\n        padding: 0.5rem;\n        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    }\n    [data-testid=\"stVerticalBlockBorderWrapper\"]:hover {\n        transform: translateY(-4px);\n        box-shadow: 0 12px 24px rgba(0,0,0,0.08);\n        border-color: #ff4b4b44 !important;\n    }\n    .agent-header {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 12px;\n    }\n    .agent-icon {\n        font-size: 1.5em;\n        background: #f8f9fa;\n        width: 42px;\n        height: 42px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 10px;\n        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;", "start_line": 601, "end_line": 650}, {"path": "src/interface/app.py", "content": "        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;\n        color: #64748b;\n        margin-bottom: 1rem;\n        min-height: 4.2em;\n        line-height: 1.5;\n    }\n    .count-display {\n        background: #f1f5f9;\n        color: #0f172a;\n        height: 2.4em;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 8px;\n        font-weight: 700;\n        font-size: 1.1em;\n    }\n    /* Compact buttons in cards */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] .stButton button {\n        height: 2.4em !important;\n    }\n    .reset-button-container {\n        display: flex;\n        justify-content: center;\n        padding: 20px;\n    }\n    @keyframes pulse-gold {\n        0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }\n        70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }\n        100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }\n    }\n    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:", "start_line": 641, "end_line": 690}, {"path": "src/interface/app.py", "content": "    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:\n    st.session_state.page = \"Communication\"\n\n# --- SIDEBAR ---\nwith st.sidebar:\n    st.title(\"\ud83e\udd16 Orchestra\")\n    \n    # Global Autorefresh (Active on all pages to catch messages)\n    st_autorefresh(interval=4000, key=\"global_pulse\")\n\n    st.markdown(\"### Navigation\")\n    \n    # --- NOTIFICATION LOGIC ---\n    total_msgs = len(messages)\n    if \"last_read_count\" not in st.session_state:\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    unread = 0\n    if st.session_state.page != \"Communication\":\n        unread = max(0, total_msgs - st.session_state.last_read_count)\n        \n        # Toast for new messages\n        if \"last_toast_count\" not in st.session_state:\n             st.session_state.last_toast_count = total_msgs\n             \n        if total_msgs > st.session_state.last_toast_count:\n             new_count = total_msgs - st.session_state.last_toast_count\n             # Toast the last one\n             newest = messages[-1]\n             sender = newest.get(\"from\", \"?\")\n             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"", "start_line": 681, "end_line": 730}, {"path": "src/interface/app.py", "content": "             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"\n    if unread > 0:\n        label_comm = f\"\ud83d\udcac Chat ({unread} \ud83d\udd34)\"\n\n    if st.button(label_comm, use_container_width=True, type=\"primary\" if st.session_state.page == \"Communication\" else \"secondary\"):\n        st.session_state.page = \"Communication\"\n        st.rerun()\n        \n    if st.button(\"\ud83c\udf9b\ufe0f Cockpit\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Cockpit\" else \"secondary\"):\n        st.session_state.page = \"Cockpit\"\n        st.rerun()\n        \n    if st.button(\"\ud83d\udee0\ufe0f \u00c9diteur\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Editor\" else \"secondary\"):\n        st.session_state.page = \"Editor\"\n        st.rerun()\n\n    st.divider()\n    \n    # 1. Identity / User Status\n    st.markdown(\"### \ud83d\udc64 Identity\")\n    user_status = config.get(\"user_availability\", \"busy\")\n    \n    # User status toggle\n    is_available = st.toggle(\"Available\", value=(user_status == \"available\"), help=\"Switch between Available (\ud83d\udfe2) and Busy (\ud83d\udd34)\")\n    new_status = \"available\" if is_available else \"busy\"\n    \n    if new_status != user_status:\n        config[\"user_availability\"] = new_status\n        save_config(config)\n        st.rerun()\n\n    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:", "start_line": 721, "end_line": 770}, {"path": "src/interface/app.py", "content": "    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:\n        config[\"language\"] = new_lang\n        save_config(config)\n        st.rerun()\n\n\n\n    st.divider()\n    \n    # Search Config\n    st.markdown(\"### \ud83d\udd0e Search Engine\")\n    \n    # Status Indicator\n    if search_engine and search_engine.initialized:\n        dev_label = search_engine.device.upper().replace(\"\u201d\", \"\") # Fix typo if any from previous edit\n        st.caption(f\"Status: **Active** | Device: **{dev_label}** \u26a1\")\n    else:\n        st.caption(\"Status: \ud83d\udd34 Disabled (Missing Deps)\")\n\n    search_conf = config.get(\"search\", {})\n    \n    sc1, sc2 = st.columns(2)\n    with sc1:\n        x_val = st.number_input(\"Context (X)\", min_value=0, max_value=10, value=search_conf.get(\"x_markdown\", 3), help=\"Number of full markdown result to inject (Passive)\")\n    with sc2:\n        y_val = st.number_input(\"Total (Y)\", min_value=1, max_value=50, value=search_conf.get(\"y_total\", 15), help=\"Default limit for Search Tool\")\n        \n    if x_val != search_conf.get(\"x_markdown\", 3) or y_val != search_conf.get(\"y_total\", 15):\n        if \"search\" not in config: config[\"search\"] = {}\n        config[\"search\"][\"x_markdown\"] = x_val\n        config[\"search\"][\"y_total\"] = y_val\n        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"", "start_line": 761, "end_line": 810}, {"path": "src/interface/app.py", "content": "        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"\n        <div style=\"display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;\">\n            <h3 style=\"margin: 0; font-size: 1.2em;\">\ud83d\udc65 Agents Actifs</h3>\n            <span style=\"background: #e0e0e0; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold;\">{connected_count}</span>\n        </div>\n    \"\"\", unsafe_allow_html=True)\n    \n    # Maintain original order from agents dictionary\n    roster_list = [name for name in agents.keys()]\n    \n    # Explicitly add User to the top\n    roster_list.insert(0, \"User\")\n    \n    current_turn = turn.get(\"current\")\n    \n    if not roster_list:\n        st.caption(\"Aucun agent d\u00e9tect\u00e9.\")\n    else:\n        for name in roster_list:\n            # Handle User specifically since they are not in 'agents' dict\n            if name == \"User\":\n                u_avail = config.get(\"user_availability\", \"busy\")\n                # Map 'available' -> 'connected' (Green), 'busy' -> 'working' (Blue/Busy look)\n                info = {\n                    \"status\": \"connected\" if u_avail == \"available\" else \"working\",\n                    \"emoji\": \"\ud83d\udc64\"\n                }\n            else:\n                info = agents[name]\n            status = info.get(\"status\", \"pending\")\n            emoji = info.get(\"emoji\", \"\ud83e\udd16\")\n            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":", "start_line": 801, "end_line": 850}, {"path": "src/interface/app.py", "content": "            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":\n                status_color = \"#4CAF50\" # Green\n                status_label = \"En ligne\"\n                bg = \"rgba(76, 175, 80, 0.05)\"\n                border_color = \"rgba(76, 175, 80, 0.2)\"\n            elif status == \"pending_connection\":\n                status_color = \"#FF9800\" # Orange\n                status_label = \"Attente Reconnexion\"\n                bg = \"rgba(255, 152, 0, 0.05)\"\n                border_color = \"rgba(255, 152, 0, 0.2)\"\n            elif status == \"working\":\n                status_color = \"#2196F3\" # Blue\n                status_label = \"Travaille...\"\n                bg = \"rgba(33, 150, 243, 0.05)\"\n                border_color = \"rgba(33, 150, 243, 0.2)\"\n            else:\n                status_color = \"#9E9E9E\" # Grey\n                status_label = \"Hors-ligne\"\n                bg = \"transparent\"\n                border_color = \"#eee\"\n            \n            # Additional pulse if it's their turn and they are connected\n            is_active_working = is_turn and status == \"connected\"\n            if is_active_working:\n                status_color = \"#2196F3\"\n                status_label = \"En action...\"\n            \n            card_html = f\"\"\"<div class=\"{card_class}\" style=\"background-color: {bg}; border: 1px solid {border_color}; border-radius: 10px; padding: 10px 14px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s ease;\"><div style=\"display: flex; align-items: center; gap: 12px;\"><div style=\"font-size: 1.4em; background: white; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);\">{emoji}</div><div style=\"display: flex; flex-direction: column;\"><span style=\"font-weight: 600; color: {'#1a1a1a' if status == 'connected' else '#666'}; font-size: 0.95em;\">{name}</span><div style=\"display: flex; align-items: center; gap: 4px;\"><div style=\"width: 6px; height: 6px; background-color: {status_color}; border-radius: 50%;\"></div><span style=\"font-size: 0.7em; color: {status_color}; font-weight: 500; letter-spacing: 0.5px;\">{status_label}</span></div></div></div>{'<span style=\"font-size: 1.2em;\" title=\"C&rsquo;est son tour !\">\u2728</span>' if is_turn else ''}</div>\"\"\"\n            \n            if name == \"User\":\n                st.markdown(card_html, unsafe_allow_html=True)\n            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))", "start_line": 841, "end_line": 890}, {"path": "src/interface/app.py", "content": "            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))\n\n                    if is_reloading:\n                        if st.button(\"\u274c\", key=f\"force_{name}\", help=\"Force Disconnect (Si bloqu\u00e9)\", type=\"primary\"):\n                             force_disconnect_agent(name)\n                             # Also remove from queue if present to unblock sequence\n                             if name in st.session_state.get(\"reload_queue\", []):\n                                 st.session_state.reload_queue.remove(name)\n                             st.rerun()\n                    else:\n                        if st.button(\"\ud83d\udd04\", key=f\"reload_{name}\", help=f\"Recharger {name}\"):\n                            handle_disconnect_agent(name)\n                            st.rerun()\n            \n    st.markdown(\"<div style='height: 10px;'></div>\", unsafe_allow_html=True)\n    if st.button(\"\ud83d\udd04 Reload All Agents\", type=\"secondary\", use_container_width=True, help=\"S\u00e9quence de rechargement (Parall\u00e8le).\"):\n         # Identify Targets\n        to_reload = [\n            n for n, d in agents.items() \n            if d.get(\"status\") in [\"connected\", \"working\"] \n        ]\n        if not to_reload:\n            st.toast(\"Aucun agent actif \u00e0 recharger.\")\n        else:\n            # START PARALLEL SEQUENCE\n            st.session_state.reload_queue = list(to_reload)\n            \n            # Atomic Bulk Update\n            def bulk_reload_signal(s):\n                count = 0\n                for name in to_reload:\n                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,", "start_line": 881, "end_line": 930}, {"path": "src/interface/app.py", "content": "                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,\n                            \"target\": name,\n                            \"timestamp\": time.time()\n                         }\n                         s.setdefault(\"messages\", []).append(msg)\n                         count += 1\n                return f\"Signal de rechargement global envoy\u00e9 ({count} agents).\"\n            \n            state_store.update(bulk_reload_signal)\n            st.toast(f\"S\u00e9quence de rechargement PARALL\u00c8LE initialis\u00e9e pour {len(to_reload)} agents.\")\n            st.rerun()\n\n    # --- SEQUENTIAL RELOAD PROCESSOR ---\n    # Global Processor for the Queue\n    if \"reload_queue\" in st.session_state and st.session_state.reload_queue:\n        current_target = st.session_state.reload_queue[0]\n        \n        # Check current status (Refetch from fresh state)\n        if current_target in agents:\n            agent_data = agents[current_target]\n            status = agent_data.get(\"status\")\n            is_reload_active = agent_data.get(\"reload_active\")\n            \n            # Condition 1: Agent is finished (Disconnect/Pending)\n            if status in [\"pending_connection\", \"disconnected\", \"offline\"]:\n                st.session_state.reload_queue.pop(0) # Done\n                st.rerun() # Proceed to next immediately\n                \n            # Condition 2: Agent needs to be signaled\n            elif not is_reload_active:\n                 handle_disconnect_agent(current_target)\n                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()", "start_line": 921, "end_line": 970}, {"path": "src/interface/app.py", "content": "                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()\n\n    st.divider()\n\n    # --- PAUSE CONTROL ---\n    is_paused = config.get(\"paused\", False)\n    if st.toggle(\"\u23f8\ufe0f PAUSE MCP\", value=is_paused, help=\"Fige le temps pour tous les agents.\"):\n        if not is_paused:\n            config[\"paused\"] = True\n            save_config(config)\n            st.rerun()\n    else:\n        if is_paused:\n            config[\"paused\"] = False\n            save_config(config)\n            st.rerun()\n            \n    if is_paused:\n        st.warning(\"\u26a0\ufe0f SIMULATION EN PAUSE\")\n    \n    st.divider()\n\n    \n    # Debug Tools\n    with st.expander(\"\ud83d\udd27 DEBUG\"):\n        st.markdown(\"### \u2702\ufe0f MCP Truncation Settings\")\n        current_trunc = config.get(\"truncation_limit\", 4096) # Default 4096\n        new_trunc = st.number_input(\"Max Character Limit (0 = Disabled)\", min_value=0, value=int(current_trunc), step=100, help=\"Limite manuelle pour \u00e9viter le tronquage silencieux du client MCP (4096 bytes max).\")\n        if new_trunc != current_trunc:\n             config[\"truncation_limit\"] = int(new_trunc)\n             save_config(config)\n             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)", "start_line": 961, "end_line": 1010}, {"path": "src/interface/app.py", "content": "             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)\n                    server_script = os.path.join(current_dir, \"src\", \"core\", \"server.py\")\n                    command_str = f\"cd {current_dir} && uv run python {server_script}\"\n                    if \"mcpServers\" not in json_data:\n                        json_data[\"mcpServers\"] = {}\n                    json_data[\"mcpServers\"][\"multi-agents-mcp\"] = {\n                        \"command\": \"sh\",\n                        \"args\": [\"-c\", command_str],\n                        \"env\": {}\n                    }\n                    with open(config_path, \"w\") as f:\n                        json.dump(json_data, f, indent=2)\n                    st.success(\"Config Path Updated\")\n            except Exception as e:\n                st.error(str(e))\n\n        if st.button(\"Delete Memories\"):\n            try:\n                mem_dir = str(MEMORY_DIR)\n                if os.path.exists(mem_dir):\n                    import shutil\n                    shutil.rmtree(mem_dir)\n                    os.makedirs(mem_dir, exist_ok=True)\n                    st.success(\"Memories Cleared\")\n            except Exception as e:\n                st.error(str(e))\n\n\n# ==========================================\n# PAGE: COMMUNICATION (Chat)\n# ==========================================\nif st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":", "start_line": 1001, "end_line": 1050}, {"path": "src/interface/app.py", "content": "if st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":\n            # FOCUS MODE STYLES\n            st.markdown(\"\"\"\n            <style>\n            /* Gray out previous messages to focus on input */\n            .stChatMessage { opacity: 0.5; filter: grayscale(0.6); transition: all 0.3s; }\n            /* Highlight Input Area */\n            div[data-testid=\"stChatInput\"] { \n                border: 2px solid #ff3d00 !important; \n                border-radius: 12px;\n                box-shadow: 0 0 15px rgba(255, 61, 0, 0.4) !important;\n                background-color: #fff8f5 !important;\n            }\n            </style>\n            \"\"\", unsafe_allow_html=True)\n            \n\n        else:\n            st.markdown(f\"\"\"<div style=\"background-color: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; border-radius: 8px; text-align: center;\"><span style=\"color: #6c757d; font-size: 0.9em;\">En attente de :</span><br><span style=\"color: #1f1f1f; font-weight: bold; font-size: 1.1em;\">\ud83e\udd16 {current_turn}</span></div>\"\"\", unsafe_allow_html=True)\n    \n    # 1. Reply Context State\n    if \"reply_to\" not in st.session_state:\n        st.session_state.reply_to = None\n\n    # --- FLUX NEURAL (FULL WIDTH) ---\n    \n    # Helper for rendering messages and reply buttons\n    def render_reply_button(sender, content, idx):\n        if st.button(\"\u21a9\ufe0f\", key=f\"btn_reply_set_{idx}\", help=f\"Reply to {sender}\", type=\"tertiary\"):\n            st.session_state.reply_to = {\n                \"sender\": sender,\n                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"", "start_line": 1041, "end_line": 1090}, {"path": "src/interface/app.py", "content": "                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"\n        if is_relevant:\n            # FILTER LOGIC\n            if is_urgent_focus:\n                target = m.get(\"target\")\n                is_replied = m.get(\"replied\", False)\n                # Show only if directed to User AND not replied\n                if target != \"User\" or is_replied:\n                    continue\n            stream_msgs.append((i, m))\n    \n    # Pagination\n    if \"stream_limit\" not in st.session_state: st.session_state.stream_limit = 25\n    total_stream = len(stream_msgs)\n    limit_stream = st.session_state.stream_limit\n    if total_stream > limit_stream:\n            # UI Minimaliste (Tertiary)\n            if st.button(f\"\ud83d\udd03 Historique ({total_stream - limit_stream})\", key=\"load_more_stream\", type=\"tertiary\"):\n                st.session_state.stream_limit += 25\n                st.rerun()\n    \n    visible_stream = stream_msgs[max(0, total_stream - limit_stream):]\n    \n    if not visible_stream:\n        st.info(\"Aucune activit\u00e9 d\u00e9tect\u00e9e sur les bandes neurales.\")\n        \n    for real_idx, m in visible_stream:\n        sender = m.get(\"from\", \"?\")\n        target = m.get(\"target\", \"?\")\n        content = m.get(\"content\", \"\")\n        is_public = m.get(\"public\", False)\n        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        ", "start_line": 1081, "end_line": 1130}, {"path": "src/interface/app.py", "content": "        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        \n        # Style and Tag Logic\n        tag_html = \"\"\n        bubble_style = \"\"\n        \n        if is_public:\n            tag_html = ''\n            bubble_style = \"background-color: rgba(248, 249, 250, 0.8); border-left: 4px solid #2e7d32;\"\n        else:\n            if target == \"User\":\n                tag_html = '<span class=\"status-tag direct-tag\">\ud83d\udd12 Direct Link</span>'\n                if not is_replied:\n                    tag_html += '<span class=\"status-tag urgent-tag\">\u26a1 Action Required</span>'\n                    bubble_style = \"background-color: #fffdf0; border-left: 4px solid #fbc02d; box-shadow: 0 4px 12px rgba(251, 192, 45, 0.12);\"\n                else:\n                    bubble_style = \"background-color: #f0f7ff; border-left: 4px solid #1976d2;\"\n            elif sender == \"User\":\n                tag_html = f'<span class=\"status-tag\">\ud83d\udce4 Outgoing to {target}</span>'\n                bubble_style = \"background-color: #ffffff; border-left: 4px solid #94a3b8;\"\n            else:\n                tag_html = f'<span class=\"status-tag direct-tag\" style=\"background: #ffebee; color: #c62828;\">\ud83d\udd12 Private {sender} \u2192 {target}</span>'\n                bubble_style = \"background-color: #fff8f8; border: 2px dashed #ff4b4b;\"\n\n        with st.chat_message(sender, avatar=sender_emoji):\n            # Header with sender, target and status tags\n            c_header, c_action = st.columns([12, 1])\n            \n            with c_header:\n                st.markdown(f\"\"\"<div class=\"message-header\"><span style=\"font-weight: 700; color: #333; font-size: 0.9em;\">{sender}</span><span style=\"color: #999; font-size: 0.8em;\">\u2192</span><span class=\"target-badge\">{target if target != 'all' else 'everyone'}</span>{tag_html}<span style=\"color: #bbb; font-size: 0.7em; margin-left: auto;\">{time.strftime('%H:%M:%S', time.localtime(timestamp))}</span></div>\"\"\", unsafe_allow_html=True)\n            \n            with c_action:\n                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to", "start_line": 1121, "end_line": 1170}, {"path": "src/interface/app.py", "content": "                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to\n        col_banner, col_x = st.columns([11, 1])\n        with col_banner:\n            st.markdown(f'<div class=\"reply-banner-custom\">\u21a9\ufe0f R\u00e9ponse \u00e0 <b>{ctx[\"sender\"]}</b>: \"{ctx[\"preview\"]}\"</div>', unsafe_allow_html=True)\n        with col_x:\n            if st.button(\"\u2716\ufe0f\", key=\"cancel_reply_v6\", help=\"Annuler\"):\n                st.session_state.reply_to = None\n                st.rerun()\n\n    # 2. Status & Focus Row\n    # (No extra spacer here to avoid empty divs)\n    \n    # 2a. Typing Indicator (Centered)\n    typing_agents = []\n    current_turn_name = turn.get(\"current\")\n    for name, info in agents.items():\n        if name == \"User\": continue\n        if info.get(\"status\") == \"working\" or (name == current_turn_name and info.get(\"status\") == \"connected\"):\n            typing_agents.append(name)\n    \n    if typing_agents:\n        agent_names = \", \".join(typing_agents)\n        plural = \"sont\" if len(typing_agents) > 1 else \"est\"\n        st.markdown(f'<div class=\"typing-container\">{agent_names} {plural} en train d\\'\u00e9crire...<div class=\"typing-dots\"><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div></div></div>', unsafe_allow_html=True)\n    \n    # 2b. Focus Toggle (Removed)\n    c1, c2, c3 = st.columns([1, 1, 1])\n    \n    # MOVED: Banner in bottom right (c3)\n    if turn.get(\"current\") == \"User\":\n        with c3:\n            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n", "start_line": 1161, "end_line": 1210}, {"path": "src/interface/app.py", "content": "            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n\n    # Main Input\n    if prompt := st.chat_input(\"Message...\"):\n        def send_omni_msg(s):\n            target = None\n            public = True\n            reply_ref_id = None\n            \n            # Logic v2.0\n            \n            # 1. Context Reply (Strongest implicit) \n            # Tech Lead said: \"1. Si @Mention -> Priority. 2. Sinon si target_sel != Tous -> Target.\"\n            # Actually Context Reply usually overrides Selector visually, but Mention overrides all?\n            # Let's follow instruction:\n            # 1. Mention check\n            # 2. Selector check\n            # 3. Public\n            \n            found_mentions = []\n            found_mention = False\n            \n            # Mention Check (Specific Agents only)\n            known_agents = sorted(list(agents.keys()), key=len, reverse=True)\n            \n            # Use regex to find all mentions in order of appearance\n            # Sorting known_agents by length reverse ensures longer names are matched first\n            if known_agents:\n                pattern = \"@(\" + \"|\".join([re.escape(name) for name in known_agents]) + \")\"\n                matches = re.finditer(pattern, prompt)\n                seen = set()\n                for match in matches:\n                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True", "start_line": 1201, "end_line": 1250}, {"path": "src/interface/app.py", "content": "                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True\n            else:\n                audience = []\n            \n            if not found_mention:\n                if st.session_state.reply_to:\n                     # Reply Context overrides Selector\n                     target = st.session_state.reply_to[\"sender\"]\n                     reply_ref_id = st.session_state.reply_to[\"id\"]\n                     public = False\n                else:\n                    # No mention, no reply context -> Public Broadcast\n                    target = \"all\"\n                    public = True\n            \n            # Prepare content with Reply Context\n            final_content = prompt\n            if st.session_state.reply_to:\n                ref = st.session_state.reply_to\n                final_content = f\"\u21aa\ufe0f [R\u00e9ponse \u00e0 {ref['sender']}: \\\"{ref['preview']}\\\"]\\n{prompt}\"\n\n            msg = {\n                \"from\": \"User\",\n                \"content\": final_content,\n                \"timestamp\": time.time(),\n                \"public\": public,\n                \"audience\": audience\n            }\n            if target:\n                msg[\"target\"] = target\n            else:\n                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---", "start_line": 1241, "end_line": 1290}, {"path": "src/interface/app.py", "content": "                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---\n            if s.get(\"turn\", {}).get(\"current\") == \"User\":\n                next_speaker = None\n                if target and target != \"all\" and target in s.get(\"agents\", {}):\n                    next_speaker = target\n                else:\n                    # Priority 1: first_agent defined during reset\n                    first_pref = s.get(\"turn\", {}).get(\"first_agent\")\n                    if first_pref and first_pref in s.get(\"agents\", {}):\n                        next_speaker = first_pref\n                    else:\n                        # Fallback to the first connected agent\n                        connected = [n for n, d in s.get(\"agents\", {}).items() if d.get(\"status\") == \"connected\"]\n                        if connected:\n                            next_speaker = connected[0]\n                \n                if next_speaker:\n                    # USE CENTRALIZED TRANSITION LOGIC FROM ENGINE\n                    from src.core.logic import Engine\n                    engine = Engine(state_store) # Use the global state_store\n                    engine._finalize_turn_transition(s, next_speaker)\n\n            # Context Cleanup\n            if reply_ref_id is not None:\n                if reply_ref_id < len(s[\"messages\"]):\n                     s[\"messages\"][reply_ref_id][\"replied\"] = True\n                     \n            return \"Message Transmis.\"\n\n        res = state_store.update(send_omni_msg)\n        st.session_state.reply_to = None\n        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")", "start_line": 1281, "end_line": 1330}, {"path": "src/interface/app.py", "content": "        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")\n    \n    # --- 0. GRAPHVIZ VIEW (TOP) ---\n    with st.expander(\"\ud83d\udd78\ufe0f Topologie de la Flotte (Graphviz)\", expanded=False):\n        try:\n            g = render_graph(profiles)\n            st.graphviz_chart(g, use_container_width=True)\n        except Exception as e:\n            st.error(f\"Erreur de rendu du graphe : {e}\")\n\n    # Scenarios\n    st.subheader(\"\ud83d\udcbe Sc\u00e9narios\")\n    with st.container(border=True):\n        col_scen1, col_scen2 = st.columns(2)\n        if col_scen1.button(\"\ud83d\udcbe Sauvegarder\", use_container_width=True, help=\"Sauvegarder la configuration actuelle\"):\n            save_scenario_dialog(config)\n        if col_scen2.button(\"\ud83d\udcc2 Charger\", use_container_width=True, help=\"Charger une configuration existante\"):\n            load_scenario_dialog()\n\n    # Global Context (Full Width)\n    st.subheader(\"\ud83c\udf0d Contexte Global\")\n    with st.container(border=True):\n        enable_backlog = st.checkbox(\"Backlog\", value=config.get(\"enable_backlog\", False), help=\"Si coch\u00e9, les agents consulteront et mettront \u00e0 jour BACKLOG.md \u00e0 la racine.\")\n        if enable_backlog != config.get(\"enable_backlog\", False):\n            config[\"enable_backlog\"] = enable_backlog\n            save_config(config)\n            st.rerun()\n\n\n        global_context = st.text_area(\"Narratif / Contexte Partag\u00e9\", config.get(\"context\", \"\"), height=215)\n        if global_context != config.get(\"context\", \"\"):\n            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    ", "start_line": 1321, "end_line": 1370}, {"path": "src/interface/app.py", "content": "            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    \n    # Display cards in a grid\n    cols_per_row = 3\n    for i in range(0, len(profiles), cols_per_row):\n        cols = st.columns(cols_per_row)\n        for j in range(cols_per_row):\n            if i + j < len(profiles):\n                p = profiles[i + j]\n                with cols[j]:\n                    with st.container(border=True):\n                        count = int(p.get(\"count\", 0))\n                        emoji = p.get(\"emoji\", \"\ud83e\udd16\")\n                        description = p.get(\"description\", \"Aucune description.\")\n                        \n                        st.markdown(f\"\"\"<div class=\"agent-header\"><div class=\"agent-icon\">{emoji}</div><div class=\"agent-name\">{p['name']}</div></div><div class=\"agent-desc\">{description}</div>\"\"\", unsafe_allow_html=True)\n                        \n                        # Controls inside the card\n                        ctrl_c1, ctrl_c2, ctrl_c3 = st.columns([1, 1.2, 1])\n                        if ctrl_c1.button(\"\u2796\", key=f\"d_{i+j}\", use_container_width=True):\n                            p[\"count\"] = max(0, count - 1)\n                            save_config(config)\n                            st.rerun()\n                        \n                        ctrl_c2.markdown(f'<div class=\"count-display\">{count}</div>', unsafe_allow_html=True)\n                        \n                        if ctrl_c3.button(\"\u2795\", key=f\"i_{i+j}\", use_container_width=True):\n                            p[\"count\"] = count + 1\n                            save_config(config)\n                            st.rerun()\n                            \n                        if st.button(\"\u270f\ufe0f Modifier\", key=f\"ed_{i+j}\", use_container_width=True, type=\"secondary\"):\n                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    ", "start_line": 1361, "end_line": 1410}, {"path": "src/interface/app.py", "content": "                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    \n    # Calculate potential agent IDs the same way reset_logic does\n    temp_slots = []\n    for p in profiles:\n        for _ in range(int(p.get(\"count\", 0))):\n            temp_slots.append(p.get(\"display_name\") or p[\"name\"])\n            \n    counters = {}\n    for base in temp_slots:\n        counters.setdefault(base, 0)\n        counters[base] += 1\n        total_of_this_base = sum(1 for b in temp_slots if b == base)\n        agent_id = f\"{base} #{counters[base]}\" if total_of_this_base > 1 else base\n        potential_agents.append(agent_id)\n\n    # Use session state to persist choice\n    if \"first_speaker\" not in st.session_state:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    # Check if current choice is still valid (profiles might have changed)\n    if st.session_state.first_speaker not in potential_agents:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    selected_first = st.selectbox(\"Qui r\u00e9pondra en premier \u00e0 l'utilisateur ?\", potential_agents,\n                                 index=potential_agents.index(st.session_state.first_speaker) if st.session_state.first_speaker in potential_agents else 0,\n                                 help=\"L'agent qui aura le premier tour pour r\u00e9pondre au premier message de l'utilisateur.\")\n    st.session_state.first_speaker = selected_first\n\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n\n    # --- 3. RESET BUTTON (MODERN) ---\n    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context", "start_line": 1401, "end_line": 1450}, {"path": "src/interface/app.py", "content": "    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context\n                \n                # Use profiles from the state s for absolute consistency\n                current_profiles = s[\"config\"].get(\"profiles\", [])\n                \n                # Update total agents count\n                total_count = get_total_agents(current_profiles)\n                s[\"config\"][\"total_agents\"] = total_count\n                \n                pending_slots = []\n                # Remove random shuffle to maintain profile order\n                for p in current_profiles:\n                    for _ in range(int(p.get(\"count\", 0))):\n                        pending_slots.append({\n                            \"profile_ref\": p[\"name\"],\n                            \"role\": p.get(\"system_prompt\", \"\"),\n                            \"display_base\": p.get(\"display_name\") or p[\"name\"],\n                            \"emoji\": p.get(\"emoji\", \"\ud83e\udd16\")\n                        })\n                \n                new_agents = {}\n                counters = {}\n                for slot in pending_slots:\n                    base = slot[\"display_base\"]\n                    counters.setdefault(base, 0)\n                    counters[base] += 1\n                    agent_id = f\"{base} #{counters[base]}\" if sum(1 for sl in pending_slots if sl[\"display_base\"] == base) > 1 else base\n                    new_agents[agent_id] = {\n                        \"role\": slot[\"role\"], \"status\": \"pending_connection\",\n                        \"profile_ref\": slot[\"profile_ref\"], \"emoji\": slot[\"emoji\"]\n                    }\n                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"", "start_line": 1441, "end_line": 1490}, {"path": "src/interface/app.py", "content": "                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"\n            st.rerun()\n\n\n# ==========================================\n# PAGE: EDITOR (Admin)\n# ==========================================\nelif st.session_state.page == \"Editor\":\n    st.header(\"\ud83d\udee0\ufe0f \u00c9diteur d'Agents\")\n    \n    profile_names = [p[\"name\"] for p in profiles]\n    profile_names.append(\"\u2795 Create New\")\n    \n    sel_idx = 0\n    cur_edit = st.session_state.get(\"editing_agent_name\")\n    if cur_edit in profile_names:\n        sel_idx = profile_names.index(cur_edit)\n        \n    selected_name = st.selectbox(\"Selection Profil\", profile_names, index=sel_idx, key=\"edit_sel_page\")\n    \n    if selected_name == \"\u2795 Create New\":\n        current_profile = {\n            \"name\": \"New Agent\", \n            \"description\": \"\", \n            \"emoji\": \"\ud83e\udd16\", # Default, will be randomized in session state\n            \"connections\": [], \n            \"count\": 1, \n            \"capabilities\": [\"public\"]\n        }\n        new_mode = True\n        st.session_state.editing_agent_name = \"New Agent\"\n        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        ", "start_line": 1481, "end_line": 1530}, {"path": "src/interface/app.py", "content": "        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        \n        if st.button(\"\ud83d\uddd1\ufe0f Supprimer Profil\", type=\"primary\"):\n             config[\"profiles\"] = [p for p in profiles if p[\"name\"] != selected_name]\n             emoji_key = f\"editing_emoji_{selected_name}\"\n             if emoji_key in st.session_state:\n                 del st.session_state[emoji_key]\n             save_config(config)\n             st.rerun()\n\n    if current_profile:\n        st.markdown(\"---\")\n        # Layout Spacieux (Columns)\n        c_main, c_disp = st.columns([3, 2])\n        \n        with c_main:\n            c_emoji, c_name = st.columns([0.18, 0.82])\n            \n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key not in st.session_state:\n                st.session_state[emoji_key] = current_profile.get(\"emoji\", \"\ud83e\udd16\")\n            current_emoji = st.session_state[emoji_key]\n            \n            with c_emoji:\n                st.markdown('<div style=\"height: 28px;\"></div>', unsafe_allow_html=True) # Spacer to align with text input label\n                with st.popover(f\"{current_emoji}\", use_container_width=True):\n                    cols = st.columns(8)\n                    for idx, emoji in enumerate(EMOJI_LIST):\n                        if cols[idx % 8].button(emoji, key=f\"emoji_btn_{selected_name}_{idx}\"):\n                            st.session_state[emoji_key] = emoji\n                            st.rerun()\n            \n            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")", "start_line": 1521, "end_line": 1570}, {"path": "src/interface/app.py", "content": "            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")\n        caps = current_profile.get(\"capabilities\", [])\n        \n        # Preserve other capabilities (e.g. shell_exec)\n        other_caps = [c for c in caps if c not in [\"public\", \"private\"]]\n        \n        has_pub = \"public\" in caps\n        has_priv = \"private\" in caps\n        \n        # Determine default index\n        default_idx = 0 # Public\n        if has_pub and has_priv:\n            default_idx = 2 # Both\n        elif has_priv and not has_pub:\n            default_idx = 1 # Private\n        \n        comm_mode = st.radio(\n            \"Port\u00e9e de Communication\",\n            [\"Public\", \"Priv\u00e9\", \"Les Deux (Public & Priv\u00e9)\"],\n            index=default_idx,\n            key=f\"comm_mode_{selected_name}\",\n            horizontal=True,\n            help=\"D\u00e9finit la port\u00e9e de communication autoris\u00e9e pour cet agent.\"\n        )\n        \n        new_caps = list(other_caps)\n        if comm_mode == \"Public\":\n            new_caps.append(\"public\")\n        elif comm_mode == \"Priv\u00e9\":\n            new_caps.append(\"private\")\n        else:\n            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        ", "start_line": 1561, "end_line": 1610}, {"path": "src/interface/app.py", "content": "            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        \n        new_connections = []\n        \n        # Header for the \"Table\"\n        with st.container():\n            h1, h2, h3 = st.columns([2, 5, 1])\n            h1.markdown(\"**Cible**\")\n            h2.markdown(\"**Condition / Contexte**\")\n            h3.markdown(\"**Active**\")\n            st.markdown(\"<hr style='margin-top: 0; margin-bottom: 10px; border-color: #eee;'>\", unsafe_allow_html=True)\n        \n        for target in targets:\n            # Case-insensitive match for connections\n            existing_conn = next((c for c in current_profile.get(\"connections\", []) if c[\"target\"].lower() == target.lower()), None)\n            \n            c1, c2, c3 = st.columns([2, 5, 1])\n            \n            # Label\n            target_profile = next((p for p in profiles if p[\"name\"] == target), None)\n            target_emoji = \"\ud83c\udf10\" if target == \"public\" else \"\ud83d\udc64\" if target == \"User\" else (target_profile.get(\"emoji\", \"\ud83e\udd16\") if target_profile else \"\ud83e\udd16\")\n            c1.markdown(f\"{target_emoji} **{target}**\")\n            \n            default_ctx = existing_conn.get(\"context\", \"\") if existing_conn else \"\"\n            default_auth = existing_conn.get(\"authorized\", True) if existing_conn else False\n            \n            # Unique key with selected_name and target\n            ctx = c2.text_area(f\"Condition for {target}\", default_ctx, key=f\"conn_ctx_{selected_name}_{target}\", label_visibility=\"collapsed\", height=68)\n            auth = c3.checkbox(f\"Active for {target}\", default_auth, key=f\"conn_auth_{selected_name}_{target}\", label_visibility=\"collapsed\")\n            \n            if auth or ctx:\n                new_connections.append({\"target\": target, \"context\": ctx, \"authorized\": auth})\n            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            ", "start_line": 1601, "end_line": 1650}, {"path": "src/interface/app.py", "content": "            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            \n            # Use the emoji from session state\n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key in st.session_state:\n                current_profile[\"emoji\"] = st.session_state[emoji_key]\n                del st.session_state[emoji_key]\n            \n            if new_mode:\n                profiles.append(current_profile)\n            \n            # Smart renaming\n            if not new_mode and selected_name and new_name != selected_name:\n                for p in profiles:\n                    for conn in p.get(\"connections\", []):\n                        if conn.get(\"target\") == selected_name:\n                            conn[\"target\"] = new_name\n            \n            save_config(config)\n            st.toast(\"Saved!\")\n            st.rerun()\n\n# --- GLOBAL INJECTION (Fixed by Anais) ---\nif st.session_state.page == \"Communication\":\n    # Ensure mentions are injected even if logic flow was broken\n    active_names = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    inject_mention_system(active_names)", "start_line": 1641, "end_line": 1675}, {"path": "src/interface/app.py", "content": "import streamlit as st\nimport streamlit.components.v1 as components\nfrom streamlit_autorefresh import st_autorefresh\nimport graphviz\nimport json\nimport uuid\nimport sys\nimport os\nimport time\nimport re\nimport shutil\nfrom pathlib import Path\n\n# Add src to path to allow imports if run directly\nfrom pathlib import Path\nimport sys\nimport os\n\nCODE_ROOT = Path(__file__).resolve().parent.parent.parent\nif str(CODE_ROOT) not in sys.path:\n    sys.path.append(str(CODE_ROOT))\n\nfrom src.config import (\n    STATE_FILE, \n    MEMORY_DIR, \n    TEMPLATE_DIR, \n    LOCAL_DATA_DIR, \n    GLOBAL_PRESET_DIR, \n    ASSETS_DIR,\n    CODE_ROOT as CONFIG_CODE_ROOT,\n    RELOAD_INSTRUCTION\n)\nfrom src.core.state import StateStore\nfrom src.services.search_engine import SearchEngine\n\nst.set_page_config(page_title=\"Agent Orchestra\", page_icon=\"\ud83e\udd16\", layout=\"wide\")\n\n# --- EMOJI LIST ---\nEMOJI_LIST = [\n    \"\ud83e\udd16\", \"\ud83e\udde0\", \"\ud83d\udd75\ufe0f\", \"\ud83e\uddb8\", \"\ud83e\udd77\", \"\ud83e\uddd9\", \"\ud83e\udddb\", \"\ud83e\udddf\", \"\ud83e\uddde\", \"\ud83e\udddd\",\n    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",", "start_line": 1, "end_line": 50}, {"path": "src/interface/app.py", "content": "    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",\n    \"\ud83e\udda1\", \"\ud83e\udda6\", \"\ud83e\udda5\", \"\ud83d\udc01\", \"\ud83d\udc00\", \"\ud83d\udc3f\ufe0f\", \"\ud83e\udd94\", \"\ud83d\udc3e\", \"\ud83d\udc09\", \"\ud83d\udc32\",\n    \"\ud83c\udf35\", \"\ud83c\udf84\", \"\ud83c\udf32\", \"\ud83c\udf33\", \"\ud83c\udf34\", \"\ud83c\udf31\", \"\ud83c\udf3f\", \"\u2618\ufe0f\", \"\ud83c\udf40\", \"\ud83c\udf43\"\n]\n\ndef get_random_emoji():\n    import random\n    return random.choice(EMOJI_LIST)\n\n# --- HELPER FUNCTIONS ---\ndef inject_custom_css():\n    st.markdown(\"\"\"<style>\n    /* Global message container */\n    [data-testid=\"stChatMessage\"] {\n        padding: 1rem !important;\n        margin-bottom: 1.5rem !important;\n    }\n    \n    [data-testid=\"stChatMessage\"] [data-testid=\"stVerticalBlock\"] {\n        gap: 12px !important;\n    }\n\n    /* Header layout inside message */\n    .message-header {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        margin-bottom: 8px;\n        opacity: 0.85;\n    }\n\n    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    ", "start_line": 41, "end_line": 90}, {"path": "src/interface/app.py", "content": "    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    \n    .reply-banner-custom {\n        background: #f0f7ff;\n        border: 1px solid #d0e7ff;\n        border-radius: 10px;\n        padding: 8px 15px;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        margin-bottom: 8px;\n        font-size: 0.85em;\n        box-shadow: 0 2px 8px rgba(0,0,0,0.05);\n    }\n\n    /* Premium Toggle Styling (Targeting the specific widget) */\n    div[data-testid=\"stToggle\"] {\n        background: #ffffff;\n        padding: 10px 24px !important;\n        border-radius: 50px !important;\n        border: 1px solid #ff4b4b22 !important;\n        box-shadow: 0 4px 15px rgba(0,0,0,0.06) !important;\n        transition: all 0.3s ease !important;\n        width: fit-content !important;\n        margin: 10px auto !important;\n    }\n    \n    div[data-testid=\"stToggle\"]:hover {\n        border-color: #ff4b4b !important;\n        box-shadow: 0 6px 20px rgba(255,75,75,0.12) !important;\n        transform: translateY(-1px);\n    }\n\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;", "start_line": 81, "end_line": 130}, {"path": "src/interface/app.py", "content": "\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;\n        gap: 12px !important;\n        margin: 0 !important;\n    }\n\n    div[data-testid=\"stToggle\"] label p {\n        font-weight: 700 !important;\n        font-size: 0.95em !important;\n        color: #1a1a1a !important;\n        margin: 0 !important;\n        letter-spacing: -0.2px !important;\n    }\n    \n    .target-badge {\n        font-weight: 600;\n        padding: 1px 6px;\n        border-radius: 4px;\n        font-size: 0.75em;\n        color: #444;\n        background: rgba(0,0,0,0.08);\n        border: 1px solid rgba(0,0,0,0.1);\n    }\n    \n    .status-tag {\n        font-size: 0.7em;\n        font-weight: 700;\n        padding: 1px 5px;\n        border-radius: 4px;\n        text-transform: uppercase;\n        letter-spacing: 0.5px;\n    }\n    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;", "start_line": 121, "end_line": 170}, {"path": "src/interface/app.py", "content": "    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        padding: 6px 16px;\n        color: #666;\n        font-size: 0.85em;\n        font-style: italic;\n        background: rgba(0,0,0,0.03);\n        border-radius: 20px;\n        margin: 10px auto;\n        width: fit-content;\n        border: 1px solid rgba(0,0,0,0.05);\n        box-shadow: 0 2px 4px rgba(0,0,0,0.02);\n    }\n    .typing-dots {\n        display: flex; gap: 4px; margin-left: 8px;\n    }\n    .typing-dot {\n        width: 5px; height: 5px; background: #999; border-radius: 50%;\n        animation: typing-bounce 1.4s infinite ease-in-out;\n    }\n    .typing-dot:nth-child(1) { animation-delay: -0.32s; }\n    .typing-dot:nth-child(2) { animation-delay: -0.16s; }\n    @keyframes typing-bounce {\n        0%, 80%, 100% { transform: translateY(0); opacity: 0.3; }\n        40% { transform: translateY(-3px); opacity: 1; }\n    }\n    </style>\"\"\", unsafe_allow_html=True)\n\ninject_custom_css()\n\n# --- INITIALIZE STATE (ONCE) ---\nstate_store = StateStore()\n\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n", "start_line": 161, "end_line": 210}, {"path": "src/interface/app.py", "content": "\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n\ndef save_config(new_config):\n    def update_fn(s):\n        s[\"config\"] = new_config\n        return \"Config Saved\"\n    state_store.update(update_fn)\n\n\n# --- SEARCH ENGINE INIT ---\n@st.cache_resource\ndef init_search_engine():\n    engine = SearchEngine()\n    # Ensure directory exists for persist\n    persist = LOCAL_DATA_DIR / \"vector_store\"\n    persist.mkdir(parents=True, exist_ok=True)\n    engine.initialize(root_dir=CODE_ROOT, persist_dir=persist)\n    return engine\n\n# Initialize background service\nsearch_engine = init_search_engine()\n\n\n# --- DIALOGS ---\ndef handle_disconnect_agent(agent_name):\n    \"\"\"\n    Sets the reload_active flag for the agent.\n    Does NOT set 'pending_connection' immediately (Agent must do it via disconnect tool).\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = True\n            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }", "start_line": 201, "end_line": 250}, {"path": "src/interface/app.py", "content": "            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }\n            s.setdefault(\"messages\", []).append(msg)\n            \n        return f\"Signal de rechargement envoy\u00e9 \u00e0 : {agent_name}\"\n    \n    state_store.update(update_fn)\n    st.toast(f\"Reload signal sent to {agent_name} \ud83d\udd01\")\n\ndef force_disconnect_agent(agent_name):\n    \"\"\"\n    Forces status to pending_connection immediately.\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = False # Reset flag\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n        return f\"Force disconnect: {agent_name}\"\n    state_store.update(update_fn)\n    st.toast(f\"\u2620\ufe0f Force Disconnect: {agent_name}\")\n\nPRESET_DIR = GLOBAL_PRESET_DIR\n\n@st.dialog(\"Sauvegarder le Sc\u00e9nario\")\ndef save_scenario_dialog(current_config):\n    save_name = st.text_input(\"Nom de Sauvegarde\", placeholder=\"mon_scenario\")\n    if st.button(\"Confirmer la Sauvegarde\", use_container_width=True):\n        if save_name:\n            # Basic filename cleaning\n            filename = \"\".join([c for c in save_name if c.isalnum() or c in (' ', '.', '_', '-')]).rstrip()\n            path = PRESET_DIR / f\"{filename}.json\"\n            with open(path, \"w\") as f:\n                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")", "start_line": 241, "end_line": 290}, {"path": "src/interface/app.py", "content": "                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")\n                except Exception as e:\n                    # Non-blocking, just dev convenience\n                    print(f\"Failed to sync to repo: {e}\")\n            st.success(f\"Sauvegard\u00e9 : {filename}\")\n            time.sleep(1)\n            st.rerun()\n        else:\n            st.error(\"Veuillez entrer un nom.\")\n\n@st.dialog(\"Charger un Sc\u00e9nario\")\ndef load_scenario_dialog():\n    # Unified Source: User Global Presets\n    # (Defaults have been synced here by sync_presets)\n    presets = sorted([f for f in os.listdir(PRESET_DIR) if f.endswith(\".json\")])\n    \n    if not presets:\n        st.warning(\"Aucun sc\u00e9nario trouv\u00e9.\")\n        return\n\n    options = [f\"\ud83d\udcbe {f}\" for f in presets]\n    path_map = {f\"\ud83d\udcbe {f}\": PRESET_DIR / f for f in presets}\n        \n    selected_label = st.selectbox(\"Choisir un Preset\", options)\n    \n    c_load, c_del = st.columns([0.85, 0.15])\n    \n    with c_load:\n        if st.button(\"Charger la Configuration\", use_container_width=True, type=\"primary\"):\n            if selected_label:\n                path = path_map[selected_label]\n                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)", "start_line": 281, "end_line": 330}, {"path": "src/interface/app.py", "content": "                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)\n                st.rerun()\n                \n    with c_del:\n        if st.button(\"\ud83d\uddd1\ufe0f\", key=\"del_scen_btn\", help=\"Supprimer d\u00e9finivement\", use_container_width=True):\n             if selected_label:\n                 path = path_map[selected_label]\n                 try:\n                     os.remove(path)\n                     st.toast(f\"Sc\u00e9nario supprim\u00e9: {selected_label}\")\n                     time.sleep(0.7)\n                     st.rerun()\n                 except Exception as e:\n                     st.error(f\"Erreur: {e}\")\n\ndef get_total_agents(profiles):\n    total = 0\n    for p in profiles:\n        try:\n            total += int(p.get(\"count\", 0))\n        except:\n            pass\n    return total\n\ndef format_mentions(text):\n    if not text: return text\n    \n    # 1. First decorate @everyone\n    text = re.sub(\n        r'(@everyone)',\n        r'<span style=\"color: #ffffff; background-color: #ff4b4b; padding: 2px 8px; border-radius: 6px; font-weight: 700; font-size: 0.9em; box-shadow: 0 2px 4px rgba(255,75,75,0.3);\">\\1</span>',\n        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )", "start_line": 321, "end_line": 370}, {"path": "src/interface/app.py", "content": "        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )\n\ndef render_graph(profiles, current_editing=None):\n    graph = graphviz.Digraph()\n    graph.attr(rankdir='LR', size='12,2', ratio='fill', bgcolor='transparent', margin='0')\n    \n    # Add User node\n    graph.node(\"User\", label=\"\ud83d\udc64 User\", style='filled', fillcolor='lightgrey', shape='circle', fontsize='10', height='0.5')\n    \n    for p in profiles:\n        name = p[\"name\"]\n        color = 'lightblue'\n        if current_editing and name == current_editing:\n            color = 'gold'\n        count = p.get(\"count\", 0)\n        label = f\"{name}\\n(x{count})\"\n        graph.node(name, label=label, style='filled', fillcolor=color, shape='box', fontsize='10', height='0.5')\n\n    for p in profiles:\n        source = p[\"name\"]\n        for conn in p.get(\"connections\", []):\n            target = conn.get(\"target\")\n            is_auth = conn.get(\"authorized\", True)\n            if is_auth and (target == \"User\" or any(prof[\"name\"] == target for prof in profiles)):\n                graph.edge(source, target, fontsize='8', color='gray', arrowsize='0.5')\n    return graph\n\ndef inject_mention_system(agent_names):\n    import json\n    agents_json = json.dumps(agent_names)\n    \n    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;", "start_line": 361, "end_line": 410}, {"path": "src/interface/app.py", "content": "    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;\n            const textarea = doc.querySelector('textarea[data-testid=\"stChatInputTextArea\"]');\n            \n            if (!textarea) {{\n                // Polled by setInterval, so just return\n                return;\n            }}\n\n            // Cleanup previous interaction from this or previous iframes\n            // We use a custom property on the DOM node to store the controller\n            if (textarea._mentionController) {{\n                // If the controller belongs to a DEAD iframe, this might fail or succeed. \n                // But mostly it allows us to signal \"Stop Listing\".\n                try {{\n                    textarea._mentionController.abort();\n                }} catch(e) {{}}\n            }}\n\n            // Create new controller for this instance\n            const controller = new AbortController();\n            textarea._mentionController = controller;\n            const signal = controller.signal;\n\n            let menu = doc.getElementById('mention-menu');\n            if (!menu) {{\n                menu = doc.createElement('div');\n                menu.id = 'mention-menu';\n                Object.assign(menu.style, {{\n                    display: 'none',\n                    position: 'fixed',\n                    background: 'white',\n                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);", "start_line": 401, "end_line": 450}, {"path": "src/interface/app.py", "content": "                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);\n            }}\n\n            // Inject styles\n            if (!doc.getElementById('mention-styles')) {{\n                const style = doc.createElement('style');\n                style.id = 'mention-styles';\n                style.innerHTML = `\n                    .mention-item:hover {{\n                        background-color: #f0f2f6 !important;\n                    }}\n                `;\n                doc.head.appendChild(style);\n            }}\n\n            textarea.addEventListener('input', (e) => {{\n                if (e.isComposing) return;\n                const value = textarea.value;\n                const cursorPos = textarea.selectionStart;\n                const textBeforeCursor = value.substring(0, cursorPos);\n                const mentionMatch = textBeforeCursor.match(/@([\\\\w\\\\s#]*)$/);\n\n                if (mentionMatch) {{\n                    isVisible = true;\n                    currentFilter = mentionMatch[1].toLowerCase();\n                    renderMenu(textarea);\n                }} else {{\n                    hideMenu();\n                }}\n            }}, {{ signal }});\n\n            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;", "start_line": 441, "end_line": 490}, {"path": "src/interface/app.py", "content": "            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'ArrowUp') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex - 1 + filtered.length) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'Enter' || e.key === 'Tab') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    insertMention(textarea, filtered[selectedIndex]);\n                }} else if (e.key === 'Escape') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    hideMenu();\n                }}\n            }}, {{ capture: true, signal: signal }});\n        }}\n\n        function renderMenu(textarea) {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n            \n            if (filtered.length === 0) {{\n                hideMenu();\n                return;\n            }}\n\n            menu.innerHTML = filtered.map((a, i) => `\n                <div class=\"mention-item\" style=\"\n                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">", "start_line": 481, "end_line": 530}, {"path": "src/interface/app.py", "content": "                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">\n                    <span style=\"font-weight: ${{i === selectedIndex ? '600' : '400'}};\">@${{a}}</span>\n                    ${{a === 'everyone' ? '<span style=\"font-size: 10px; background: #ff4b4b; color: white; padding: 1px 4px; border-radius: 4px; margin-left: 5px;\">PUBLIC</span>' : ''}}\n                </div>\n            `).join('');\n\n            const rect = textarea.getBoundingClientRect();\n            menu.style.display = 'block';\n            menu.style.left = rect.left + 'px';\n            \n            // Position above the textarea\n            menu.style.bottom = (window.parent.innerHeight - rect.top + 10) + 'px';\n            isVisible = true;\n        }}\n\n        function insertMention(textarea, name) {{\n            const value = textarea.value;\n            const cursorPos = textarea.selectionStart;\n            const textBeforeCursor = value.substring(0, cursorPos);\n            const textAfterCursor = value.substring(cursorPos);\n            \n            const newTextBefore = textBeforeCursor.replace(/@([\\\\w\\\\s#]*)$/, '@' + name + ' ');\n            const newValue = newTextBefore + textAfterCursor;\n\n            // Robust React state update\n            const nativeTextareaValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, \"value\").set;\n            nativeTextareaValueSetter.call(textarea, newValue);\n            \n            // Trigger events\n            textarea.dispatchEvent(new Event('input', {{ bubbles: true }}));\n            textarea.dispatchEvent(new Event('change', {{ bubbles: true }}));\n\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{", "start_line": 521, "end_line": 570}, {"path": "src/interface/app.py", "content": "\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            if (menu) menu.style.display = 'none';\n            isVisible = false;\n            selectedIndex = 0;\n        }}\n\n        // Initial setup & Polling for re-mounts\n        setInterval(setupMentions, 1000);\n    }})();\n    </script>\n    \"\"\"\n    components.html(components_code, height=0)\n\n# --- MAIN LOGIC ---\n\n# 1. Load Data\nstate, config = load_config()\ndata = state\nprofiles = config.get(\"profiles\", [])\nagents = data.get(\"agents\", {})\nturn = data.get(\"turn\", {})\nmessages = data.get(\"messages\", [])\n\n# --- CSS STYLING ---\nst.markdown(\"\"\"\n<style>\n    div[data-testid=\"stSidebar\"] {\n        background-color: #f0f2f6;\n    }\n    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;", "start_line": 561, "end_line": 610}, {"path": "src/interface/app.py", "content": "    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;\n    }\n    /* Agent Card Styling */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] {\n        background-color: white;\n        border-radius: 16px !important;\n        border: 1px solid #f0f0f0 !important;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.04);\n        padding: 0.5rem;\n        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    }\n    [data-testid=\"stVerticalBlockBorderWrapper\"]:hover {\n        transform: translateY(-4px);\n        box-shadow: 0 12px 24px rgba(0,0,0,0.08);\n        border-color: #ff4b4b44 !important;\n    }\n    .agent-header {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 12px;\n    }\n    .agent-icon {\n        font-size: 1.5em;\n        background: #f8f9fa;\n        width: 42px;\n        height: 42px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 10px;\n        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;", "start_line": 601, "end_line": 650}, {"path": "src/interface/app.py", "content": "        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;\n        color: #64748b;\n        margin-bottom: 1rem;\n        min-height: 4.2em;\n        line-height: 1.5;\n    }\n    .count-display {\n        background: #f1f5f9;\n        color: #0f172a;\n        height: 2.4em;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 8px;\n        font-weight: 700;\n        font-size: 1.1em;\n    }\n    /* Compact buttons in cards */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] .stButton button {\n        height: 2.4em !important;\n    }\n    .reset-button-container {\n        display: flex;\n        justify-content: center;\n        padding: 20px;\n    }\n    @keyframes pulse-gold {\n        0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }\n        70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }\n        100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }\n    }\n    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:", "start_line": 641, "end_line": 690}, {"path": "src/interface/app.py", "content": "    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:\n    st.session_state.page = \"Communication\"\n\n# --- SIDEBAR ---\nwith st.sidebar:\n    st.title(\"\ud83e\udd16 Orchestra\")\n    \n    # Global Autorefresh (Active on all pages to catch messages)\n    st_autorefresh(interval=4000, key=\"global_pulse\")\n\n    st.markdown(\"### Navigation\")\n    \n    # --- NOTIFICATION LOGIC ---\n    total_msgs = len(messages)\n    if \"last_read_count\" not in st.session_state:\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    unread = 0\n    if st.session_state.page != \"Communication\":\n        unread = max(0, total_msgs - st.session_state.last_read_count)\n        \n        # Toast for new messages\n        if \"last_toast_count\" not in st.session_state:\n             st.session_state.last_toast_count = total_msgs\n             \n        if total_msgs > st.session_state.last_toast_count:\n             new_count = total_msgs - st.session_state.last_toast_count\n             # Toast the last one\n             newest = messages[-1]\n             sender = newest.get(\"from\", \"?\")\n             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"", "start_line": 681, "end_line": 730}, {"path": "src/interface/app.py", "content": "             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"\n    if unread > 0:\n        label_comm = f\"\ud83d\udcac Chat ({unread} \ud83d\udd34)\"\n\n    if st.button(label_comm, use_container_width=True, type=\"primary\" if st.session_state.page == \"Communication\" else \"secondary\"):\n        st.session_state.page = \"Communication\"\n        st.rerun()\n        \n    if st.button(\"\ud83c\udf9b\ufe0f Cockpit\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Cockpit\" else \"secondary\"):\n        st.session_state.page = \"Cockpit\"\n        st.rerun()\n        \n    if st.button(\"\ud83d\udee0\ufe0f \u00c9diteur\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Editor\" else \"secondary\"):\n        st.session_state.page = \"Editor\"\n        st.rerun()\n\n    st.divider()\n    \n    # 1. Identity / User Status\n    st.markdown(\"### \ud83d\udc64 Identity\")\n    user_status = config.get(\"user_availability\", \"busy\")\n    \n    # User status toggle\n    is_available = st.toggle(\"Available\", value=(user_status == \"available\"), help=\"Switch between Available (\ud83d\udfe2) and Busy (\ud83d\udd34)\")\n    new_status = \"available\" if is_available else \"busy\"\n    \n    if new_status != user_status:\n        config[\"user_availability\"] = new_status\n        save_config(config)\n        st.rerun()\n\n    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:", "start_line": 721, "end_line": 770}, {"path": "src/interface/app.py", "content": "    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:\n        config[\"language\"] = new_lang\n        save_config(config)\n        st.rerun()\n\n\n\n    st.divider()\n    \n    # Search Config\n    st.markdown(\"### \ud83d\udd0e Search Engine\")\n    \n    # Status Indicator\n    if search_engine and search_engine.initialized:\n        dev_label = search_engine.device.upper().replace(\"\u201d\", \"\") # Fix typo if any from previous edit\n        st.caption(f\"Status: **Active** | Device: **{dev_label}** \u26a1\")\n    else:\n        st.caption(\"Status: \ud83d\udd34 Disabled (Missing Deps)\")\n\n    search_conf = config.get(\"search\", {})\n    \n    sc1, sc2 = st.columns(2)\n    with sc1:\n        x_val = st.number_input(\"Context (X)\", min_value=0, max_value=10, value=search_conf.get(\"x_markdown\", 3), help=\"Number of full markdown result to inject (Passive)\")\n    with sc2:\n        y_val = st.number_input(\"Total (Y)\", min_value=1, max_value=50, value=search_conf.get(\"y_total\", 15), help=\"Default limit for Search Tool\")\n        \n    if x_val != search_conf.get(\"x_markdown\", 3) or y_val != search_conf.get(\"y_total\", 15):\n        if \"search\" not in config: config[\"search\"] = {}\n        config[\"search\"][\"x_markdown\"] = x_val\n        config[\"search\"][\"y_total\"] = y_val\n        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"", "start_line": 761, "end_line": 810}, {"path": "src/interface/app.py", "content": "        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"\n        <div style=\"display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;\">\n            <h3 style=\"margin: 0; font-size: 1.2em;\">\ud83d\udc65 Agents Actifs</h3>\n            <span style=\"background: #e0e0e0; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold;\">{connected_count}</span>\n        </div>\n    \"\"\", unsafe_allow_html=True)\n    \n    # Maintain original order from agents dictionary\n    roster_list = [name for name in agents.keys()]\n    \n    # Explicitly add User to the top\n    roster_list.insert(0, \"User\")\n    \n    current_turn = turn.get(\"current\")\n    \n    if not roster_list:\n        st.caption(\"Aucun agent d\u00e9tect\u00e9.\")\n    else:\n        for name in roster_list:\n            # Handle User specifically since they are not in 'agents' dict\n            if name == \"User\":\n                u_avail = config.get(\"user_availability\", \"busy\")\n                # Map 'available' -> 'connected' (Green), 'busy' -> 'working' (Blue/Busy look)\n                info = {\n                    \"status\": \"connected\" if u_avail == \"available\" else \"working\",\n                    \"emoji\": \"\ud83d\udc64\"\n                }\n            else:\n                info = agents[name]\n            status = info.get(\"status\", \"pending\")\n            emoji = info.get(\"emoji\", \"\ud83e\udd16\")\n            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":", "start_line": 801, "end_line": 850}, {"path": "src/interface/app.py", "content": "            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":\n                status_color = \"#4CAF50\" # Green\n                status_label = \"En ligne\"\n                bg = \"rgba(76, 175, 80, 0.05)\"\n                border_color = \"rgba(76, 175, 80, 0.2)\"\n            elif status == \"pending_connection\":\n                status_color = \"#FF9800\" # Orange\n                status_label = \"Attente Reconnexion\"\n                bg = \"rgba(255, 152, 0, 0.05)\"\n                border_color = \"rgba(255, 152, 0, 0.2)\"\n            elif status == \"working\":\n                status_color = \"#2196F3\" # Blue\n                status_label = \"Travaille...\"\n                bg = \"rgba(33, 150, 243, 0.05)\"\n                border_color = \"rgba(33, 150, 243, 0.2)\"\n            else:\n                status_color = \"#9E9E9E\" # Grey\n                status_label = \"Hors-ligne\"\n                bg = \"transparent\"\n                border_color = \"#eee\"\n            \n            # Additional pulse if it's their turn and they are connected\n            is_active_working = is_turn and status == \"connected\"\n            if is_active_working:\n                status_color = \"#2196F3\"\n                status_label = \"En action...\"\n            \n            card_html = f\"\"\"<div class=\"{card_class}\" style=\"background-color: {bg}; border: 1px solid {border_color}; border-radius: 10px; padding: 10px 14px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s ease;\"><div style=\"display: flex; align-items: center; gap: 12px;\"><div style=\"font-size: 1.4em; background: white; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);\">{emoji}</div><div style=\"display: flex; flex-direction: column;\"><span style=\"font-weight: 600; color: {'#1a1a1a' if status == 'connected' else '#666'}; font-size: 0.95em;\">{name}</span><div style=\"display: flex; align-items: center; gap: 4px;\"><div style=\"width: 6px; height: 6px; background-color: {status_color}; border-radius: 50%;\"></div><span style=\"font-size: 0.7em; color: {status_color}; font-weight: 500; letter-spacing: 0.5px;\">{status_label}</span></div></div></div>{'<span style=\"font-size: 1.2em;\" title=\"C&rsquo;est son tour !\">\u2728</span>' if is_turn else ''}</div>\"\"\"\n            \n            if name == \"User\":\n                st.markdown(card_html, unsafe_allow_html=True)\n            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))", "start_line": 841, "end_line": 890}, {"path": "src/interface/app.py", "content": "            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))\n\n                    if is_reloading:\n                        if st.button(\"\u274c\", key=f\"force_{name}\", help=\"Force Disconnect (Si bloqu\u00e9)\", type=\"primary\"):\n                             force_disconnect_agent(name)\n                             # Also remove from queue if present to unblock sequence\n                             if name in st.session_state.get(\"reload_queue\", []):\n                                 st.session_state.reload_queue.remove(name)\n                             st.rerun()\n                    else:\n                        if st.button(\"\ud83d\udd04\", key=f\"reload_{name}\", help=f\"Recharger {name}\"):\n                            handle_disconnect_agent(name)\n                            st.rerun()\n            \n    st.markdown(\"<div style='height: 10px;'></div>\", unsafe_allow_html=True)\n    if st.button(\"\ud83d\udd04 Reload All Agents\", type=\"secondary\", use_container_width=True, help=\"S\u00e9quence de rechargement (Parall\u00e8le).\"):\n         # Identify Targets\n        to_reload = [\n            n for n, d in agents.items() \n            if d.get(\"status\") in [\"connected\", \"working\"] \n        ]\n        if not to_reload:\n            st.toast(\"Aucun agent actif \u00e0 recharger.\")\n        else:\n            # START PARALLEL SEQUENCE\n            st.session_state.reload_queue = list(to_reload)\n            \n            # Atomic Bulk Update\n            def bulk_reload_signal(s):\n                count = 0\n                for name in to_reload:\n                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,", "start_line": 881, "end_line": 930}, {"path": "src/interface/app.py", "content": "                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,\n                            \"target\": name,\n                            \"timestamp\": time.time()\n                         }\n                         s.setdefault(\"messages\", []).append(msg)\n                         count += 1\n                return f\"Signal de rechargement global envoy\u00e9 ({count} agents).\"\n            \n            state_store.update(bulk_reload_signal)\n            st.toast(f\"S\u00e9quence de rechargement PARALL\u00c8LE initialis\u00e9e pour {len(to_reload)} agents.\")\n            st.rerun()\n\n    # --- SEQUENTIAL RELOAD PROCESSOR ---\n    # Global Processor for the Queue\n    if \"reload_queue\" in st.session_state and st.session_state.reload_queue:\n        current_target = st.session_state.reload_queue[0]\n        \n        # Check current status (Refetch from fresh state)\n        if current_target in agents:\n            agent_data = agents[current_target]\n            status = agent_data.get(\"status\")\n            is_reload_active = agent_data.get(\"reload_active\")\n            \n            # Condition 1: Agent is finished (Disconnect/Pending)\n            if status in [\"pending_connection\", \"disconnected\", \"offline\"]:\n                st.session_state.reload_queue.pop(0) # Done\n                st.rerun() # Proceed to next immediately\n                \n            # Condition 2: Agent needs to be signaled\n            elif not is_reload_active:\n                 handle_disconnect_agent(current_target)\n                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()", "start_line": 921, "end_line": 970}, {"path": "src/interface/app.py", "content": "                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()\n\n    st.divider()\n\n    # --- PAUSE CONTROL ---\n    is_paused = config.get(\"paused\", False)\n    if st.toggle(\"\u23f8\ufe0f PAUSE MCP\", value=is_paused, help=\"Fige le temps pour tous les agents.\"):\n        if not is_paused:\n            config[\"paused\"] = True\n            save_config(config)\n            st.rerun()\n    else:\n        if is_paused:\n            config[\"paused\"] = False\n            save_config(config)\n            st.rerun()\n            \n    if is_paused:\n        st.warning(\"\u26a0\ufe0f SIMULATION EN PAUSE\")\n    \n    st.divider()\n\n    \n    # Debug Tools\n    with st.expander(\"\ud83d\udd27 DEBUG\"):\n        st.markdown(\"### \u2702\ufe0f MCP Truncation Settings\")\n        current_trunc = config.get(\"truncation_limit\", 4096) # Default 4096\n        new_trunc = st.number_input(\"Max Character Limit (0 = Disabled)\", min_value=0, value=int(current_trunc), step=100, help=\"Limite manuelle pour \u00e9viter le tronquage silencieux du client MCP (4096 bytes max).\")\n        if new_trunc != current_trunc:\n             config[\"truncation_limit\"] = int(new_trunc)\n             save_config(config)\n             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)", "start_line": 961, "end_line": 1010}, {"path": "src/interface/app.py", "content": "             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)\n                    server_script = os.path.join(current_dir, \"src\", \"core\", \"server.py\")\n                    command_str = f\"cd {current_dir} && uv run python {server_script}\"\n                    if \"mcpServers\" not in json_data:\n                        json_data[\"mcpServers\"] = {}\n                    json_data[\"mcpServers\"][\"multi-agents-mcp\"] = {\n                        \"command\": \"sh\",\n                        \"args\": [\"-c\", command_str],\n                        \"env\": {}\n                    }\n                    with open(config_path, \"w\") as f:\n                        json.dump(json_data, f, indent=2)\n                    st.success(\"Config Path Updated\")\n            except Exception as e:\n                st.error(str(e))\n\n        if st.button(\"Delete Memories\"):\n            try:\n                mem_dir = str(MEMORY_DIR)\n                if os.path.exists(mem_dir):\n                    import shutil\n                    shutil.rmtree(mem_dir)\n                    os.makedirs(mem_dir, exist_ok=True)\n                    st.success(\"Memories Cleared\")\n            except Exception as e:\n                st.error(str(e))\n\n\n# ==========================================\n# PAGE: COMMUNICATION (Chat)\n# ==========================================\nif st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":", "start_line": 1001, "end_line": 1050}, {"path": "src/interface/app.py", "content": "if st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":\n            # FOCUS MODE STYLES\n            st.markdown(\"\"\"\n            <style>\n            /* Gray out previous messages to focus on input */\n            .stChatMessage { opacity: 0.5; filter: grayscale(0.6); transition: all 0.3s; }\n            /* Highlight Input Area */\n            div[data-testid=\"stChatInput\"] { \n                border: 2px solid #ff3d00 !important; \n                border-radius: 12px;\n                box-shadow: 0 0 15px rgba(255, 61, 0, 0.4) !important;\n                background-color: #fff8f5 !important;\n            }\n            </style>\n            \"\"\", unsafe_allow_html=True)\n            \n\n        else:\n            st.markdown(f\"\"\"<div style=\"background-color: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; border-radius: 8px; text-align: center;\"><span style=\"color: #6c757d; font-size: 0.9em;\">En attente de :</span><br><span style=\"color: #1f1f1f; font-weight: bold; font-size: 1.1em;\">\ud83e\udd16 {current_turn}</span></div>\"\"\", unsafe_allow_html=True)\n    \n    # 1. Reply Context State\n    if \"reply_to\" not in st.session_state:\n        st.session_state.reply_to = None\n\n    # --- FLUX NEURAL (FULL WIDTH) ---\n    \n    # Helper for rendering messages and reply buttons\n    def render_reply_button(sender, content, idx):\n        if st.button(\"\u21a9\ufe0f\", key=f\"btn_reply_set_{idx}\", help=f\"Reply to {sender}\", type=\"tertiary\"):\n            st.session_state.reply_to = {\n                \"sender\": sender,\n                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"", "start_line": 1041, "end_line": 1090}, {"path": "src/interface/app.py", "content": "                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"\n        if is_relevant:\n            # FILTER LOGIC\n            if is_urgent_focus:\n                target = m.get(\"target\")\n                is_replied = m.get(\"replied\", False)\n                # Show only if directed to User AND not replied\n                if target != \"User\" or is_replied:\n                    continue\n            stream_msgs.append((i, m))\n    \n    # Pagination\n    if \"stream_limit\" not in st.session_state: st.session_state.stream_limit = 25\n    total_stream = len(stream_msgs)\n    limit_stream = st.session_state.stream_limit\n    if total_stream > limit_stream:\n            # UI Minimaliste (Tertiary)\n            if st.button(f\"\ud83d\udd03 Historique ({total_stream - limit_stream})\", key=\"load_more_stream\", type=\"tertiary\"):\n                st.session_state.stream_limit += 25\n                st.rerun()\n    \n    visible_stream = stream_msgs[max(0, total_stream - limit_stream):]\n    \n    if not visible_stream:\n        st.info(\"Aucune activit\u00e9 d\u00e9tect\u00e9e sur les bandes neurales.\")\n        \n    for real_idx, m in visible_stream:\n        sender = m.get(\"from\", \"?\")\n        target = m.get(\"target\", \"?\")\n        content = m.get(\"content\", \"\")\n        is_public = m.get(\"public\", False)\n        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        ", "start_line": 1081, "end_line": 1130}, {"path": "src/interface/app.py", "content": "        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        \n        # Style and Tag Logic\n        tag_html = \"\"\n        bubble_style = \"\"\n        \n        if is_public:\n            tag_html = ''\n            bubble_style = \"background-color: rgba(248, 249, 250, 0.8); border-left: 4px solid #2e7d32;\"\n        else:\n            if target == \"User\":\n                tag_html = '<span class=\"status-tag direct-tag\">\ud83d\udd12 Direct Link</span>'\n                if not is_replied:\n                    tag_html += '<span class=\"status-tag urgent-tag\">\u26a1 Action Required</span>'\n                    bubble_style = \"background-color: #fffdf0; border-left: 4px solid #fbc02d; box-shadow: 0 4px 12px rgba(251, 192, 45, 0.12);\"\n                else:\n                    bubble_style = \"background-color: #f0f7ff; border-left: 4px solid #1976d2;\"\n            elif sender == \"User\":\n                tag_html = f'<span class=\"status-tag\">\ud83d\udce4 Outgoing to {target}</span>'\n                bubble_style = \"background-color: #ffffff; border-left: 4px solid #94a3b8;\"\n            else:\n                tag_html = f'<span class=\"status-tag direct-tag\" style=\"background: #ffebee; color: #c62828;\">\ud83d\udd12 Private {sender} \u2192 {target}</span>'\n                bubble_style = \"background-color: #fff8f8; border: 2px dashed #ff4b4b;\"\n\n        with st.chat_message(sender, avatar=sender_emoji):\n            # Header with sender, target and status tags\n            c_header, c_action = st.columns([12, 1])\n            \n            with c_header:\n                st.markdown(f\"\"\"<div class=\"message-header\"><span style=\"font-weight: 700; color: #333; font-size: 0.9em;\">{sender}</span><span style=\"color: #999; font-size: 0.8em;\">\u2192</span><span class=\"target-badge\">{target if target != 'all' else 'everyone'}</span>{tag_html}<span style=\"color: #bbb; font-size: 0.7em; margin-left: auto;\">{time.strftime('%H:%M:%S', time.localtime(timestamp))}</span></div>\"\"\", unsafe_allow_html=True)\n            \n            with c_action:\n                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to", "start_line": 1121, "end_line": 1170}, {"path": "src/interface/app.py", "content": "                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to\n        col_banner, col_x = st.columns([11, 1])\n        with col_banner:\n            st.markdown(f'<div class=\"reply-banner-custom\">\u21a9\ufe0f R\u00e9ponse \u00e0 <b>{ctx[\"sender\"]}</b>: \"{ctx[\"preview\"]}\"</div>', unsafe_allow_html=True)\n        with col_x:\n            if st.button(\"\u2716\ufe0f\", key=\"cancel_reply_v6\", help=\"Annuler\"):\n                st.session_state.reply_to = None\n                st.rerun()\n\n    # 2. Status & Focus Row\n    # (No extra spacer here to avoid empty divs)\n    \n    # 2a. Typing Indicator (Centered)\n    typing_agents = []\n    current_turn_name = turn.get(\"current\")\n    for name, info in agents.items():\n        if name == \"User\": continue\n        if info.get(\"status\") == \"working\" or (name == current_turn_name and info.get(\"status\") == \"connected\"):\n            typing_agents.append(name)\n    \n    if typing_agents:\n        agent_names = \", \".join(typing_agents)\n        plural = \"sont\" if len(typing_agents) > 1 else \"est\"\n        st.markdown(f'<div class=\"typing-container\">{agent_names} {plural} en train d\\'\u00e9crire...<div class=\"typing-dots\"><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div></div></div>', unsafe_allow_html=True)\n    \n    # 2b. Focus Toggle (Removed)\n    c1, c2, c3 = st.columns([1, 1, 1])\n    \n    # MOVED: Banner in bottom right (c3)\n    if turn.get(\"current\") == \"User\":\n        with c3:\n            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n", "start_line": 1161, "end_line": 1210}, {"path": "src/interface/app.py", "content": "            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n\n    # Main Input\n    if prompt := st.chat_input(\"Message...\"):\n        def send_omni_msg(s):\n            target = None\n            public = True\n            reply_ref_id = None\n            \n            # Logic v2.0\n            \n            # 1. Context Reply (Strongest implicit) \n            # Tech Lead said: \"1. Si @Mention -> Priority. 2. Sinon si target_sel != Tous -> Target.\"\n            # Actually Context Reply usually overrides Selector visually, but Mention overrides all?\n            # Let's follow instruction:\n            # 1. Mention check\n            # 2. Selector check\n            # 3. Public\n            \n            found_mentions = []\n            found_mention = False\n            \n            # Mention Check (Specific Agents only)\n            known_agents = sorted(list(agents.keys()), key=len, reverse=True)\n            \n            # Use regex to find all mentions in order of appearance\n            # Sorting known_agents by length reverse ensures longer names are matched first\n            if known_agents:\n                pattern = \"@(\" + \"|\".join([re.escape(name) for name in known_agents]) + \")\"\n                matches = re.finditer(pattern, prompt)\n                seen = set()\n                for match in matches:\n                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True", "start_line": 1201, "end_line": 1250}, {"path": "src/interface/app.py", "content": "                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True\n            else:\n                audience = []\n            \n            if not found_mention:\n                if st.session_state.reply_to:\n                     # Reply Context overrides Selector\n                     target = st.session_state.reply_to[\"sender\"]\n                     reply_ref_id = st.session_state.reply_to[\"id\"]\n                     public = False\n                else:\n                    # No mention, no reply context -> Public Broadcast\n                    target = \"all\"\n                    public = True\n            \n            # Prepare content with Reply Context\n            final_content = prompt\n            if st.session_state.reply_to:\n                ref = st.session_state.reply_to\n                final_content = f\"\u21aa\ufe0f [R\u00e9ponse \u00e0 {ref['sender']}: \\\"{ref['preview']}\\\"]\\n{prompt}\"\n\n            msg = {\n                \"from\": \"User\",\n                \"content\": final_content,\n                \"timestamp\": time.time(),\n                \"public\": public,\n                \"audience\": audience\n            }\n            if target:\n                msg[\"target\"] = target\n            else:\n                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---", "start_line": 1241, "end_line": 1290}, {"path": "src/interface/app.py", "content": "                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---\n            if s.get(\"turn\", {}).get(\"current\") == \"User\":\n                next_speaker = None\n                if target and target != \"all\" and target in s.get(\"agents\", {}):\n                    next_speaker = target\n                else:\n                    # Priority 1: first_agent defined during reset\n                    first_pref = s.get(\"turn\", {}).get(\"first_agent\")\n                    if first_pref and first_pref in s.get(\"agents\", {}):\n                        next_speaker = first_pref\n                    else:\n                        # Fallback to the first connected agent\n                        connected = [n for n, d in s.get(\"agents\", {}).items() if d.get(\"status\") == \"connected\"]\n                        if connected:\n                            next_speaker = connected[0]\n                \n                if next_speaker:\n                    # USE CENTRALIZED TRANSITION LOGIC FROM ENGINE\n                    from src.core.logic import Engine\n                    engine = Engine(state_store) # Use the global state_store\n                    engine._finalize_turn_transition(s, next_speaker)\n\n            # Context Cleanup\n            if reply_ref_id is not None:\n                if reply_ref_id < len(s[\"messages\"]):\n                     s[\"messages\"][reply_ref_id][\"replied\"] = True\n                     \n            return \"Message Transmis.\"\n\n        res = state_store.update(send_omni_msg)\n        st.session_state.reply_to = None\n        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")", "start_line": 1281, "end_line": 1330}, {"path": "src/interface/app.py", "content": "        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")\n    \n    # --- 0. GRAPHVIZ VIEW (TOP) ---\n    with st.expander(\"\ud83d\udd78\ufe0f Topologie de la Flotte (Graphviz)\", expanded=False):\n        try:\n            g = render_graph(profiles)\n            st.graphviz_chart(g, use_container_width=True)\n        except Exception as e:\n            st.error(f\"Erreur de rendu du graphe : {e}\")\n\n    # Scenarios\n    st.subheader(\"\ud83d\udcbe Sc\u00e9narios\")\n    with st.container(border=True):\n        col_scen1, col_scen2 = st.columns(2)\n        if col_scen1.button(\"\ud83d\udcbe Sauvegarder\", use_container_width=True, help=\"Sauvegarder la configuration actuelle\"):\n            save_scenario_dialog(config)\n        if col_scen2.button(\"\ud83d\udcc2 Charger\", use_container_width=True, help=\"Charger une configuration existante\"):\n            load_scenario_dialog()\n\n    # Global Context (Full Width)\n    st.subheader(\"\ud83c\udf0d Contexte Global\")\n    with st.container(border=True):\n        enable_backlog = st.checkbox(\"Backlog\", value=config.get(\"enable_backlog\", False), help=\"Si coch\u00e9, les agents consulteront et mettront \u00e0 jour BACKLOG.md \u00e0 la racine.\")\n        if enable_backlog != config.get(\"enable_backlog\", False):\n            config[\"enable_backlog\"] = enable_backlog\n            save_config(config)\n            st.rerun()\n\n\n        global_context = st.text_area(\"Narratif / Contexte Partag\u00e9\", config.get(\"context\", \"\"), height=215)\n        if global_context != config.get(\"context\", \"\"):\n            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    ", "start_line": 1321, "end_line": 1370}, {"path": "src/interface/app.py", "content": "            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    \n    # Display cards in a grid\n    cols_per_row = 3\n    for i in range(0, len(profiles), cols_per_row):\n        cols = st.columns(cols_per_row)\n        for j in range(cols_per_row):\n            if i + j < len(profiles):\n                p = profiles[i + j]\n                with cols[j]:\n                    with st.container(border=True):\n                        count = int(p.get(\"count\", 0))\n                        emoji = p.get(\"emoji\", \"\ud83e\udd16\")\n                        description = p.get(\"description\", \"Aucune description.\")\n                        \n                        st.markdown(f\"\"\"<div class=\"agent-header\"><div class=\"agent-icon\">{emoji}</div><div class=\"agent-name\">{p['name']}</div></div><div class=\"agent-desc\">{description}</div>\"\"\", unsafe_allow_html=True)\n                        \n                        # Controls inside the card\n                        ctrl_c1, ctrl_c2, ctrl_c3 = st.columns([1, 1.2, 1])\n                        if ctrl_c1.button(\"\u2796\", key=f\"d_{i+j}\", use_container_width=True):\n                            p[\"count\"] = max(0, count - 1)\n                            save_config(config)\n                            st.rerun()\n                        \n                        ctrl_c2.markdown(f'<div class=\"count-display\">{count}</div>', unsafe_allow_html=True)\n                        \n                        if ctrl_c3.button(\"\u2795\", key=f\"i_{i+j}\", use_container_width=True):\n                            p[\"count\"] = count + 1\n                            save_config(config)\n                            st.rerun()\n                            \n                        if st.button(\"\u270f\ufe0f Modifier\", key=f\"ed_{i+j}\", use_container_width=True, type=\"secondary\"):\n                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    ", "start_line": 1361, "end_line": 1410}, {"path": "src/interface/app.py", "content": "                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    \n    # Calculate potential agent IDs the same way reset_logic does\n    temp_slots = []\n    for p in profiles:\n        for _ in range(int(p.get(\"count\", 0))):\n            temp_slots.append(p.get(\"display_name\") or p[\"name\"])\n            \n    counters = {}\n    for base in temp_slots:\n        counters.setdefault(base, 0)\n        counters[base] += 1\n        total_of_this_base = sum(1 for b in temp_slots if b == base)\n        agent_id = f\"{base} #{counters[base]}\" if total_of_this_base > 1 else base\n        potential_agents.append(agent_id)\n\n    # Use session state to persist choice\n    if \"first_speaker\" not in st.session_state:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    # Check if current choice is still valid (profiles might have changed)\n    if st.session_state.first_speaker not in potential_agents:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    selected_first = st.selectbox(\"Qui r\u00e9pondra en premier \u00e0 l'utilisateur ?\", potential_agents,\n                                 index=potential_agents.index(st.session_state.first_speaker) if st.session_state.first_speaker in potential_agents else 0,\n                                 help=\"L'agent qui aura le premier tour pour r\u00e9pondre au premier message de l'utilisateur.\")\n    st.session_state.first_speaker = selected_first\n\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n\n    # --- 3. RESET BUTTON (MODERN) ---\n    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context", "start_line": 1401, "end_line": 1450}, {"path": "src/interface/app.py", "content": "    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context\n                \n                # Use profiles from the state s for absolute consistency\n                current_profiles = s[\"config\"].get(\"profiles\", [])\n                \n                # Update total agents count\n                total_count = get_total_agents(current_profiles)\n                s[\"config\"][\"total_agents\"] = total_count\n                \n                pending_slots = []\n                # Remove random shuffle to maintain profile order\n                for p in current_profiles:\n                    for _ in range(int(p.get(\"count\", 0))):\n                        pending_slots.append({\n                            \"profile_ref\": p[\"name\"],\n                            \"role\": p.get(\"system_prompt\", \"\"),\n                            \"display_base\": p.get(\"display_name\") or p[\"name\"],\n                            \"emoji\": p.get(\"emoji\", \"\ud83e\udd16\")\n                        })\n                \n                new_agents = {}\n                counters = {}\n                for slot in pending_slots:\n                    base = slot[\"display_base\"]\n                    counters.setdefault(base, 0)\n                    counters[base] += 1\n                    agent_id = f\"{base} #{counters[base]}\" if sum(1 for sl in pending_slots if sl[\"display_base\"] == base) > 1 else base\n                    new_agents[agent_id] = {\n                        \"role\": slot[\"role\"], \"status\": \"pending_connection\",\n                        \"profile_ref\": slot[\"profile_ref\"], \"emoji\": slot[\"emoji\"]\n                    }\n                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"", "start_line": 1441, "end_line": 1490}, {"path": "src/interface/app.py", "content": "                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"\n            st.rerun()\n\n\n# ==========================================\n# PAGE: EDITOR (Admin)\n# ==========================================\nelif st.session_state.page == \"Editor\":\n    st.header(\"\ud83d\udee0\ufe0f \u00c9diteur d'Agents\")\n    \n    profile_names = [p[\"name\"] for p in profiles]\n    profile_names.append(\"\u2795 Create New\")\n    \n    sel_idx = 0\n    cur_edit = st.session_state.get(\"editing_agent_name\")\n    if cur_edit in profile_names:\n        sel_idx = profile_names.index(cur_edit)\n        \n    selected_name = st.selectbox(\"Selection Profil\", profile_names, index=sel_idx, key=\"edit_sel_page\")\n    \n    if selected_name == \"\u2795 Create New\":\n        current_profile = {\n            \"name\": \"New Agent\", \n            \"description\": \"\", \n            \"emoji\": \"\ud83e\udd16\", # Default, will be randomized in session state\n            \"connections\": [], \n            \"count\": 1, \n            \"capabilities\": [\"public\"]\n        }\n        new_mode = True\n        st.session_state.editing_agent_name = \"New Agent\"\n        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        ", "start_line": 1481, "end_line": 1530}, {"path": "src/interface/app.py", "content": "        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        \n        if st.button(\"\ud83d\uddd1\ufe0f Supprimer Profil\", type=\"primary\"):\n             config[\"profiles\"] = [p for p in profiles if p[\"name\"] != selected_name]\n             emoji_key = f\"editing_emoji_{selected_name}\"\n             if emoji_key in st.session_state:\n                 del st.session_state[emoji_key]\n             save_config(config)\n             st.rerun()\n\n    if current_profile:\n        st.markdown(\"---\")\n        # Layout Spacieux (Columns)\n        c_main, c_disp = st.columns([3, 2])\n        \n        with c_main:\n            c_emoji, c_name = st.columns([0.18, 0.82])\n            \n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key not in st.session_state:\n                st.session_state[emoji_key] = current_profile.get(\"emoji\", \"\ud83e\udd16\")\n            current_emoji = st.session_state[emoji_key]\n            \n            with c_emoji:\n                st.markdown('<div style=\"height: 28px;\"></div>', unsafe_allow_html=True) # Spacer to align with text input label\n                with st.popover(f\"{current_emoji}\", use_container_width=True):\n                    cols = st.columns(8)\n                    for idx, emoji in enumerate(EMOJI_LIST):\n                        if cols[idx % 8].button(emoji, key=f\"emoji_btn_{selected_name}_{idx}\"):\n                            st.session_state[emoji_key] = emoji\n                            st.rerun()\n            \n            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")", "start_line": 1521, "end_line": 1570}, {"path": "src/interface/app.py", "content": "            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")\n        caps = current_profile.get(\"capabilities\", [])\n        \n        # Preserve other capabilities (e.g. shell_exec)\n        other_caps = [c for c in caps if c not in [\"public\", \"private\"]]\n        \n        has_pub = \"public\" in caps\n        has_priv = \"private\" in caps\n        \n        # Determine default index\n        default_idx = 0 # Public\n        if has_pub and has_priv:\n            default_idx = 2 # Both\n        elif has_priv and not has_pub:\n            default_idx = 1 # Private\n        \n        comm_mode = st.radio(\n            \"Port\u00e9e de Communication\",\n            [\"Public\", \"Priv\u00e9\", \"Les Deux (Public & Priv\u00e9)\"],\n            index=default_idx,\n            key=f\"comm_mode_{selected_name}\",\n            horizontal=True,\n            help=\"D\u00e9finit la port\u00e9e de communication autoris\u00e9e pour cet agent.\"\n        )\n        \n        new_caps = list(other_caps)\n        if comm_mode == \"Public\":\n            new_caps.append(\"public\")\n        elif comm_mode == \"Priv\u00e9\":\n            new_caps.append(\"private\")\n        else:\n            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        ", "start_line": 1561, "end_line": 1610}, {"path": "src/interface/app.py", "content": "            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        \n        new_connections = []\n        \n        # Header for the \"Table\"\n        with st.container():\n            h1, h2, h3 = st.columns([2, 5, 1])\n            h1.markdown(\"**Cible**\")\n            h2.markdown(\"**Condition / Contexte**\")\n            h3.markdown(\"**Active**\")\n            st.markdown(\"<hr style='margin-top: 0; margin-bottom: 10px; border-color: #eee;'>\", unsafe_allow_html=True)\n        \n        for target in targets:\n            # Case-insensitive match for connections\n            existing_conn = next((c for c in current_profile.get(\"connections\", []) if c[\"target\"].lower() == target.lower()), None)\n            \n            c1, c2, c3 = st.columns([2, 5, 1])\n            \n            # Label\n            target_profile = next((p for p in profiles if p[\"name\"] == target), None)\n            target_emoji = \"\ud83c\udf10\" if target == \"public\" else \"\ud83d\udc64\" if target == \"User\" else (target_profile.get(\"emoji\", \"\ud83e\udd16\") if target_profile else \"\ud83e\udd16\")\n            c1.markdown(f\"{target_emoji} **{target}**\")\n            \n            default_ctx = existing_conn.get(\"context\", \"\") if existing_conn else \"\"\n            default_auth = existing_conn.get(\"authorized\", True) if existing_conn else False\n            \n            # Unique key with selected_name and target\n            ctx = c2.text_area(f\"Condition for {target}\", default_ctx, key=f\"conn_ctx_{selected_name}_{target}\", label_visibility=\"collapsed\", height=68)\n            auth = c3.checkbox(f\"Active for {target}\", default_auth, key=f\"conn_auth_{selected_name}_{target}\", label_visibility=\"collapsed\")\n            \n            if auth or ctx:\n                new_connections.append({\"target\": target, \"context\": ctx, \"authorized\": auth})\n            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            ", "start_line": 1601, "end_line": 1650}, {"path": "src/interface/app.py", "content": "            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            \n            # Use the emoji from session state\n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key in st.session_state:\n                current_profile[\"emoji\"] = st.session_state[emoji_key]\n                del st.session_state[emoji_key]\n            \n            if new_mode:\n                profiles.append(current_profile)\n            \n            # Smart renaming\n            if not new_mode and selected_name and new_name != selected_name:\n                for p in profiles:\n                    for conn in p.get(\"connections\", []):\n                        if conn.get(\"target\") == selected_name:\n                            conn[\"target\"] = new_name\n            \n            save_config(config)\n            st.toast(\"Saved!\")\n            st.rerun()\n\n# --- GLOBAL INJECTION (Fixed by Anais) ---\nif st.session_state.page == \"Communication\":\n    # Ensure mentions are injected even if logic flow was broken\n    active_names = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    inject_mention_system(active_names)", "start_line": 1641, "end_line": 1675}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n## \u2705 Done\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 23}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n## \u2705 Done\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 23}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Ajustement seuils recherche passive (Feedback Vir)\n\n## \u2705 Done\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 26}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Ajustement seuils recherche passive (Feedback Vir)\n\n## \u2705 Done\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 26}, {"path": "src/interface/app.py", "content": "import streamlit as st\nimport streamlit.components.v1 as components\nfrom streamlit_autorefresh import st_autorefresh\nimport graphviz\nimport json\nimport uuid\nimport sys\nimport os\nimport time\nimport re\nimport shutil\nfrom pathlib import Path\n\n# Add src to path to allow imports if run directly\nfrom pathlib import Path\nimport sys\nimport os\n\nCODE_ROOT = Path(__file__).resolve().parent.parent.parent\nif str(CODE_ROOT) not in sys.path:\n    sys.path.append(str(CODE_ROOT))\n\nfrom src.config import (\n    STATE_FILE, \n    MEMORY_DIR, \n    TEMPLATE_DIR, \n    LOCAL_DATA_DIR, \n    GLOBAL_PRESET_DIR, \n    ASSETS_DIR,\n    CODE_ROOT as CONFIG_CODE_ROOT,\n    RELOAD_INSTRUCTION\n)\nfrom src.core.state import StateStore\nfrom src.services.search_engine import SearchEngine\n\nst.set_page_config(page_title=\"Agent Orchestra\", page_icon=\"\ud83e\udd16\", layout=\"wide\")\n\n# --- EMOJI LIST ---\nEMOJI_LIST = [\n    \"\ud83e\udd16\", \"\ud83e\udde0\", \"\ud83d\udd75\ufe0f\", \"\ud83e\uddb8\", \"\ud83e\udd77\", \"\ud83e\uddd9\", \"\ud83e\udddb\", \"\ud83e\udddf\", \"\ud83e\uddde\", \"\ud83e\udddd\",\n    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",", "start_line": 1, "end_line": 50}, {"path": "src/interface/app.py", "content": "    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",\n    \"\ud83e\udda1\", \"\ud83e\udda6\", \"\ud83e\udda5\", \"\ud83d\udc01\", \"\ud83d\udc00\", \"\ud83d\udc3f\ufe0f\", \"\ud83e\udd94\", \"\ud83d\udc3e\", \"\ud83d\udc09\", \"\ud83d\udc32\",\n    \"\ud83c\udf35\", \"\ud83c\udf84\", \"\ud83c\udf32\", \"\ud83c\udf33\", \"\ud83c\udf34\", \"\ud83c\udf31\", \"\ud83c\udf3f\", \"\u2618\ufe0f\", \"\ud83c\udf40\", \"\ud83c\udf43\"\n]\n\ndef get_random_emoji():\n    import random\n    return random.choice(EMOJI_LIST)\n\n# --- HELPER FUNCTIONS ---\ndef inject_custom_css():\n    st.markdown(\"\"\"<style>\n    /* Global message container */\n    [data-testid=\"stChatMessage\"] {\n        padding: 1rem !important;\n        margin-bottom: 1.5rem !important;\n    }\n    \n    [data-testid=\"stChatMessage\"] [data-testid=\"stVerticalBlock\"] {\n        gap: 12px !important;\n    }\n\n    /* Header layout inside message */\n    .message-header {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        margin-bottom: 8px;\n        opacity: 0.85;\n    }\n\n    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    ", "start_line": 41, "end_line": 90}, {"path": "src/interface/app.py", "content": "    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    \n    .reply-banner-custom {\n        background: #f0f7ff;\n        border: 1px solid #d0e7ff;\n        border-radius: 10px;\n        padding: 8px 15px;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        margin-bottom: 8px;\n        font-size: 0.85em;\n        box-shadow: 0 2px 8px rgba(0,0,0,0.05);\n    }\n\n    /* Premium Toggle Styling (Targeting the specific widget) */\n    div[data-testid=\"stToggle\"] {\n        background: #ffffff;\n        padding: 10px 24px !important;\n        border-radius: 50px !important;\n        border: 1px solid #ff4b4b22 !important;\n        box-shadow: 0 4px 15px rgba(0,0,0,0.06) !important;\n        transition: all 0.3s ease !important;\n        width: fit-content !important;\n        margin: 10px auto !important;\n    }\n    \n    div[data-testid=\"stToggle\"]:hover {\n        border-color: #ff4b4b !important;\n        box-shadow: 0 6px 20px rgba(255,75,75,0.12) !important;\n        transform: translateY(-1px);\n    }\n\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;", "start_line": 81, "end_line": 130}, {"path": "src/interface/app.py", "content": "\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;\n        gap: 12px !important;\n        margin: 0 !important;\n    }\n\n    div[data-testid=\"stToggle\"] label p {\n        font-weight: 700 !important;\n        font-size: 0.95em !important;\n        color: #1a1a1a !important;\n        margin: 0 !important;\n        letter-spacing: -0.2px !important;\n    }\n    \n    .target-badge {\n        font-weight: 600;\n        padding: 1px 6px;\n        border-radius: 4px;\n        font-size: 0.75em;\n        color: #444;\n        background: rgba(0,0,0,0.08);\n        border: 1px solid rgba(0,0,0,0.1);\n    }\n    \n    .status-tag {\n        font-size: 0.7em;\n        font-weight: 700;\n        padding: 1px 5px;\n        border-radius: 4px;\n        text-transform: uppercase;\n        letter-spacing: 0.5px;\n    }\n    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;", "start_line": 121, "end_line": 170}, {"path": "src/interface/app.py", "content": "    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        padding: 6px 16px;\n        color: #666;\n        font-size: 0.85em;\n        font-style: italic;\n        background: rgba(0,0,0,0.03);\n        border-radius: 20px;\n        margin: 10px auto;\n        width: fit-content;\n        border: 1px solid rgba(0,0,0,0.05);\n        box-shadow: 0 2px 4px rgba(0,0,0,0.02);\n    }\n    .typing-dots {\n        display: flex; gap: 4px; margin-left: 8px;\n    }\n    .typing-dot {\n        width: 5px; height: 5px; background: #999; border-radius: 50%;\n        animation: typing-bounce 1.4s infinite ease-in-out;\n    }\n    .typing-dot:nth-child(1) { animation-delay: -0.32s; }\n    .typing-dot:nth-child(2) { animation-delay: -0.16s; }\n    @keyframes typing-bounce {\n        0%, 80%, 100% { transform: translateY(0); opacity: 0.3; }\n        40% { transform: translateY(-3px); opacity: 1; }\n    }\n    </style>\"\"\", unsafe_allow_html=True)\n\ninject_custom_css()\n\n# --- INITIALIZE STATE (ONCE) ---\nstate_store = StateStore()\n\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n", "start_line": 161, "end_line": 210}, {"path": "src/interface/app.py", "content": "\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n\ndef save_config(new_config):\n    def update_fn(s):\n        s[\"config\"] = new_config\n        return \"Config Saved\"\n    state_store.update(update_fn)\n\n\n# --- SEARCH ENGINE INIT ---\n@st.cache_resource\ndef init_search_engine():\n    engine = SearchEngine()\n    # Ensure directory exists for persist\n    persist = LOCAL_DATA_DIR / \"vector_store\"\n    persist.mkdir(parents=True, exist_ok=True)\n    engine.initialize(root_dir=CODE_ROOT, persist_dir=persist)\n    return engine\n\n# Initialize background service\nsearch_engine = init_search_engine()\n\n\n# --- DIALOGS ---\ndef handle_disconnect_agent(agent_name):\n    \"\"\"\n    Sets the reload_active flag for the agent.\n    Does NOT set 'pending_connection' immediately (Agent must do it via disconnect tool).\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = True\n            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }", "start_line": 201, "end_line": 250}, {"path": "src/interface/app.py", "content": "            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }\n            s.setdefault(\"messages\", []).append(msg)\n            \n        return f\"Signal de rechargement envoy\u00e9 \u00e0 : {agent_name}\"\n    \n    state_store.update(update_fn)\n    st.toast(f\"Reload signal sent to {agent_name} \ud83d\udd01\")\n\ndef force_disconnect_agent(agent_name):\n    \"\"\"\n    Forces status to pending_connection immediately.\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = False # Reset flag\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n        return f\"Force disconnect: {agent_name}\"\n    state_store.update(update_fn)\n    st.toast(f\"\u2620\ufe0f Force Disconnect: {agent_name}\")\n\nPRESET_DIR = GLOBAL_PRESET_DIR\n\n@st.dialog(\"Sauvegarder le Sc\u00e9nario\")\ndef save_scenario_dialog(current_config):\n    save_name = st.text_input(\"Nom de Sauvegarde\", placeholder=\"mon_scenario\")\n    if st.button(\"Confirmer la Sauvegarde\", use_container_width=True):\n        if save_name:\n            # Basic filename cleaning\n            filename = \"\".join([c for c in save_name if c.isalnum() or c in (' ', '.', '_', '-')]).rstrip()\n            path = PRESET_DIR / f\"{filename}.json\"\n            with open(path, \"w\") as f:\n                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")", "start_line": 241, "end_line": 290}, {"path": "src/interface/app.py", "content": "                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")\n                except Exception as e:\n                    # Non-blocking, just dev convenience\n                    print(f\"Failed to sync to repo: {e}\")\n            st.success(f\"Sauvegard\u00e9 : {filename}\")\n            time.sleep(1)\n            st.rerun()\n        else:\n            st.error(\"Veuillez entrer un nom.\")\n\n@st.dialog(\"Charger un Sc\u00e9nario\")\ndef load_scenario_dialog():\n    # Unified Source: User Global Presets\n    # (Defaults have been synced here by sync_presets)\n    presets = sorted([f for f in os.listdir(PRESET_DIR) if f.endswith(\".json\")])\n    \n    if not presets:\n        st.warning(\"Aucun sc\u00e9nario trouv\u00e9.\")\n        return\n\n    options = [f\"\ud83d\udcbe {f}\" for f in presets]\n    path_map = {f\"\ud83d\udcbe {f}\": PRESET_DIR / f for f in presets}\n        \n    selected_label = st.selectbox(\"Choisir un Preset\", options)\n    \n    c_load, c_del = st.columns([0.85, 0.15])\n    \n    with c_load:\n        if st.button(\"Charger la Configuration\", use_container_width=True, type=\"primary\"):\n            if selected_label:\n                path = path_map[selected_label]\n                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)", "start_line": 281, "end_line": 330}, {"path": "src/interface/app.py", "content": "                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)\n                st.rerun()\n                \n    with c_del:\n        if st.button(\"\ud83d\uddd1\ufe0f\", key=\"del_scen_btn\", help=\"Supprimer d\u00e9finivement\", use_container_width=True):\n             if selected_label:\n                 path = path_map[selected_label]\n                 try:\n                     os.remove(path)\n                     st.toast(f\"Sc\u00e9nario supprim\u00e9: {selected_label}\")\n                     time.sleep(0.7)\n                     st.rerun()\n                 except Exception as e:\n                     st.error(f\"Erreur: {e}\")\n\ndef get_total_agents(profiles):\n    total = 0\n    for p in profiles:\n        try:\n            total += int(p.get(\"count\", 0))\n        except:\n            pass\n    return total\n\ndef format_mentions(text):\n    if not text: return text\n    \n    # 1. First decorate @everyone\n    text = re.sub(\n        r'(@everyone)',\n        r'<span style=\"color: #ffffff; background-color: #ff4b4b; padding: 2px 8px; border-radius: 6px; font-weight: 700; font-size: 0.9em; box-shadow: 0 2px 4px rgba(255,75,75,0.3);\">\\1</span>',\n        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )", "start_line": 321, "end_line": 370}, {"path": "src/interface/app.py", "content": "        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )\n\ndef render_graph(profiles, current_editing=None):\n    graph = graphviz.Digraph()\n    graph.attr(rankdir='LR', size='12,2', ratio='fill', bgcolor='transparent', margin='0')\n    \n    # Add User node\n    graph.node(\"User\", label=\"\ud83d\udc64 User\", style='filled', fillcolor='lightgrey', shape='circle', fontsize='10', height='0.5')\n    \n    for p in profiles:\n        name = p[\"name\"]\n        color = 'lightblue'\n        if current_editing and name == current_editing:\n            color = 'gold'\n        count = p.get(\"count\", 0)\n        label = f\"{name}\\n(x{count})\"\n        graph.node(name, label=label, style='filled', fillcolor=color, shape='box', fontsize='10', height='0.5')\n\n    for p in profiles:\n        source = p[\"name\"]\n        for conn in p.get(\"connections\", []):\n            target = conn.get(\"target\")\n            is_auth = conn.get(\"authorized\", True)\n            if is_auth and (target == \"User\" or any(prof[\"name\"] == target for prof in profiles)):\n                graph.edge(source, target, fontsize='8', color='gray', arrowsize='0.5')\n    return graph\n\ndef inject_mention_system(agent_names):\n    import json\n    agents_json = json.dumps(agent_names)\n    \n    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;", "start_line": 361, "end_line": 410}, {"path": "src/interface/app.py", "content": "    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;\n            const textarea = doc.querySelector('textarea[data-testid=\"stChatInputTextArea\"]');\n            \n            if (!textarea) {{\n                // Polled by setInterval, so just return\n                return;\n            }}\n\n            // Cleanup previous interaction from this or previous iframes\n            // We use a custom property on the DOM node to store the controller\n            if (textarea._mentionController) {{\n                // If the controller belongs to a DEAD iframe, this might fail or succeed. \n                // But mostly it allows us to signal \"Stop Listing\".\n                try {{\n                    textarea._mentionController.abort();\n                }} catch(e) {{}}\n            }}\n\n            // Create new controller for this instance\n            const controller = new AbortController();\n            textarea._mentionController = controller;\n            const signal = controller.signal;\n\n            let menu = doc.getElementById('mention-menu');\n            if (!menu) {{\n                menu = doc.createElement('div');\n                menu.id = 'mention-menu';\n                Object.assign(menu.style, {{\n                    display: 'none',\n                    position: 'fixed',\n                    background: 'white',\n                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);", "start_line": 401, "end_line": 450}, {"path": "src/interface/app.py", "content": "                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);\n            }}\n\n            // Inject styles\n            if (!doc.getElementById('mention-styles')) {{\n                const style = doc.createElement('style');\n                style.id = 'mention-styles';\n                style.innerHTML = `\n                    .mention-item:hover {{\n                        background-color: #f0f2f6 !important;\n                    }}\n                `;\n                doc.head.appendChild(style);\n            }}\n\n            textarea.addEventListener('input', (e) => {{\n                if (e.isComposing) return;\n                const value = textarea.value;\n                const cursorPos = textarea.selectionStart;\n                const textBeforeCursor = value.substring(0, cursorPos);\n                const mentionMatch = textBeforeCursor.match(/@([\\\\w\\\\s#]*)$/);\n\n                if (mentionMatch) {{\n                    isVisible = true;\n                    currentFilter = mentionMatch[1].toLowerCase();\n                    renderMenu(textarea);\n                }} else {{\n                    hideMenu();\n                }}\n            }}, {{ signal }});\n\n            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;", "start_line": 441, "end_line": 490}, {"path": "src/interface/app.py", "content": "            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'ArrowUp') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex - 1 + filtered.length) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'Enter' || e.key === 'Tab') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    insertMention(textarea, filtered[selectedIndex]);\n                }} else if (e.key === 'Escape') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    hideMenu();\n                }}\n            }}, {{ capture: true, signal: signal }});\n        }}\n\n        function renderMenu(textarea) {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n            \n            if (filtered.length === 0) {{\n                hideMenu();\n                return;\n            }}\n\n            menu.innerHTML = filtered.map((a, i) => `\n                <div class=\"mention-item\" style=\"\n                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">", "start_line": 481, "end_line": 530}, {"path": "src/interface/app.py", "content": "                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">\n                    <span style=\"font-weight: ${{i === selectedIndex ? '600' : '400'}};\">@${{a}}</span>\n                    ${{a === 'everyone' ? '<span style=\"font-size: 10px; background: #ff4b4b; color: white; padding: 1px 4px; border-radius: 4px; margin-left: 5px;\">PUBLIC</span>' : ''}}\n                </div>\n            `).join('');\n\n            const rect = textarea.getBoundingClientRect();\n            menu.style.display = 'block';\n            menu.style.left = rect.left + 'px';\n            \n            // Position above the textarea\n            menu.style.bottom = (window.parent.innerHeight - rect.top + 10) + 'px';\n            isVisible = true;\n        }}\n\n        function insertMention(textarea, name) {{\n            const value = textarea.value;\n            const cursorPos = textarea.selectionStart;\n            const textBeforeCursor = value.substring(0, cursorPos);\n            const textAfterCursor = value.substring(cursorPos);\n            \n            const newTextBefore = textBeforeCursor.replace(/@([\\\\w\\\\s#]*)$/, '@' + name + ' ');\n            const newValue = newTextBefore + textAfterCursor;\n\n            // Robust React state update\n            const nativeTextareaValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, \"value\").set;\n            nativeTextareaValueSetter.call(textarea, newValue);\n            \n            // Trigger events\n            textarea.dispatchEvent(new Event('input', {{ bubbles: true }}));\n            textarea.dispatchEvent(new Event('change', {{ bubbles: true }}));\n\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{", "start_line": 521, "end_line": 570}, {"path": "src/interface/app.py", "content": "\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            if (menu) menu.style.display = 'none';\n            isVisible = false;\n            selectedIndex = 0;\n        }}\n\n        // Initial setup & Polling for re-mounts\n        setInterval(setupMentions, 1000);\n    }})();\n    </script>\n    \"\"\"\n    components.html(components_code, height=0)\n\n# --- MAIN LOGIC ---\n\n# 1. Load Data\nstate, config = load_config()\ndata = state\nprofiles = config.get(\"profiles\", [])\nagents = data.get(\"agents\", {})\nturn = data.get(\"turn\", {})\nmessages = data.get(\"messages\", [])\n\n# --- CSS STYLING ---\nst.markdown(\"\"\"\n<style>\n    div[data-testid=\"stSidebar\"] {\n        background-color: #f0f2f6;\n    }\n    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;", "start_line": 561, "end_line": 610}, {"path": "src/interface/app.py", "content": "    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;\n    }\n    /* Agent Card Styling */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] {\n        background-color: white;\n        border-radius: 16px !important;\n        border: 1px solid #f0f0f0 !important;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.04);\n        padding: 0.5rem;\n        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    }\n    [data-testid=\"stVerticalBlockBorderWrapper\"]:hover {\n        transform: translateY(-4px);\n        box-shadow: 0 12px 24px rgba(0,0,0,0.08);\n        border-color: #ff4b4b44 !important;\n    }\n    .agent-header {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 12px;\n    }\n    .agent-icon {\n        font-size: 1.5em;\n        background: #f8f9fa;\n        width: 42px;\n        height: 42px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 10px;\n        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;", "start_line": 601, "end_line": 650}, {"path": "src/interface/app.py", "content": "        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;\n        color: #64748b;\n        margin-bottom: 1rem;\n        min-height: 4.2em;\n        line-height: 1.5;\n    }\n    .count-display {\n        background: #f1f5f9;\n        color: #0f172a;\n        height: 2.4em;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 8px;\n        font-weight: 700;\n        font-size: 1.1em;\n    }\n    /* Compact buttons in cards */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] .stButton button {\n        height: 2.4em !important;\n    }\n    .reset-button-container {\n        display: flex;\n        justify-content: center;\n        padding: 20px;\n    }\n    @keyframes pulse-gold {\n        0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }\n        70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }\n        100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }\n    }\n    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:", "start_line": 641, "end_line": 690}, {"path": "src/interface/app.py", "content": "    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:\n    st.session_state.page = \"Communication\"\n\n# --- SIDEBAR ---\nwith st.sidebar:\n    st.title(\"\ud83e\udd16 Orchestra\")\n    \n    # Global Autorefresh (Active on all pages to catch messages)\n    st_autorefresh(interval=4000, key=\"global_pulse\")\n\n    st.markdown(\"### Navigation\")\n    \n    # --- NOTIFICATION LOGIC ---\n    total_msgs = len(messages)\n    if \"last_read_count\" not in st.session_state:\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    unread = 0\n    if st.session_state.page != \"Communication\":\n        unread = max(0, total_msgs - st.session_state.last_read_count)\n        \n        # Toast for new messages\n        if \"last_toast_count\" not in st.session_state:\n             st.session_state.last_toast_count = total_msgs\n             \n        if total_msgs > st.session_state.last_toast_count:\n             new_count = total_msgs - st.session_state.last_toast_count\n             # Toast the last one\n             newest = messages[-1]\n             sender = newest.get(\"from\", \"?\")\n             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"", "start_line": 681, "end_line": 730}, {"path": "src/interface/app.py", "content": "             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"\n    if unread > 0:\n        label_comm = f\"\ud83d\udcac Chat ({unread} \ud83d\udd34)\"\n\n    if st.button(label_comm, use_container_width=True, type=\"primary\" if st.session_state.page == \"Communication\" else \"secondary\"):\n        st.session_state.page = \"Communication\"\n        st.rerun()\n        \n    if st.button(\"\ud83c\udf9b\ufe0f Cockpit\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Cockpit\" else \"secondary\"):\n        st.session_state.page = \"Cockpit\"\n        st.rerun()\n        \n    if st.button(\"\ud83d\udee0\ufe0f \u00c9diteur\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Editor\" else \"secondary\"):\n        st.session_state.page = \"Editor\"\n        st.rerun()\n\n    st.divider()\n    \n    # 1. Identity / User Status\n    st.markdown(\"### \ud83d\udc64 Identity\")\n    user_status = config.get(\"user_availability\", \"busy\")\n    \n    # User status toggle\n    is_available = st.toggle(\"Available\", value=(user_status == \"available\"), help=\"Switch between Available (\ud83d\udfe2) and Busy (\ud83d\udd34)\")\n    new_status = \"available\" if is_available else \"busy\"\n    \n    if new_status != user_status:\n        config[\"user_availability\"] = new_status\n        save_config(config)\n        st.rerun()\n\n    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:", "start_line": 721, "end_line": 770}, {"path": "src/interface/app.py", "content": "    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:\n        config[\"language\"] = new_lang\n        save_config(config)\n        st.rerun()\n\n\n\n    st.divider()\n    \n    # Search Config\n    st.markdown(\"### \ud83d\udd0e Search Engine\")\n    \n    # Status Indicator\n    if search_engine and search_engine.initialized:\n        dev_label = search_engine.device.upper().replace(\"\u201d\", \"\") # Fix typo if any from previous edit\n        st.caption(f\"Status: **Active** | Device: **{dev_label}** \u26a1\")\n    else:\n        st.caption(\"Status: \ud83d\udd34 Disabled (Missing Deps)\")\n\n    search_conf = config.get(\"search\", {})\n    \n    sc1, sc2 = st.columns(2)\n    with sc1:\n        x_val = st.number_input(\"Context (X)\", min_value=0, max_value=10, value=search_conf.get(\"x_markdown\", 2), help=\"Number of full markdown result to inject (Passive)\")\n    with sc2:\n        y_val = st.number_input(\"Total (Y)\", min_value=1, max_value=50, value=search_conf.get(\"y_total\", 5), help=\"Default limit for Search Tool\")\n        \n    if x_val != search_conf.get(\"x_markdown\", 3) or y_val != search_conf.get(\"y_total\", 15):\n        if \"search\" not in config: config[\"search\"] = {}\n        config[\"search\"][\"x_markdown\"] = x_val\n        config[\"search\"][\"y_total\"] = y_val\n        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"", "start_line": 761, "end_line": 810}, {"path": "src/interface/app.py", "content": "        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"\n        <div style=\"display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;\">\n            <h3 style=\"margin: 0; font-size: 1.2em;\">\ud83d\udc65 Agents Actifs</h3>\n            <span style=\"background: #e0e0e0; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold;\">{connected_count}</span>\n        </div>\n    \"\"\", unsafe_allow_html=True)\n    \n    # Maintain original order from agents dictionary\n    roster_list = [name for name in agents.keys()]\n    \n    # Explicitly add User to the top\n    roster_list.insert(0, \"User\")\n    \n    current_turn = turn.get(\"current\")\n    \n    if not roster_list:\n        st.caption(\"Aucun agent d\u00e9tect\u00e9.\")\n    else:\n        for name in roster_list:\n            # Handle User specifically since they are not in 'agents' dict\n            if name == \"User\":\n                u_avail = config.get(\"user_availability\", \"busy\")\n                # Map 'available' -> 'connected' (Green), 'busy' -> 'working' (Blue/Busy look)\n                info = {\n                    \"status\": \"connected\" if u_avail == \"available\" else \"working\",\n                    \"emoji\": \"\ud83d\udc64\"\n                }\n            else:\n                info = agents[name]\n            status = info.get(\"status\", \"pending\")\n            emoji = info.get(\"emoji\", \"\ud83e\udd16\")\n            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":", "start_line": 801, "end_line": 850}, {"path": "src/interface/app.py", "content": "            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":\n                status_color = \"#4CAF50\" # Green\n                status_label = \"En ligne\"\n                bg = \"rgba(76, 175, 80, 0.05)\"\n                border_color = \"rgba(76, 175, 80, 0.2)\"\n            elif status == \"pending_connection\":\n                status_color = \"#FF9800\" # Orange\n                status_label = \"Attente Reconnexion\"\n                bg = \"rgba(255, 152, 0, 0.05)\"\n                border_color = \"rgba(255, 152, 0, 0.2)\"\n            elif status == \"working\":\n                status_color = \"#2196F3\" # Blue\n                status_label = \"Travaille...\"\n                bg = \"rgba(33, 150, 243, 0.05)\"\n                border_color = \"rgba(33, 150, 243, 0.2)\"\n            else:\n                status_color = \"#9E9E9E\" # Grey\n                status_label = \"Hors-ligne\"\n                bg = \"transparent\"\n                border_color = \"#eee\"\n            \n            # Additional pulse if it's their turn and they are connected\n            is_active_working = is_turn and status == \"connected\"\n            if is_active_working:\n                status_color = \"#2196F3\"\n                status_label = \"En action...\"\n            \n            card_html = f\"\"\"<div class=\"{card_class}\" style=\"background-color: {bg}; border: 1px solid {border_color}; border-radius: 10px; padding: 10px 14px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s ease;\"><div style=\"display: flex; align-items: center; gap: 12px;\"><div style=\"font-size: 1.4em; background: white; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);\">{emoji}</div><div style=\"display: flex; flex-direction: column;\"><span style=\"font-weight: 600; color: {'#1a1a1a' if status == 'connected' else '#666'}; font-size: 0.95em;\">{name}</span><div style=\"display: flex; align-items: center; gap: 4px;\"><div style=\"width: 6px; height: 6px; background-color: {status_color}; border-radius: 50%;\"></div><span style=\"font-size: 0.7em; color: {status_color}; font-weight: 500; letter-spacing: 0.5px;\">{status_label}</span></div></div></div>{'<span style=\"font-size: 1.2em;\" title=\"C&rsquo;est son tour !\">\u2728</span>' if is_turn else ''}</div>\"\"\"\n            \n            if name == \"User\":\n                st.markdown(card_html, unsafe_allow_html=True)\n            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))", "start_line": 841, "end_line": 890}, {"path": "src/interface/app.py", "content": "            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))\n\n                    if is_reloading:\n                        if st.button(\"\u274c\", key=f\"force_{name}\", help=\"Force Disconnect (Si bloqu\u00e9)\", type=\"primary\"):\n                             force_disconnect_agent(name)\n                             # Also remove from queue if present to unblock sequence\n                             if name in st.session_state.get(\"reload_queue\", []):\n                                 st.session_state.reload_queue.remove(name)\n                             st.rerun()\n                    else:\n                        if st.button(\"\ud83d\udd04\", key=f\"reload_{name}\", help=f\"Recharger {name}\"):\n                            handle_disconnect_agent(name)\n                            st.rerun()\n            \n    st.markdown(\"<div style='height: 10px;'></div>\", unsafe_allow_html=True)\n    if st.button(\"\ud83d\udd04 Reload All Agents\", type=\"secondary\", use_container_width=True, help=\"S\u00e9quence de rechargement (Parall\u00e8le).\"):\n         # Identify Targets\n        to_reload = [\n            n for n, d in agents.items() \n            if d.get(\"status\") in [\"connected\", \"working\"] \n        ]\n        if not to_reload:\n            st.toast(\"Aucun agent actif \u00e0 recharger.\")\n        else:\n            # START PARALLEL SEQUENCE\n            st.session_state.reload_queue = list(to_reload)\n            \n            # Atomic Bulk Update\n            def bulk_reload_signal(s):\n                count = 0\n                for name in to_reload:\n                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,", "start_line": 881, "end_line": 930}, {"path": "src/interface/app.py", "content": "                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,\n                            \"target\": name,\n                            \"timestamp\": time.time()\n                         }\n                         s.setdefault(\"messages\", []).append(msg)\n                         count += 1\n                return f\"Signal de rechargement global envoy\u00e9 ({count} agents).\"\n            \n            state_store.update(bulk_reload_signal)\n            st.toast(f\"S\u00e9quence de rechargement PARALL\u00c8LE initialis\u00e9e pour {len(to_reload)} agents.\")\n            st.rerun()\n\n    # --- SEQUENTIAL RELOAD PROCESSOR ---\n    # Global Processor for the Queue\n    if \"reload_queue\" in st.session_state and st.session_state.reload_queue:\n        current_target = st.session_state.reload_queue[0]\n        \n        # Check current status (Refetch from fresh state)\n        if current_target in agents:\n            agent_data = agents[current_target]\n            status = agent_data.get(\"status\")\n            is_reload_active = agent_data.get(\"reload_active\")\n            \n            # Condition 1: Agent is finished (Disconnect/Pending)\n            if status in [\"pending_connection\", \"disconnected\", \"offline\"]:\n                st.session_state.reload_queue.pop(0) # Done\n                st.rerun() # Proceed to next immediately\n                \n            # Condition 2: Agent needs to be signaled\n            elif not is_reload_active:\n                 handle_disconnect_agent(current_target)\n                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()", "start_line": 921, "end_line": 970}, {"path": "src/interface/app.py", "content": "                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()\n\n    st.divider()\n\n    # --- PAUSE CONTROL ---\n    is_paused = config.get(\"paused\", False)\n    if st.toggle(\"\u23f8\ufe0f PAUSE MCP\", value=is_paused, help=\"Fige le temps pour tous les agents.\"):\n        if not is_paused:\n            config[\"paused\"] = True\n            save_config(config)\n            st.rerun()\n    else:\n        if is_paused:\n            config[\"paused\"] = False\n            save_config(config)\n            st.rerun()\n            \n    if is_paused:\n        st.warning(\"\u26a0\ufe0f SIMULATION EN PAUSE\")\n    \n    st.divider()\n\n    \n    # Debug Tools\n    with st.expander(\"\ud83d\udd27 DEBUG\"):\n        st.markdown(\"### \u2702\ufe0f MCP Truncation Settings\")\n        current_trunc = config.get(\"truncation_limit\", 4096) # Default 4096\n        new_trunc = st.number_input(\"Max Character Limit (0 = Disabled)\", min_value=0, value=int(current_trunc), step=100, help=\"Limite manuelle pour \u00e9viter le tronquage silencieux du client MCP (4096 bytes max).\")\n        if new_trunc != current_trunc:\n             config[\"truncation_limit\"] = int(new_trunc)\n             save_config(config)\n             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)", "start_line": 961, "end_line": 1010}, {"path": "src/interface/app.py", "content": "             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)\n                    server_script = os.path.join(current_dir, \"src\", \"core\", \"server.py\")\n                    command_str = f\"cd {current_dir} && uv run python {server_script}\"\n                    if \"mcpServers\" not in json_data:\n                        json_data[\"mcpServers\"] = {}\n                    json_data[\"mcpServers\"][\"multi-agents-mcp\"] = {\n                        \"command\": \"sh\",\n                        \"args\": [\"-c\", command_str],\n                        \"env\": {}\n                    }\n                    with open(config_path, \"w\") as f:\n                        json.dump(json_data, f, indent=2)\n                    st.success(\"Config Path Updated\")\n            except Exception as e:\n                st.error(str(e))\n\n        if st.button(\"Delete Memories\"):\n            try:\n                mem_dir = str(MEMORY_DIR)\n                if os.path.exists(mem_dir):\n                    import shutil\n                    shutil.rmtree(mem_dir)\n                    os.makedirs(mem_dir, exist_ok=True)\n                    st.success(\"Memories Cleared\")\n            except Exception as e:\n                st.error(str(e))\n\n\n# ==========================================\n# PAGE: COMMUNICATION (Chat)\n# ==========================================\nif st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":", "start_line": 1001, "end_line": 1050}, {"path": "src/interface/app.py", "content": "if st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":\n            # FOCUS MODE STYLES\n            st.markdown(\"\"\"\n            <style>\n            /* Gray out previous messages to focus on input */\n            .stChatMessage { opacity: 0.5; filter: grayscale(0.6); transition: all 0.3s; }\n            /* Highlight Input Area */\n            div[data-testid=\"stChatInput\"] { \n                border: 2px solid #ff3d00 !important; \n                border-radius: 12px;\n                box-shadow: 0 0 15px rgba(255, 61, 0, 0.4) !important;\n                background-color: #fff8f5 !important;\n            }\n            </style>\n            \"\"\", unsafe_allow_html=True)\n            \n\n        else:\n            st.markdown(f\"\"\"<div style=\"background-color: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; border-radius: 8px; text-align: center;\"><span style=\"color: #6c757d; font-size: 0.9em;\">En attente de :</span><br><span style=\"color: #1f1f1f; font-weight: bold; font-size: 1.1em;\">\ud83e\udd16 {current_turn}</span></div>\"\"\", unsafe_allow_html=True)\n    \n    # 1. Reply Context State\n    if \"reply_to\" not in st.session_state:\n        st.session_state.reply_to = None\n\n    # --- FLUX NEURAL (FULL WIDTH) ---\n    \n    # Helper for rendering messages and reply buttons\n    def render_reply_button(sender, content, idx):\n        if st.button(\"\u21a9\ufe0f\", key=f\"btn_reply_set_{idx}\", help=f\"Reply to {sender}\", type=\"tertiary\"):\n            st.session_state.reply_to = {\n                \"sender\": sender,\n                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"", "start_line": 1041, "end_line": 1090}, {"path": "src/interface/app.py", "content": "                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"\n        if is_relevant:\n            # FILTER LOGIC\n            if is_urgent_focus:\n                target = m.get(\"target\")\n                is_replied = m.get(\"replied\", False)\n                # Show only if directed to User AND not replied\n                if target != \"User\" or is_replied:\n                    continue\n            stream_msgs.append((i, m))\n    \n    # Pagination\n    if \"stream_limit\" not in st.session_state: st.session_state.stream_limit = 25\n    total_stream = len(stream_msgs)\n    limit_stream = st.session_state.stream_limit\n    if total_stream > limit_stream:\n            # UI Minimaliste (Tertiary)\n            if st.button(f\"\ud83d\udd03 Historique ({total_stream - limit_stream})\", key=\"load_more_stream\", type=\"tertiary\"):\n                st.session_state.stream_limit += 25\n                st.rerun()\n    \n    visible_stream = stream_msgs[max(0, total_stream - limit_stream):]\n    \n    if not visible_stream:\n        st.info(\"Aucune activit\u00e9 d\u00e9tect\u00e9e sur les bandes neurales.\")\n        \n    for real_idx, m in visible_stream:\n        sender = m.get(\"from\", \"?\")\n        target = m.get(\"target\", \"?\")\n        content = m.get(\"content\", \"\")\n        is_public = m.get(\"public\", False)\n        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        ", "start_line": 1081, "end_line": 1130}, {"path": "src/interface/app.py", "content": "        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        \n        # Style and Tag Logic\n        tag_html = \"\"\n        bubble_style = \"\"\n        \n        if is_public:\n            tag_html = ''\n            bubble_style = \"background-color: rgba(248, 249, 250, 0.8); border-left: 4px solid #2e7d32;\"\n        else:\n            if target == \"User\":\n                tag_html = '<span class=\"status-tag direct-tag\">\ud83d\udd12 Direct Link</span>'\n                if not is_replied:\n                    tag_html += '<span class=\"status-tag urgent-tag\">\u26a1 Action Required</span>'\n                    bubble_style = \"background-color: #fffdf0; border-left: 4px solid #fbc02d; box-shadow: 0 4px 12px rgba(251, 192, 45, 0.12);\"\n                else:\n                    bubble_style = \"background-color: #f0f7ff; border-left: 4px solid #1976d2;\"\n            elif sender == \"User\":\n                tag_html = f'<span class=\"status-tag\">\ud83d\udce4 Outgoing to {target}</span>'\n                bubble_style = \"background-color: #ffffff; border-left: 4px solid #94a3b8;\"\n            else:\n                tag_html = f'<span class=\"status-tag direct-tag\" style=\"background: #ffebee; color: #c62828;\">\ud83d\udd12 Private {sender} \u2192 {target}</span>'\n                bubble_style = \"background-color: #fff8f8; border: 2px dashed #ff4b4b;\"\n\n        with st.chat_message(sender, avatar=sender_emoji):\n            # Header with sender, target and status tags\n            c_header, c_action = st.columns([12, 1])\n            \n            with c_header:\n                st.markdown(f\"\"\"<div class=\"message-header\"><span style=\"font-weight: 700; color: #333; font-size: 0.9em;\">{sender}</span><span style=\"color: #999; font-size: 0.8em;\">\u2192</span><span class=\"target-badge\">{target if target != 'all' else 'everyone'}</span>{tag_html}<span style=\"color: #bbb; font-size: 0.7em; margin-left: auto;\">{time.strftime('%H:%M:%S', time.localtime(timestamp))}</span></div>\"\"\", unsafe_allow_html=True)\n            \n            with c_action:\n                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to", "start_line": 1121, "end_line": 1170}, {"path": "src/interface/app.py", "content": "                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to\n        col_banner, col_x = st.columns([11, 1])\n        with col_banner:\n            st.markdown(f'<div class=\"reply-banner-custom\">\u21a9\ufe0f R\u00e9ponse \u00e0 <b>{ctx[\"sender\"]}</b>: \"{ctx[\"preview\"]}\"</div>', unsafe_allow_html=True)\n        with col_x:\n            if st.button(\"\u2716\ufe0f\", key=\"cancel_reply_v6\", help=\"Annuler\"):\n                st.session_state.reply_to = None\n                st.rerun()\n\n    # 2. Status & Focus Row\n    # (No extra spacer here to avoid empty divs)\n    \n    # 2a. Typing Indicator (Centered)\n    typing_agents = []\n    current_turn_name = turn.get(\"current\")\n    for name, info in agents.items():\n        if name == \"User\": continue\n        if info.get(\"status\") == \"working\" or (name == current_turn_name and info.get(\"status\") == \"connected\"):\n            typing_agents.append(name)\n    \n    if typing_agents:\n        agent_names = \", \".join(typing_agents)\n        plural = \"sont\" if len(typing_agents) > 1 else \"est\"\n        st.markdown(f'<div class=\"typing-container\">{agent_names} {plural} en train d\\'\u00e9crire...<div class=\"typing-dots\"><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div></div></div>', unsafe_allow_html=True)\n    \n    # 2b. Focus Toggle (Removed)\n    c1, c2, c3 = st.columns([1, 1, 1])\n    \n    # MOVED: Banner in bottom right (c3)\n    if turn.get(\"current\") == \"User\":\n        with c3:\n            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n", "start_line": 1161, "end_line": 1210}, {"path": "src/interface/app.py", "content": "            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n\n    # Main Input\n    if prompt := st.chat_input(\"Message...\"):\n        def send_omni_msg(s):\n            target = None\n            public = True\n            reply_ref_id = None\n            \n            # Logic v2.0\n            \n            # 1. Context Reply (Strongest implicit) \n            # Tech Lead said: \"1. Si @Mention -> Priority. 2. Sinon si target_sel != Tous -> Target.\"\n            # Actually Context Reply usually overrides Selector visually, but Mention overrides all?\n            # Let's follow instruction:\n            # 1. Mention check\n            # 2. Selector check\n            # 3. Public\n            \n            found_mentions = []\n            found_mention = False\n            \n            # Mention Check (Specific Agents only)\n            known_agents = sorted(list(agents.keys()), key=len, reverse=True)\n            \n            # Use regex to find all mentions in order of appearance\n            # Sorting known_agents by length reverse ensures longer names are matched first\n            if known_agents:\n                pattern = \"@(\" + \"|\".join([re.escape(name) for name in known_agents]) + \")\"\n                matches = re.finditer(pattern, prompt)\n                seen = set()\n                for match in matches:\n                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True", "start_line": 1201, "end_line": 1250}, {"path": "src/interface/app.py", "content": "                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True\n            else:\n                audience = []\n            \n            if not found_mention:\n                if st.session_state.reply_to:\n                     # Reply Context overrides Selector\n                     target = st.session_state.reply_to[\"sender\"]\n                     reply_ref_id = st.session_state.reply_to[\"id\"]\n                     public = False\n                else:\n                    # No mention, no reply context -> Public Broadcast\n                    target = \"all\"\n                    public = True\n            \n            # Prepare content with Reply Context\n            final_content = prompt\n            if st.session_state.reply_to:\n                ref = st.session_state.reply_to\n                final_content = f\"\u21aa\ufe0f [R\u00e9ponse \u00e0 {ref['sender']}: \\\"{ref['preview']}\\\"]\\n{prompt}\"\n\n            msg = {\n                \"from\": \"User\",\n                \"content\": final_content,\n                \"timestamp\": time.time(),\n                \"public\": public,\n                \"audience\": audience\n            }\n            if target:\n                msg[\"target\"] = target\n            else:\n                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---", "start_line": 1241, "end_line": 1290}, {"path": "src/interface/app.py", "content": "                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---\n            if s.get(\"turn\", {}).get(\"current\") == \"User\":\n                next_speaker = None\n                if target and target != \"all\" and target in s.get(\"agents\", {}):\n                    next_speaker = target\n                else:\n                    # Priority 1: first_agent defined during reset\n                    first_pref = s.get(\"turn\", {}).get(\"first_agent\")\n                    if first_pref and first_pref in s.get(\"agents\", {}):\n                        next_speaker = first_pref\n                    else:\n                        # Fallback to the first connected agent\n                        connected = [n for n, d in s.get(\"agents\", {}).items() if d.get(\"status\") == \"connected\"]\n                        if connected:\n                            next_speaker = connected[0]\n                \n                if next_speaker:\n                    # USE CENTRALIZED TRANSITION LOGIC FROM ENGINE\n                    from src.core.logic import Engine\n                    engine = Engine(state_store) # Use the global state_store\n                    engine._finalize_turn_transition(s, next_speaker)\n\n            # Context Cleanup\n            if reply_ref_id is not None:\n                if reply_ref_id < len(s[\"messages\"]):\n                     s[\"messages\"][reply_ref_id][\"replied\"] = True\n                     \n            return \"Message Transmis.\"\n\n        res = state_store.update(send_omni_msg)\n        st.session_state.reply_to = None\n        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")", "start_line": 1281, "end_line": 1330}, {"path": "src/interface/app.py", "content": "        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")\n    \n    # --- 0. GRAPHVIZ VIEW (TOP) ---\n    with st.expander(\"\ud83d\udd78\ufe0f Topologie de la Flotte (Graphviz)\", expanded=False):\n        try:\n            g = render_graph(profiles)\n            st.graphviz_chart(g, use_container_width=True)\n        except Exception as e:\n            st.error(f\"Erreur de rendu du graphe : {e}\")\n\n    # Scenarios\n    st.subheader(\"\ud83d\udcbe Sc\u00e9narios\")\n    with st.container(border=True):\n        col_scen1, col_scen2 = st.columns(2)\n        if col_scen1.button(\"\ud83d\udcbe Sauvegarder\", use_container_width=True, help=\"Sauvegarder la configuration actuelle\"):\n            save_scenario_dialog(config)\n        if col_scen2.button(\"\ud83d\udcc2 Charger\", use_container_width=True, help=\"Charger une configuration existante\"):\n            load_scenario_dialog()\n\n    # Global Context (Full Width)\n    st.subheader(\"\ud83c\udf0d Contexte Global\")\n    with st.container(border=True):\n        enable_backlog = st.checkbox(\"Backlog\", value=config.get(\"enable_backlog\", False), help=\"Si coch\u00e9, les agents consulteront et mettront \u00e0 jour BACKLOG.md \u00e0 la racine.\")\n        if enable_backlog != config.get(\"enable_backlog\", False):\n            config[\"enable_backlog\"] = enable_backlog\n            save_config(config)\n            st.rerun()\n\n\n        global_context = st.text_area(\"Narratif / Contexte Partag\u00e9\", config.get(\"context\", \"\"), height=215)\n        if global_context != config.get(\"context\", \"\"):\n            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    ", "start_line": 1321, "end_line": 1370}, {"path": "src/interface/app.py", "content": "            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    \n    # Display cards in a grid\n    cols_per_row = 3\n    for i in range(0, len(profiles), cols_per_row):\n        cols = st.columns(cols_per_row)\n        for j in range(cols_per_row):\n            if i + j < len(profiles):\n                p = profiles[i + j]\n                with cols[j]:\n                    with st.container(border=True):\n                        count = int(p.get(\"count\", 0))\n                        emoji = p.get(\"emoji\", \"\ud83e\udd16\")\n                        description = p.get(\"description\", \"Aucune description.\")\n                        \n                        st.markdown(f\"\"\"<div class=\"agent-header\"><div class=\"agent-icon\">{emoji}</div><div class=\"agent-name\">{p['name']}</div></div><div class=\"agent-desc\">{description}</div>\"\"\", unsafe_allow_html=True)\n                        \n                        # Controls inside the card\n                        ctrl_c1, ctrl_c2, ctrl_c3 = st.columns([1, 1.2, 1])\n                        if ctrl_c1.button(\"\u2796\", key=f\"d_{i+j}\", use_container_width=True):\n                            p[\"count\"] = max(0, count - 1)\n                            save_config(config)\n                            st.rerun()\n                        \n                        ctrl_c2.markdown(f'<div class=\"count-display\">{count}</div>', unsafe_allow_html=True)\n                        \n                        if ctrl_c3.button(\"\u2795\", key=f\"i_{i+j}\", use_container_width=True):\n                            p[\"count\"] = count + 1\n                            save_config(config)\n                            st.rerun()\n                            \n                        if st.button(\"\u270f\ufe0f Modifier\", key=f\"ed_{i+j}\", use_container_width=True, type=\"secondary\"):\n                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    ", "start_line": 1361, "end_line": 1410}, {"path": "src/interface/app.py", "content": "                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    \n    # Calculate potential agent IDs the same way reset_logic does\n    temp_slots = []\n    for p in profiles:\n        for _ in range(int(p.get(\"count\", 0))):\n            temp_slots.append(p.get(\"display_name\") or p[\"name\"])\n            \n    counters = {}\n    for base in temp_slots:\n        counters.setdefault(base, 0)\n        counters[base] += 1\n        total_of_this_base = sum(1 for b in temp_slots if b == base)\n        agent_id = f\"{base} #{counters[base]}\" if total_of_this_base > 1 else base\n        potential_agents.append(agent_id)\n\n    # Use session state to persist choice\n    if \"first_speaker\" not in st.session_state:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    # Check if current choice is still valid (profiles might have changed)\n    if st.session_state.first_speaker not in potential_agents:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    selected_first = st.selectbox(\"Qui r\u00e9pondra en premier \u00e0 l'utilisateur ?\", potential_agents,\n                                 index=potential_agents.index(st.session_state.first_speaker) if st.session_state.first_speaker in potential_agents else 0,\n                                 help=\"L'agent qui aura le premier tour pour r\u00e9pondre au premier message de l'utilisateur.\")\n    st.session_state.first_speaker = selected_first\n\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n\n    # --- 3. RESET BUTTON (MODERN) ---\n    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context", "start_line": 1401, "end_line": 1450}, {"path": "src/interface/app.py", "content": "    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context\n                \n                # Use profiles from the state s for absolute consistency\n                current_profiles = s[\"config\"].get(\"profiles\", [])\n                \n                # Update total agents count\n                total_count = get_total_agents(current_profiles)\n                s[\"config\"][\"total_agents\"] = total_count\n                \n                pending_slots = []\n                # Remove random shuffle to maintain profile order\n                for p in current_profiles:\n                    for _ in range(int(p.get(\"count\", 0))):\n                        pending_slots.append({\n                            \"profile_ref\": p[\"name\"],\n                            \"role\": p.get(\"system_prompt\", \"\"),\n                            \"display_base\": p.get(\"display_name\") or p[\"name\"],\n                            \"emoji\": p.get(\"emoji\", \"\ud83e\udd16\")\n                        })\n                \n                new_agents = {}\n                counters = {}\n                for slot in pending_slots:\n                    base = slot[\"display_base\"]\n                    counters.setdefault(base, 0)\n                    counters[base] += 1\n                    agent_id = f\"{base} #{counters[base]}\" if sum(1 for sl in pending_slots if sl[\"display_base\"] == base) > 1 else base\n                    new_agents[agent_id] = {\n                        \"role\": slot[\"role\"], \"status\": \"pending_connection\",\n                        \"profile_ref\": slot[\"profile_ref\"], \"emoji\": slot[\"emoji\"]\n                    }\n                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"", "start_line": 1441, "end_line": 1490}, {"path": "src/interface/app.py", "content": "                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"\n            st.rerun()\n\n\n# ==========================================\n# PAGE: EDITOR (Admin)\n# ==========================================\nelif st.session_state.page == \"Editor\":\n    st.header(\"\ud83d\udee0\ufe0f \u00c9diteur d'Agents\")\n    \n    profile_names = [p[\"name\"] for p in profiles]\n    profile_names.append(\"\u2795 Create New\")\n    \n    sel_idx = 0\n    cur_edit = st.session_state.get(\"editing_agent_name\")\n    if cur_edit in profile_names:\n        sel_idx = profile_names.index(cur_edit)\n        \n    selected_name = st.selectbox(\"Selection Profil\", profile_names, index=sel_idx, key=\"edit_sel_page\")\n    \n    if selected_name == \"\u2795 Create New\":\n        current_profile = {\n            \"name\": \"New Agent\", \n            \"description\": \"\", \n            \"emoji\": \"\ud83e\udd16\", # Default, will be randomized in session state\n            \"connections\": [], \n            \"count\": 1, \n            \"capabilities\": [\"public\"]\n        }\n        new_mode = True\n        st.session_state.editing_agent_name = \"New Agent\"\n        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        ", "start_line": 1481, "end_line": 1530}, {"path": "src/interface/app.py", "content": "        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        \n        if st.button(\"\ud83d\uddd1\ufe0f Supprimer Profil\", type=\"primary\"):\n             config[\"profiles\"] = [p for p in profiles if p[\"name\"] != selected_name]\n             emoji_key = f\"editing_emoji_{selected_name}\"\n             if emoji_key in st.session_state:\n                 del st.session_state[emoji_key]\n             save_config(config)\n             st.rerun()\n\n    if current_profile:\n        st.markdown(\"---\")\n        # Layout Spacieux (Columns)\n        c_main, c_disp = st.columns([3, 2])\n        \n        with c_main:\n            c_emoji, c_name = st.columns([0.18, 0.82])\n            \n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key not in st.session_state:\n                st.session_state[emoji_key] = current_profile.get(\"emoji\", \"\ud83e\udd16\")\n            current_emoji = st.session_state[emoji_key]\n            \n            with c_emoji:\n                st.markdown('<div style=\"height: 28px;\"></div>', unsafe_allow_html=True) # Spacer to align with text input label\n                with st.popover(f\"{current_emoji}\", use_container_width=True):\n                    cols = st.columns(8)\n                    for idx, emoji in enumerate(EMOJI_LIST):\n                        if cols[idx % 8].button(emoji, key=f\"emoji_btn_{selected_name}_{idx}\"):\n                            st.session_state[emoji_key] = emoji\n                            st.rerun()\n            \n            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")", "start_line": 1521, "end_line": 1570}, {"path": "src/interface/app.py", "content": "            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")\n        caps = current_profile.get(\"capabilities\", [])\n        \n        # Preserve other capabilities (e.g. shell_exec)\n        other_caps = [c for c in caps if c not in [\"public\", \"private\"]]\n        \n        has_pub = \"public\" in caps\n        has_priv = \"private\" in caps\n        \n        # Determine default index\n        default_idx = 0 # Public\n        if has_pub and has_priv:\n            default_idx = 2 # Both\n        elif has_priv and not has_pub:\n            default_idx = 1 # Private\n        \n        comm_mode = st.radio(\n            \"Port\u00e9e de Communication\",\n            [\"Public\", \"Priv\u00e9\", \"Les Deux (Public & Priv\u00e9)\"],\n            index=default_idx,\n            key=f\"comm_mode_{selected_name}\",\n            horizontal=True,\n            help=\"D\u00e9finit la port\u00e9e de communication autoris\u00e9e pour cet agent.\"\n        )\n        \n        new_caps = list(other_caps)\n        if comm_mode == \"Public\":\n            new_caps.append(\"public\")\n        elif comm_mode == \"Priv\u00e9\":\n            new_caps.append(\"private\")\n        else:\n            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        ", "start_line": 1561, "end_line": 1610}, {"path": "src/interface/app.py", "content": "            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        \n        new_connections = []\n        \n        # Header for the \"Table\"\n        with st.container():\n            h1, h2, h3 = st.columns([2, 5, 1])\n            h1.markdown(\"**Cible**\")\n            h2.markdown(\"**Condition / Contexte**\")\n            h3.markdown(\"**Active**\")\n            st.markdown(\"<hr style='margin-top: 0; margin-bottom: 10px; border-color: #eee;'>\", unsafe_allow_html=True)\n        \n        for target in targets:\n            # Case-insensitive match for connections\n            existing_conn = next((c for c in current_profile.get(\"connections\", []) if c[\"target\"].lower() == target.lower()), None)\n            \n            c1, c2, c3 = st.columns([2, 5, 1])\n            \n            # Label\n            target_profile = next((p for p in profiles if p[\"name\"] == target), None)\n            target_emoji = \"\ud83c\udf10\" if target == \"public\" else \"\ud83d\udc64\" if target == \"User\" else (target_profile.get(\"emoji\", \"\ud83e\udd16\") if target_profile else \"\ud83e\udd16\")\n            c1.markdown(f\"{target_emoji} **{target}**\")\n            \n            default_ctx = existing_conn.get(\"context\", \"\") if existing_conn else \"\"\n            default_auth = existing_conn.get(\"authorized\", True) if existing_conn else False\n            \n            # Unique key with selected_name and target\n            ctx = c2.text_area(f\"Condition for {target}\", default_ctx, key=f\"conn_ctx_{selected_name}_{target}\", label_visibility=\"collapsed\", height=68)\n            auth = c3.checkbox(f\"Active for {target}\", default_auth, key=f\"conn_auth_{selected_name}_{target}\", label_visibility=\"collapsed\")\n            \n            if auth or ctx:\n                new_connections.append({\"target\": target, \"context\": ctx, \"authorized\": auth})\n            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            ", "start_line": 1601, "end_line": 1650}, {"path": "src/interface/app.py", "content": "            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            \n            # Use the emoji from session state\n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key in st.session_state:\n                current_profile[\"emoji\"] = st.session_state[emoji_key]\n                del st.session_state[emoji_key]\n            \n            if new_mode:\n                profiles.append(current_profile)\n            \n            # Smart renaming\n            if not new_mode and selected_name and new_name != selected_name:\n                for p in profiles:\n                    for conn in p.get(\"connections\", []):\n                        if conn.get(\"target\") == selected_name:\n                            conn[\"target\"] = new_name\n            \n            save_config(config)\n            st.toast(\"Saved!\")\n            st.rerun()\n\n# --- GLOBAL INJECTION (Fixed by Anais) ---\nif st.session_state.page == \"Communication\":\n    # Ensure mentions are injected even if logic flow was broken\n    active_names = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    inject_mention_system(active_names)", "start_line": 1641, "end_line": 1675}, {"path": "src/interface/app.py", "content": "import streamlit as st\nimport streamlit.components.v1 as components\nfrom streamlit_autorefresh import st_autorefresh\nimport graphviz\nimport json\nimport uuid\nimport sys\nimport os\nimport time\nimport re\nimport shutil\nfrom pathlib import Path\n\n# Add src to path to allow imports if run directly\nfrom pathlib import Path\nimport sys\nimport os\n\nCODE_ROOT = Path(__file__).resolve().parent.parent.parent\nif str(CODE_ROOT) not in sys.path:\n    sys.path.append(str(CODE_ROOT))\n\nfrom src.config import (\n    STATE_FILE, \n    MEMORY_DIR, \n    TEMPLATE_DIR, \n    LOCAL_DATA_DIR, \n    GLOBAL_PRESET_DIR, \n    ASSETS_DIR,\n    CODE_ROOT as CONFIG_CODE_ROOT,\n    RELOAD_INSTRUCTION\n)\nfrom src.core.state import StateStore\nfrom src.services.search_engine import SearchEngine\n\nst.set_page_config(page_title=\"Agent Orchestra\", page_icon=\"\ud83e\udd16\", layout=\"wide\")\n\n# --- EMOJI LIST ---\nEMOJI_LIST = [\n    \"\ud83e\udd16\", \"\ud83e\udde0\", \"\ud83d\udd75\ufe0f\", \"\ud83e\uddb8\", \"\ud83e\udd77\", \"\ud83e\uddd9\", \"\ud83e\udddb\", \"\ud83e\udddf\", \"\ud83e\uddde\", \"\ud83e\udddd\",\n    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",", "start_line": 1, "end_line": 50}, {"path": "src/interface/app.py", "content": "    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",\n    \"\ud83e\udda1\", \"\ud83e\udda6\", \"\ud83e\udda5\", \"\ud83d\udc01\", \"\ud83d\udc00\", \"\ud83d\udc3f\ufe0f\", \"\ud83e\udd94\", \"\ud83d\udc3e\", \"\ud83d\udc09\", \"\ud83d\udc32\",\n    \"\ud83c\udf35\", \"\ud83c\udf84\", \"\ud83c\udf32\", \"\ud83c\udf33\", \"\ud83c\udf34\", \"\ud83c\udf31\", \"\ud83c\udf3f\", \"\u2618\ufe0f\", \"\ud83c\udf40\", \"\ud83c\udf43\"\n]\n\ndef get_random_emoji():\n    import random\n    return random.choice(EMOJI_LIST)\n\n# --- HELPER FUNCTIONS ---\ndef inject_custom_css():\n    st.markdown(\"\"\"<style>\n    /* Global message container */\n    [data-testid=\"stChatMessage\"] {\n        padding: 1rem !important;\n        margin-bottom: 1.5rem !important;\n    }\n    \n    [data-testid=\"stChatMessage\"] [data-testid=\"stVerticalBlock\"] {\n        gap: 12px !important;\n    }\n\n    /* Header layout inside message */\n    .message-header {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        margin-bottom: 8px;\n        opacity: 0.85;\n    }\n\n    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    ", "start_line": 41, "end_line": 90}, {"path": "src/interface/app.py", "content": "    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    \n    .reply-banner-custom {\n        background: #f0f7ff;\n        border: 1px solid #d0e7ff;\n        border-radius: 10px;\n        padding: 8px 15px;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        margin-bottom: 8px;\n        font-size: 0.85em;\n        box-shadow: 0 2px 8px rgba(0,0,0,0.05);\n    }\n\n    /* Premium Toggle Styling (Targeting the specific widget) */\n    div[data-testid=\"stToggle\"] {\n        background: #ffffff;\n        padding: 10px 24px !important;\n        border-radius: 50px !important;\n        border: 1px solid #ff4b4b22 !important;\n        box-shadow: 0 4px 15px rgba(0,0,0,0.06) !important;\n        transition: all 0.3s ease !important;\n        width: fit-content !important;\n        margin: 10px auto !important;\n    }\n    \n    div[data-testid=\"stToggle\"]:hover {\n        border-color: #ff4b4b !important;\n        box-shadow: 0 6px 20px rgba(255,75,75,0.12) !important;\n        transform: translateY(-1px);\n    }\n\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;", "start_line": 81, "end_line": 130}, {"path": "src/interface/app.py", "content": "\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;\n        gap: 12px !important;\n        margin: 0 !important;\n    }\n\n    div[data-testid=\"stToggle\"] label p {\n        font-weight: 700 !important;\n        font-size: 0.95em !important;\n        color: #1a1a1a !important;\n        margin: 0 !important;\n        letter-spacing: -0.2px !important;\n    }\n    \n    .target-badge {\n        font-weight: 600;\n        padding: 1px 6px;\n        border-radius: 4px;\n        font-size: 0.75em;\n        color: #444;\n        background: rgba(0,0,0,0.08);\n        border: 1px solid rgba(0,0,0,0.1);\n    }\n    \n    .status-tag {\n        font-size: 0.7em;\n        font-weight: 700;\n        padding: 1px 5px;\n        border-radius: 4px;\n        text-transform: uppercase;\n        letter-spacing: 0.5px;\n    }\n    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;", "start_line": 121, "end_line": 170}, {"path": "src/interface/app.py", "content": "    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        padding: 6px 16px;\n        color: #666;\n        font-size: 0.85em;\n        font-style: italic;\n        background: rgba(0,0,0,0.03);\n        border-radius: 20px;\n        margin: 10px auto;\n        width: fit-content;\n        border: 1px solid rgba(0,0,0,0.05);\n        box-shadow: 0 2px 4px rgba(0,0,0,0.02);\n    }\n    .typing-dots {\n        display: flex; gap: 4px; margin-left: 8px;\n    }\n    .typing-dot {\n        width: 5px; height: 5px; background: #999; border-radius: 50%;\n        animation: typing-bounce 1.4s infinite ease-in-out;\n    }\n    .typing-dot:nth-child(1) { animation-delay: -0.32s; }\n    .typing-dot:nth-child(2) { animation-delay: -0.16s; }\n    @keyframes typing-bounce {\n        0%, 80%, 100% { transform: translateY(0); opacity: 0.3; }\n        40% { transform: translateY(-3px); opacity: 1; }\n    }\n    </style>\"\"\", unsafe_allow_html=True)\n\ninject_custom_css()\n\n# --- INITIALIZE STATE (ONCE) ---\nstate_store = StateStore()\n\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n", "start_line": 161, "end_line": 210}, {"path": "src/interface/app.py", "content": "\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n\ndef save_config(new_config):\n    def update_fn(s):\n        s[\"config\"] = new_config\n        return \"Config Saved\"\n    state_store.update(update_fn)\n\n\n# --- SEARCH ENGINE INIT ---\n@st.cache_resource\ndef init_search_engine():\n    engine = SearchEngine()\n    # Ensure directory exists for persist\n    persist = LOCAL_DATA_DIR / \"vector_store\"\n    persist.mkdir(parents=True, exist_ok=True)\n    engine.initialize(root_dir=CODE_ROOT, persist_dir=persist)\n    return engine\n\n# Initialize background service\nsearch_engine = init_search_engine()\n\n\n# --- DIALOGS ---\ndef handle_disconnect_agent(agent_name):\n    \"\"\"\n    Sets the reload_active flag for the agent.\n    Does NOT set 'pending_connection' immediately (Agent must do it via disconnect tool).\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = True\n            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }", "start_line": 201, "end_line": 250}, {"path": "src/interface/app.py", "content": "            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }\n            s.setdefault(\"messages\", []).append(msg)\n            \n        return f\"Signal de rechargement envoy\u00e9 \u00e0 : {agent_name}\"\n    \n    state_store.update(update_fn)\n    st.toast(f\"Reload signal sent to {agent_name} \ud83d\udd01\")\n\ndef force_disconnect_agent(agent_name):\n    \"\"\"\n    Forces status to pending_connection immediately.\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = False # Reset flag\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n        return f\"Force disconnect: {agent_name}\"\n    state_store.update(update_fn)\n    st.toast(f\"\u2620\ufe0f Force Disconnect: {agent_name}\")\n\nPRESET_DIR = GLOBAL_PRESET_DIR\n\n@st.dialog(\"Sauvegarder le Sc\u00e9nario\")\ndef save_scenario_dialog(current_config):\n    save_name = st.text_input(\"Nom de Sauvegarde\", placeholder=\"mon_scenario\")\n    if st.button(\"Confirmer la Sauvegarde\", use_container_width=True):\n        if save_name:\n            # Basic filename cleaning\n            filename = \"\".join([c for c in save_name if c.isalnum() or c in (' ', '.', '_', '-')]).rstrip()\n            path = PRESET_DIR / f\"{filename}.json\"\n            with open(path, \"w\") as f:\n                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")", "start_line": 241, "end_line": 290}, {"path": "src/interface/app.py", "content": "                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")\n                except Exception as e:\n                    # Non-blocking, just dev convenience\n                    print(f\"Failed to sync to repo: {e}\")\n            st.success(f\"Sauvegard\u00e9 : {filename}\")\n            time.sleep(1)\n            st.rerun()\n        else:\n            st.error(\"Veuillez entrer un nom.\")\n\n@st.dialog(\"Charger un Sc\u00e9nario\")\ndef load_scenario_dialog():\n    # Unified Source: User Global Presets\n    # (Defaults have been synced here by sync_presets)\n    presets = sorted([f for f in os.listdir(PRESET_DIR) if f.endswith(\".json\")])\n    \n    if not presets:\n        st.warning(\"Aucun sc\u00e9nario trouv\u00e9.\")\n        return\n\n    options = [f\"\ud83d\udcbe {f}\" for f in presets]\n    path_map = {f\"\ud83d\udcbe {f}\": PRESET_DIR / f for f in presets}\n        \n    selected_label = st.selectbox(\"Choisir un Preset\", options)\n    \n    c_load, c_del = st.columns([0.85, 0.15])\n    \n    with c_load:\n        if st.button(\"Charger la Configuration\", use_container_width=True, type=\"primary\"):\n            if selected_label:\n                path = path_map[selected_label]\n                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)", "start_line": 281, "end_line": 330}, {"path": "src/interface/app.py", "content": "                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)\n                st.rerun()\n                \n    with c_del:\n        if st.button(\"\ud83d\uddd1\ufe0f\", key=\"del_scen_btn\", help=\"Supprimer d\u00e9finivement\", use_container_width=True):\n             if selected_label:\n                 path = path_map[selected_label]\n                 try:\n                     os.remove(path)\n                     st.toast(f\"Sc\u00e9nario supprim\u00e9: {selected_label}\")\n                     time.sleep(0.7)\n                     st.rerun()\n                 except Exception as e:\n                     st.error(f\"Erreur: {e}\")\n\ndef get_total_agents(profiles):\n    total = 0\n    for p in profiles:\n        try:\n            total += int(p.get(\"count\", 0))\n        except:\n            pass\n    return total\n\ndef format_mentions(text):\n    if not text: return text\n    \n    # 1. First decorate @everyone\n    text = re.sub(\n        r'(@everyone)',\n        r'<span style=\"color: #ffffff; background-color: #ff4b4b; padding: 2px 8px; border-radius: 6px; font-weight: 700; font-size: 0.9em; box-shadow: 0 2px 4px rgba(255,75,75,0.3);\">\\1</span>',\n        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )", "start_line": 321, "end_line": 370}, {"path": "src/interface/app.py", "content": "        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )\n\ndef render_graph(profiles, current_editing=None):\n    graph = graphviz.Digraph()\n    graph.attr(rankdir='LR', size='12,2', ratio='fill', bgcolor='transparent', margin='0')\n    \n    # Add User node\n    graph.node(\"User\", label=\"\ud83d\udc64 User\", style='filled', fillcolor='lightgrey', shape='circle', fontsize='10', height='0.5')\n    \n    for p in profiles:\n        name = p[\"name\"]\n        color = 'lightblue'\n        if current_editing and name == current_editing:\n            color = 'gold'\n        count = p.get(\"count\", 0)\n        label = f\"{name}\\n(x{count})\"\n        graph.node(name, label=label, style='filled', fillcolor=color, shape='box', fontsize='10', height='0.5')\n\n    for p in profiles:\n        source = p[\"name\"]\n        for conn in p.get(\"connections\", []):\n            target = conn.get(\"target\")\n            is_auth = conn.get(\"authorized\", True)\n            if is_auth and (target == \"User\" or any(prof[\"name\"] == target for prof in profiles)):\n                graph.edge(source, target, fontsize='8', color='gray', arrowsize='0.5')\n    return graph\n\ndef inject_mention_system(agent_names):\n    import json\n    agents_json = json.dumps(agent_names)\n    \n    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;", "start_line": 361, "end_line": 410}, {"path": "src/interface/app.py", "content": "    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;\n            const textarea = doc.querySelector('textarea[data-testid=\"stChatInputTextArea\"]');\n            \n            if (!textarea) {{\n                // Polled by setInterval, so just return\n                return;\n            }}\n\n            // Cleanup previous interaction from this or previous iframes\n            // We use a custom property on the DOM node to store the controller\n            if (textarea._mentionController) {{\n                // If the controller belongs to a DEAD iframe, this might fail or succeed. \n                // But mostly it allows us to signal \"Stop Listing\".\n                try {{\n                    textarea._mentionController.abort();\n                }} catch(e) {{}}\n            }}\n\n            // Create new controller for this instance\n            const controller = new AbortController();\n            textarea._mentionController = controller;\n            const signal = controller.signal;\n\n            let menu = doc.getElementById('mention-menu');\n            if (!menu) {{\n                menu = doc.createElement('div');\n                menu.id = 'mention-menu';\n                Object.assign(menu.style, {{\n                    display: 'none',\n                    position: 'fixed',\n                    background: 'white',\n                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);", "start_line": 401, "end_line": 450}, {"path": "src/interface/app.py", "content": "                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);\n            }}\n\n            // Inject styles\n            if (!doc.getElementById('mention-styles')) {{\n                const style = doc.createElement('style');\n                style.id = 'mention-styles';\n                style.innerHTML = `\n                    .mention-item:hover {{\n                        background-color: #f0f2f6 !important;\n                    }}\n                `;\n                doc.head.appendChild(style);\n            }}\n\n            textarea.addEventListener('input', (e) => {{\n                if (e.isComposing) return;\n                const value = textarea.value;\n                const cursorPos = textarea.selectionStart;\n                const textBeforeCursor = value.substring(0, cursorPos);\n                const mentionMatch = textBeforeCursor.match(/@([\\\\w\\\\s#]*)$/);\n\n                if (mentionMatch) {{\n                    isVisible = true;\n                    currentFilter = mentionMatch[1].toLowerCase();\n                    renderMenu(textarea);\n                }} else {{\n                    hideMenu();\n                }}\n            }}, {{ signal }});\n\n            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;", "start_line": 441, "end_line": 490}, {"path": "src/interface/app.py", "content": "            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'ArrowUp') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex - 1 + filtered.length) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'Enter' || e.key === 'Tab') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    insertMention(textarea, filtered[selectedIndex]);\n                }} else if (e.key === 'Escape') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    hideMenu();\n                }}\n            }}, {{ capture: true, signal: signal }});\n        }}\n\n        function renderMenu(textarea) {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n            \n            if (filtered.length === 0) {{\n                hideMenu();\n                return;\n            }}\n\n            menu.innerHTML = filtered.map((a, i) => `\n                <div class=\"mention-item\" style=\"\n                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">", "start_line": 481, "end_line": 530}, {"path": "src/interface/app.py", "content": "                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">\n                    <span style=\"font-weight: ${{i === selectedIndex ? '600' : '400'}};\">@${{a}}</span>\n                    ${{a === 'everyone' ? '<span style=\"font-size: 10px; background: #ff4b4b; color: white; padding: 1px 4px; border-radius: 4px; margin-left: 5px;\">PUBLIC</span>' : ''}}\n                </div>\n            `).join('');\n\n            const rect = textarea.getBoundingClientRect();\n            menu.style.display = 'block';\n            menu.style.left = rect.left + 'px';\n            \n            // Position above the textarea\n            menu.style.bottom = (window.parent.innerHeight - rect.top + 10) + 'px';\n            isVisible = true;\n        }}\n\n        function insertMention(textarea, name) {{\n            const value = textarea.value;\n            const cursorPos = textarea.selectionStart;\n            const textBeforeCursor = value.substring(0, cursorPos);\n            const textAfterCursor = value.substring(cursorPos);\n            \n            const newTextBefore = textBeforeCursor.replace(/@([\\\\w\\\\s#]*)$/, '@' + name + ' ');\n            const newValue = newTextBefore + textAfterCursor;\n\n            // Robust React state update\n            const nativeTextareaValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, \"value\").set;\n            nativeTextareaValueSetter.call(textarea, newValue);\n            \n            // Trigger events\n            textarea.dispatchEvent(new Event('input', {{ bubbles: true }}));\n            textarea.dispatchEvent(new Event('change', {{ bubbles: true }}));\n\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{", "start_line": 521, "end_line": 570}, {"path": "src/interface/app.py", "content": "\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            if (menu) menu.style.display = 'none';\n            isVisible = false;\n            selectedIndex = 0;\n        }}\n\n        // Initial setup & Polling for re-mounts\n        setInterval(setupMentions, 1000);\n    }})();\n    </script>\n    \"\"\"\n    components.html(components_code, height=0)\n\n# --- MAIN LOGIC ---\n\n# 1. Load Data\nstate, config = load_config()\ndata = state\nprofiles = config.get(\"profiles\", [])\nagents = data.get(\"agents\", {})\nturn = data.get(\"turn\", {})\nmessages = data.get(\"messages\", [])\n\n# --- CSS STYLING ---\nst.markdown(\"\"\"\n<style>\n    div[data-testid=\"stSidebar\"] {\n        background-color: #f0f2f6;\n    }\n    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;", "start_line": 561, "end_line": 610}, {"path": "src/interface/app.py", "content": "    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;\n    }\n    /* Agent Card Styling */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] {\n        background-color: white;\n        border-radius: 16px !important;\n        border: 1px solid #f0f0f0 !important;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.04);\n        padding: 0.5rem;\n        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    }\n    [data-testid=\"stVerticalBlockBorderWrapper\"]:hover {\n        transform: translateY(-4px);\n        box-shadow: 0 12px 24px rgba(0,0,0,0.08);\n        border-color: #ff4b4b44 !important;\n    }\n    .agent-header {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 12px;\n    }\n    .agent-icon {\n        font-size: 1.5em;\n        background: #f8f9fa;\n        width: 42px;\n        height: 42px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 10px;\n        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;", "start_line": 601, "end_line": 650}, {"path": "src/interface/app.py", "content": "        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;\n        color: #64748b;\n        margin-bottom: 1rem;\n        min-height: 4.2em;\n        line-height: 1.5;\n    }\n    .count-display {\n        background: #f1f5f9;\n        color: #0f172a;\n        height: 2.4em;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 8px;\n        font-weight: 700;\n        font-size: 1.1em;\n    }\n    /* Compact buttons in cards */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] .stButton button {\n        height: 2.4em !important;\n    }\n    .reset-button-container {\n        display: flex;\n        justify-content: center;\n        padding: 20px;\n    }\n    @keyframes pulse-gold {\n        0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }\n        70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }\n        100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }\n    }\n    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:", "start_line": 641, "end_line": 690}, {"path": "src/interface/app.py", "content": "    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:\n    st.session_state.page = \"Communication\"\n\n# --- SIDEBAR ---\nwith st.sidebar:\n    st.title(\"\ud83e\udd16 Orchestra\")\n    \n    # Global Autorefresh (Active on all pages to catch messages)\n    st_autorefresh(interval=4000, key=\"global_pulse\")\n\n    st.markdown(\"### Navigation\")\n    \n    # --- NOTIFICATION LOGIC ---\n    total_msgs = len(messages)\n    if \"last_read_count\" not in st.session_state:\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    unread = 0\n    if st.session_state.page != \"Communication\":\n        unread = max(0, total_msgs - st.session_state.last_read_count)\n        \n        # Toast for new messages\n        if \"last_toast_count\" not in st.session_state:\n             st.session_state.last_toast_count = total_msgs\n             \n        if total_msgs > st.session_state.last_toast_count:\n             new_count = total_msgs - st.session_state.last_toast_count\n             # Toast the last one\n             newest = messages[-1]\n             sender = newest.get(\"from\", \"?\")\n             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"", "start_line": 681, "end_line": 730}, {"path": "src/interface/app.py", "content": "             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"\n    if unread > 0:\n        label_comm = f\"\ud83d\udcac Chat ({unread} \ud83d\udd34)\"\n\n    if st.button(label_comm, use_container_width=True, type=\"primary\" if st.session_state.page == \"Communication\" else \"secondary\"):\n        st.session_state.page = \"Communication\"\n        st.rerun()\n        \n    if st.button(\"\ud83c\udf9b\ufe0f Cockpit\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Cockpit\" else \"secondary\"):\n        st.session_state.page = \"Cockpit\"\n        st.rerun()\n        \n    if st.button(\"\ud83d\udee0\ufe0f \u00c9diteur\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Editor\" else \"secondary\"):\n        st.session_state.page = \"Editor\"\n        st.rerun()\n\n    st.divider()\n    \n    # 1. Identity / User Status\n    st.markdown(\"### \ud83d\udc64 Identity\")\n    user_status = config.get(\"user_availability\", \"busy\")\n    \n    # User status toggle\n    is_available = st.toggle(\"Available\", value=(user_status == \"available\"), help=\"Switch between Available (\ud83d\udfe2) and Busy (\ud83d\udd34)\")\n    new_status = \"available\" if is_available else \"busy\"\n    \n    if new_status != user_status:\n        config[\"user_availability\"] = new_status\n        save_config(config)\n        st.rerun()\n\n    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:", "start_line": 721, "end_line": 770}, {"path": "src/interface/app.py", "content": "    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:\n        config[\"language\"] = new_lang\n        save_config(config)\n        st.rerun()\n\n\n\n    st.divider()\n    \n    # Search Config\n    st.markdown(\"### \ud83d\udd0e Search Engine\")\n    \n    # Status Indicator\n    if search_engine and search_engine.initialized:\n        dev_label = search_engine.device.upper().replace(\"\u201d\", \"\") # Fix typo if any from previous edit\n        st.caption(f\"Status: **Active** | Device: **{dev_label}** \u26a1\")\n    else:\n        st.caption(\"Status: \ud83d\udd34 Disabled (Missing Deps)\")\n\n    search_conf = config.get(\"search\", {})\n    \n    sc1, sc2 = st.columns(2)\n    with sc1:\n        x_val = st.number_input(\"Context (X)\", min_value=0, max_value=10, value=search_conf.get(\"x_markdown\", 2), help=\"Number of full markdown result to inject (Passive)\")\n    with sc2:\n        y_val = st.number_input(\"Total (Y)\", min_value=1, max_value=50, value=search_conf.get(\"y_total\", 5), help=\"Default limit for Search Tool\")\n        \n    if x_val != search_conf.get(\"x_markdown\", 3) or y_val != search_conf.get(\"y_total\", 15):\n        if \"search\" not in config: config[\"search\"] = {}\n        config[\"search\"][\"x_markdown\"] = x_val\n        config[\"search\"][\"y_total\"] = y_val\n        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"", "start_line": 761, "end_line": 810}, {"path": "src/interface/app.py", "content": "        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"\n        <div style=\"display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;\">\n            <h3 style=\"margin: 0; font-size: 1.2em;\">\ud83d\udc65 Agents Actifs</h3>\n            <span style=\"background: #e0e0e0; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold;\">{connected_count}</span>\n        </div>\n    \"\"\", unsafe_allow_html=True)\n    \n    # Maintain original order from agents dictionary\n    roster_list = [name for name in agents.keys()]\n    \n    # Explicitly add User to the top\n    roster_list.insert(0, \"User\")\n    \n    current_turn = turn.get(\"current\")\n    \n    if not roster_list:\n        st.caption(\"Aucun agent d\u00e9tect\u00e9.\")\n    else:\n        for name in roster_list:\n            # Handle User specifically since they are not in 'agents' dict\n            if name == \"User\":\n                u_avail = config.get(\"user_availability\", \"busy\")\n                # Map 'available' -> 'connected' (Green), 'busy' -> 'working' (Blue/Busy look)\n                info = {\n                    \"status\": \"connected\" if u_avail == \"available\" else \"working\",\n                    \"emoji\": \"\ud83d\udc64\"\n                }\n            else:\n                info = agents[name]\n            status = info.get(\"status\", \"pending\")\n            emoji = info.get(\"emoji\", \"\ud83e\udd16\")\n            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":", "start_line": 801, "end_line": 850}, {"path": "src/interface/app.py", "content": "            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":\n                status_color = \"#4CAF50\" # Green\n                status_label = \"En ligne\"\n                bg = \"rgba(76, 175, 80, 0.05)\"\n                border_color = \"rgba(76, 175, 80, 0.2)\"\n            elif status == \"pending_connection\":\n                status_color = \"#FF9800\" # Orange\n                status_label = \"Attente Reconnexion\"\n                bg = \"rgba(255, 152, 0, 0.05)\"\n                border_color = \"rgba(255, 152, 0, 0.2)\"\n            elif status == \"working\":\n                status_color = \"#2196F3\" # Blue\n                status_label = \"Travaille...\"\n                bg = \"rgba(33, 150, 243, 0.05)\"\n                border_color = \"rgba(33, 150, 243, 0.2)\"\n            else:\n                status_color = \"#9E9E9E\" # Grey\n                status_label = \"Hors-ligne\"\n                bg = \"transparent\"\n                border_color = \"#eee\"\n            \n            # Additional pulse if it's their turn and they are connected\n            is_active_working = is_turn and status == \"connected\"\n            if is_active_working:\n                status_color = \"#2196F3\"\n                status_label = \"En action...\"\n            \n            card_html = f\"\"\"<div class=\"{card_class}\" style=\"background-color: {bg}; border: 1px solid {border_color}; border-radius: 10px; padding: 10px 14px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s ease;\"><div style=\"display: flex; align-items: center; gap: 12px;\"><div style=\"font-size: 1.4em; background: white; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);\">{emoji}</div><div style=\"display: flex; flex-direction: column;\"><span style=\"font-weight: 600; color: {'#1a1a1a' if status == 'connected' else '#666'}; font-size: 0.95em;\">{name}</span><div style=\"display: flex; align-items: center; gap: 4px;\"><div style=\"width: 6px; height: 6px; background-color: {status_color}; border-radius: 50%;\"></div><span style=\"font-size: 0.7em; color: {status_color}; font-weight: 500; letter-spacing: 0.5px;\">{status_label}</span></div></div></div>{'<span style=\"font-size: 1.2em;\" title=\"C&rsquo;est son tour !\">\u2728</span>' if is_turn else ''}</div>\"\"\"\n            \n            if name == \"User\":\n                st.markdown(card_html, unsafe_allow_html=True)\n            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))", "start_line": 841, "end_line": 890}, {"path": "src/interface/app.py", "content": "            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))\n\n                    if is_reloading:\n                        if st.button(\"\u274c\", key=f\"force_{name}\", help=\"Force Disconnect (Si bloqu\u00e9)\", type=\"primary\"):\n                             force_disconnect_agent(name)\n                             # Also remove from queue if present to unblock sequence\n                             if name in st.session_state.get(\"reload_queue\", []):\n                                 st.session_state.reload_queue.remove(name)\n                             st.rerun()\n                    else:\n                        if st.button(\"\ud83d\udd04\", key=f\"reload_{name}\", help=f\"Recharger {name}\"):\n                            handle_disconnect_agent(name)\n                            st.rerun()\n            \n    st.markdown(\"<div style='height: 10px;'></div>\", unsafe_allow_html=True)\n    if st.button(\"\ud83d\udd04 Reload All Agents\", type=\"secondary\", use_container_width=True, help=\"S\u00e9quence de rechargement (Parall\u00e8le).\"):\n         # Identify Targets\n        to_reload = [\n            n for n, d in agents.items() \n            if d.get(\"status\") in [\"connected\", \"working\"] \n        ]\n        if not to_reload:\n            st.toast(\"Aucun agent actif \u00e0 recharger.\")\n        else:\n            # START PARALLEL SEQUENCE\n            st.session_state.reload_queue = list(to_reload)\n            \n            # Atomic Bulk Update\n            def bulk_reload_signal(s):\n                count = 0\n                for name in to_reload:\n                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,", "start_line": 881, "end_line": 930}, {"path": "src/interface/app.py", "content": "                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,\n                            \"target\": name,\n                            \"timestamp\": time.time()\n                         }\n                         s.setdefault(\"messages\", []).append(msg)\n                         count += 1\n                return f\"Signal de rechargement global envoy\u00e9 ({count} agents).\"\n            \n            state_store.update(bulk_reload_signal)\n            st.toast(f\"S\u00e9quence de rechargement PARALL\u00c8LE initialis\u00e9e pour {len(to_reload)} agents.\")\n            st.rerun()\n\n    # --- SEQUENTIAL RELOAD PROCESSOR ---\n    # Global Processor for the Queue\n    if \"reload_queue\" in st.session_state and st.session_state.reload_queue:\n        current_target = st.session_state.reload_queue[0]\n        \n        # Check current status (Refetch from fresh state)\n        if current_target in agents:\n            agent_data = agents[current_target]\n            status = agent_data.get(\"status\")\n            is_reload_active = agent_data.get(\"reload_active\")\n            \n            # Condition 1: Agent is finished (Disconnect/Pending)\n            if status in [\"pending_connection\", \"disconnected\", \"offline\"]:\n                st.session_state.reload_queue.pop(0) # Done\n                st.rerun() # Proceed to next immediately\n                \n            # Condition 2: Agent needs to be signaled\n            elif not is_reload_active:\n                 handle_disconnect_agent(current_target)\n                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()", "start_line": 921, "end_line": 970}, {"path": "src/interface/app.py", "content": "                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()\n\n    st.divider()\n\n    # --- PAUSE CONTROL ---\n    is_paused = config.get(\"paused\", False)\n    if st.toggle(\"\u23f8\ufe0f PAUSE MCP\", value=is_paused, help=\"Fige le temps pour tous les agents.\"):\n        if not is_paused:\n            config[\"paused\"] = True\n            save_config(config)\n            st.rerun()\n    else:\n        if is_paused:\n            config[\"paused\"] = False\n            save_config(config)\n            st.rerun()\n            \n    if is_paused:\n        st.warning(\"\u26a0\ufe0f SIMULATION EN PAUSE\")\n    \n    st.divider()\n\n    \n    # Debug Tools\n    with st.expander(\"\ud83d\udd27 DEBUG\"):\n        st.markdown(\"### \u2702\ufe0f MCP Truncation Settings\")\n        current_trunc = config.get(\"truncation_limit\", 4096) # Default 4096\n        new_trunc = st.number_input(\"Max Character Limit (0 = Disabled)\", min_value=0, value=int(current_trunc), step=100, help=\"Limite manuelle pour \u00e9viter le tronquage silencieux du client MCP (4096 bytes max).\")\n        if new_trunc != current_trunc:\n             config[\"truncation_limit\"] = int(new_trunc)\n             save_config(config)\n             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)", "start_line": 961, "end_line": 1010}, {"path": "src/interface/app.py", "content": "             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)\n                    server_script = os.path.join(current_dir, \"src\", \"core\", \"server.py\")\n                    command_str = f\"cd {current_dir} && uv run python {server_script}\"\n                    if \"mcpServers\" not in json_data:\n                        json_data[\"mcpServers\"] = {}\n                    json_data[\"mcpServers\"][\"multi-agents-mcp\"] = {\n                        \"command\": \"sh\",\n                        \"args\": [\"-c\", command_str],\n                        \"env\": {}\n                    }\n                    with open(config_path, \"w\") as f:\n                        json.dump(json_data, f, indent=2)\n                    st.success(\"Config Path Updated\")\n            except Exception as e:\n                st.error(str(e))\n\n        if st.button(\"Delete Memories\"):\n            try:\n                mem_dir = str(MEMORY_DIR)\n                if os.path.exists(mem_dir):\n                    import shutil\n                    shutil.rmtree(mem_dir)\n                    os.makedirs(mem_dir, exist_ok=True)\n                    st.success(\"Memories Cleared\")\n            except Exception as e:\n                st.error(str(e))\n\n\n# ==========================================\n# PAGE: COMMUNICATION (Chat)\n# ==========================================\nif st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":", "start_line": 1001, "end_line": 1050}, {"path": "src/interface/app.py", "content": "if st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":\n            # FOCUS MODE STYLES\n            st.markdown(\"\"\"\n            <style>\n            /* Gray out previous messages to focus on input */\n            .stChatMessage { opacity: 0.5; filter: grayscale(0.6); transition: all 0.3s; }\n            /* Highlight Input Area */\n            div[data-testid=\"stChatInput\"] { \n                border: 2px solid #ff3d00 !important; \n                border-radius: 12px;\n                box-shadow: 0 0 15px rgba(255, 61, 0, 0.4) !important;\n                background-color: #fff8f5 !important;\n            }\n            </style>\n            \"\"\", unsafe_allow_html=True)\n            \n\n        else:\n            st.markdown(f\"\"\"<div style=\"background-color: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; border-radius: 8px; text-align: center;\"><span style=\"color: #6c757d; font-size: 0.9em;\">En attente de :</span><br><span style=\"color: #1f1f1f; font-weight: bold; font-size: 1.1em;\">\ud83e\udd16 {current_turn}</span></div>\"\"\", unsafe_allow_html=True)\n    \n    # 1. Reply Context State\n    if \"reply_to\" not in st.session_state:\n        st.session_state.reply_to = None\n\n    # --- FLUX NEURAL (FULL WIDTH) ---\n    \n    # Helper for rendering messages and reply buttons\n    def render_reply_button(sender, content, idx):\n        if st.button(\"\u21a9\ufe0f\", key=f\"btn_reply_set_{idx}\", help=f\"Reply to {sender}\", type=\"tertiary\"):\n            st.session_state.reply_to = {\n                \"sender\": sender,\n                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"", "start_line": 1041, "end_line": 1090}, {"path": "src/interface/app.py", "content": "                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"\n        if is_relevant:\n            # FILTER LOGIC\n            if is_urgent_focus:\n                target = m.get(\"target\")\n                is_replied = m.get(\"replied\", False)\n                # Show only if directed to User AND not replied\n                if target != \"User\" or is_replied:\n                    continue\n            stream_msgs.append((i, m))\n    \n    # Pagination\n    if \"stream_limit\" not in st.session_state: st.session_state.stream_limit = 25\n    total_stream = len(stream_msgs)\n    limit_stream = st.session_state.stream_limit\n    if total_stream > limit_stream:\n            # UI Minimaliste (Tertiary)\n            if st.button(f\"\ud83d\udd03 Historique ({total_stream - limit_stream})\", key=\"load_more_stream\", type=\"tertiary\"):\n                st.session_state.stream_limit += 25\n                st.rerun()\n    \n    visible_stream = stream_msgs[max(0, total_stream - limit_stream):]\n    \n    if not visible_stream:\n        st.info(\"Aucune activit\u00e9 d\u00e9tect\u00e9e sur les bandes neurales.\")\n        \n    for real_idx, m in visible_stream:\n        sender = m.get(\"from\", \"?\")\n        target = m.get(\"target\", \"?\")\n        content = m.get(\"content\", \"\")\n        is_public = m.get(\"public\", False)\n        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        ", "start_line": 1081, "end_line": 1130}, {"path": "src/interface/app.py", "content": "        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        \n        # Style and Tag Logic\n        tag_html = \"\"\n        bubble_style = \"\"\n        \n        if is_public:\n            tag_html = ''\n            bubble_style = \"background-color: rgba(248, 249, 250, 0.8); border-left: 4px solid #2e7d32;\"\n        else:\n            if target == \"User\":\n                tag_html = '<span class=\"status-tag direct-tag\">\ud83d\udd12 Direct Link</span>'\n                if not is_replied:\n                    tag_html += '<span class=\"status-tag urgent-tag\">\u26a1 Action Required</span>'\n                    bubble_style = \"background-color: #fffdf0; border-left: 4px solid #fbc02d; box-shadow: 0 4px 12px rgba(251, 192, 45, 0.12);\"\n                else:\n                    bubble_style = \"background-color: #f0f7ff; border-left: 4px solid #1976d2;\"\n            elif sender == \"User\":\n                tag_html = f'<span class=\"status-tag\">\ud83d\udce4 Outgoing to {target}</span>'\n                bubble_style = \"background-color: #ffffff; border-left: 4px solid #94a3b8;\"\n            else:\n                tag_html = f'<span class=\"status-tag direct-tag\" style=\"background: #ffebee; color: #c62828;\">\ud83d\udd12 Private {sender} \u2192 {target}</span>'\n                bubble_style = \"background-color: #fff8f8; border: 2px dashed #ff4b4b;\"\n\n        with st.chat_message(sender, avatar=sender_emoji):\n            # Header with sender, target and status tags\n            c_header, c_action = st.columns([12, 1])\n            \n            with c_header:\n                st.markdown(f\"\"\"<div class=\"message-header\"><span style=\"font-weight: 700; color: #333; font-size: 0.9em;\">{sender}</span><span style=\"color: #999; font-size: 0.8em;\">\u2192</span><span class=\"target-badge\">{target if target != 'all' else 'everyone'}</span>{tag_html}<span style=\"color: #bbb; font-size: 0.7em; margin-left: auto;\">{time.strftime('%H:%M:%S', time.localtime(timestamp))}</span></div>\"\"\", unsafe_allow_html=True)\n            \n            with c_action:\n                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to", "start_line": 1121, "end_line": 1170}, {"path": "src/interface/app.py", "content": "                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to\n        col_banner, col_x = st.columns([11, 1])\n        with col_banner:\n            st.markdown(f'<div class=\"reply-banner-custom\">\u21a9\ufe0f R\u00e9ponse \u00e0 <b>{ctx[\"sender\"]}</b>: \"{ctx[\"preview\"]}\"</div>', unsafe_allow_html=True)\n        with col_x:\n            if st.button(\"\u2716\ufe0f\", key=\"cancel_reply_v6\", help=\"Annuler\"):\n                st.session_state.reply_to = None\n                st.rerun()\n\n    # 2. Status & Focus Row\n    # (No extra spacer here to avoid empty divs)\n    \n    # 2a. Typing Indicator (Centered)\n    typing_agents = []\n    current_turn_name = turn.get(\"current\")\n    for name, info in agents.items():\n        if name == \"User\": continue\n        if info.get(\"status\") == \"working\" or (name == current_turn_name and info.get(\"status\") == \"connected\"):\n            typing_agents.append(name)\n    \n    if typing_agents:\n        agent_names = \", \".join(typing_agents)\n        plural = \"sont\" if len(typing_agents) > 1 else \"est\"\n        st.markdown(f'<div class=\"typing-container\">{agent_names} {plural} en train d\\'\u00e9crire...<div class=\"typing-dots\"><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div></div></div>', unsafe_allow_html=True)\n    \n    # 2b. Focus Toggle (Removed)\n    c1, c2, c3 = st.columns([1, 1, 1])\n    \n    # MOVED: Banner in bottom right (c3)\n    if turn.get(\"current\") == \"User\":\n        with c3:\n            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n", "start_line": 1161, "end_line": 1210}, {"path": "src/interface/app.py", "content": "            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n\n    # Main Input\n    if prompt := st.chat_input(\"Message...\"):\n        def send_omni_msg(s):\n            target = None\n            public = True\n            reply_ref_id = None\n            \n            # Logic v2.0\n            \n            # 1. Context Reply (Strongest implicit) \n            # Tech Lead said: \"1. Si @Mention -> Priority. 2. Sinon si target_sel != Tous -> Target.\"\n            # Actually Context Reply usually overrides Selector visually, but Mention overrides all?\n            # Let's follow instruction:\n            # 1. Mention check\n            # 2. Selector check\n            # 3. Public\n            \n            found_mentions = []\n            found_mention = False\n            \n            # Mention Check (Specific Agents only)\n            known_agents = sorted(list(agents.keys()), key=len, reverse=True)\n            \n            # Use regex to find all mentions in order of appearance\n            # Sorting known_agents by length reverse ensures longer names are matched first\n            if known_agents:\n                pattern = \"@(\" + \"|\".join([re.escape(name) for name in known_agents]) + \")\"\n                matches = re.finditer(pattern, prompt)\n                seen = set()\n                for match in matches:\n                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True", "start_line": 1201, "end_line": 1250}, {"path": "src/interface/app.py", "content": "                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True\n            else:\n                audience = []\n            \n            if not found_mention:\n                if st.session_state.reply_to:\n                     # Reply Context overrides Selector\n                     target = st.session_state.reply_to[\"sender\"]\n                     reply_ref_id = st.session_state.reply_to[\"id\"]\n                     public = False\n                else:\n                    # No mention, no reply context -> Public Broadcast\n                    target = \"all\"\n                    public = True\n            \n            # Prepare content with Reply Context\n            final_content = prompt\n            if st.session_state.reply_to:\n                ref = st.session_state.reply_to\n                final_content = f\"\u21aa\ufe0f [R\u00e9ponse \u00e0 {ref['sender']}: \\\"{ref['preview']}\\\"]\\n{prompt}\"\n\n            msg = {\n                \"from\": \"User\",\n                \"content\": final_content,\n                \"timestamp\": time.time(),\n                \"public\": public,\n                \"audience\": audience\n            }\n            if target:\n                msg[\"target\"] = target\n            else:\n                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---", "start_line": 1241, "end_line": 1290}, {"path": "src/interface/app.py", "content": "                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---\n            if s.get(\"turn\", {}).get(\"current\") == \"User\":\n                next_speaker = None\n                if target and target != \"all\" and target in s.get(\"agents\", {}):\n                    next_speaker = target\n                else:\n                    # Priority 1: first_agent defined during reset\n                    first_pref = s.get(\"turn\", {}).get(\"first_agent\")\n                    if first_pref and first_pref in s.get(\"agents\", {}):\n                        next_speaker = first_pref\n                    else:\n                        # Fallback to the first connected agent\n                        connected = [n for n, d in s.get(\"agents\", {}).items() if d.get(\"status\") == \"connected\"]\n                        if connected:\n                            next_speaker = connected[0]\n                \n                if next_speaker:\n                    # USE CENTRALIZED TRANSITION LOGIC FROM ENGINE\n                    from src.core.logic import Engine\n                    engine = Engine(state_store) # Use the global state_store\n                    engine._finalize_turn_transition(s, next_speaker)\n\n            # Context Cleanup\n            if reply_ref_id is not None:\n                if reply_ref_id < len(s[\"messages\"]):\n                     s[\"messages\"][reply_ref_id][\"replied\"] = True\n                     \n            return \"Message Transmis.\"\n\n        res = state_store.update(send_omni_msg)\n        st.session_state.reply_to = None\n        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")", "start_line": 1281, "end_line": 1330}, {"path": "src/interface/app.py", "content": "        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")\n    \n    # --- 0. GRAPHVIZ VIEW (TOP) ---\n    with st.expander(\"\ud83d\udd78\ufe0f Topologie de la Flotte (Graphviz)\", expanded=False):\n        try:\n            g = render_graph(profiles)\n            st.graphviz_chart(g, use_container_width=True)\n        except Exception as e:\n            st.error(f\"Erreur de rendu du graphe : {e}\")\n\n    # Scenarios\n    st.subheader(\"\ud83d\udcbe Sc\u00e9narios\")\n    with st.container(border=True):\n        col_scen1, col_scen2 = st.columns(2)\n        if col_scen1.button(\"\ud83d\udcbe Sauvegarder\", use_container_width=True, help=\"Sauvegarder la configuration actuelle\"):\n            save_scenario_dialog(config)\n        if col_scen2.button(\"\ud83d\udcc2 Charger\", use_container_width=True, help=\"Charger une configuration existante\"):\n            load_scenario_dialog()\n\n    # Global Context (Full Width)\n    st.subheader(\"\ud83c\udf0d Contexte Global\")\n    with st.container(border=True):\n        enable_backlog = st.checkbox(\"Backlog\", value=config.get(\"enable_backlog\", False), help=\"Si coch\u00e9, les agents consulteront et mettront \u00e0 jour BACKLOG.md \u00e0 la racine.\")\n        if enable_backlog != config.get(\"enable_backlog\", False):\n            config[\"enable_backlog\"] = enable_backlog\n            save_config(config)\n            st.rerun()\n\n\n        global_context = st.text_area(\"Narratif / Contexte Partag\u00e9\", config.get(\"context\", \"\"), height=215)\n        if global_context != config.get(\"context\", \"\"):\n            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    ", "start_line": 1321, "end_line": 1370}, {"path": "src/interface/app.py", "content": "            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    \n    # Display cards in a grid\n    cols_per_row = 3\n    for i in range(0, len(profiles), cols_per_row):\n        cols = st.columns(cols_per_row)\n        for j in range(cols_per_row):\n            if i + j < len(profiles):\n                p = profiles[i + j]\n                with cols[j]:\n                    with st.container(border=True):\n                        count = int(p.get(\"count\", 0))\n                        emoji = p.get(\"emoji\", \"\ud83e\udd16\")\n                        description = p.get(\"description\", \"Aucune description.\")\n                        \n                        st.markdown(f\"\"\"<div class=\"agent-header\"><div class=\"agent-icon\">{emoji}</div><div class=\"agent-name\">{p['name']}</div></div><div class=\"agent-desc\">{description}</div>\"\"\", unsafe_allow_html=True)\n                        \n                        # Controls inside the card\n                        ctrl_c1, ctrl_c2, ctrl_c3 = st.columns([1, 1.2, 1])\n                        if ctrl_c1.button(\"\u2796\", key=f\"d_{i+j}\", use_container_width=True):\n                            p[\"count\"] = max(0, count - 1)\n                            save_config(config)\n                            st.rerun()\n                        \n                        ctrl_c2.markdown(f'<div class=\"count-display\">{count}</div>', unsafe_allow_html=True)\n                        \n                        if ctrl_c3.button(\"\u2795\", key=f\"i_{i+j}\", use_container_width=True):\n                            p[\"count\"] = count + 1\n                            save_config(config)\n                            st.rerun()\n                            \n                        if st.button(\"\u270f\ufe0f Modifier\", key=f\"ed_{i+j}\", use_container_width=True, type=\"secondary\"):\n                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    ", "start_line": 1361, "end_line": 1410}, {"path": "src/interface/app.py", "content": "                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    \n    # Calculate potential agent IDs the same way reset_logic does\n    temp_slots = []\n    for p in profiles:\n        for _ in range(int(p.get(\"count\", 0))):\n            temp_slots.append(p.get(\"display_name\") or p[\"name\"])\n            \n    counters = {}\n    for base in temp_slots:\n        counters.setdefault(base, 0)\n        counters[base] += 1\n        total_of_this_base = sum(1 for b in temp_slots if b == base)\n        agent_id = f\"{base} #{counters[base]}\" if total_of_this_base > 1 else base\n        potential_agents.append(agent_id)\n\n    # Use session state to persist choice\n    if \"first_speaker\" not in st.session_state:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    # Check if current choice is still valid (profiles might have changed)\n    if st.session_state.first_speaker not in potential_agents:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    selected_first = st.selectbox(\"Qui r\u00e9pondra en premier \u00e0 l'utilisateur ?\", potential_agents,\n                                 index=potential_agents.index(st.session_state.first_speaker) if st.session_state.first_speaker in potential_agents else 0,\n                                 help=\"L'agent qui aura le premier tour pour r\u00e9pondre au premier message de l'utilisateur.\")\n    st.session_state.first_speaker = selected_first\n\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n\n    # --- 3. RESET BUTTON (MODERN) ---\n    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context", "start_line": 1401, "end_line": 1450}, {"path": "src/interface/app.py", "content": "    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context\n                \n                # Use profiles from the state s for absolute consistency\n                current_profiles = s[\"config\"].get(\"profiles\", [])\n                \n                # Update total agents count\n                total_count = get_total_agents(current_profiles)\n                s[\"config\"][\"total_agents\"] = total_count\n                \n                pending_slots = []\n                # Remove random shuffle to maintain profile order\n                for p in current_profiles:\n                    for _ in range(int(p.get(\"count\", 0))):\n                        pending_slots.append({\n                            \"profile_ref\": p[\"name\"],\n                            \"role\": p.get(\"system_prompt\", \"\"),\n                            \"display_base\": p.get(\"display_name\") or p[\"name\"],\n                            \"emoji\": p.get(\"emoji\", \"\ud83e\udd16\")\n                        })\n                \n                new_agents = {}\n                counters = {}\n                for slot in pending_slots:\n                    base = slot[\"display_base\"]\n                    counters.setdefault(base, 0)\n                    counters[base] += 1\n                    agent_id = f\"{base} #{counters[base]}\" if sum(1 for sl in pending_slots if sl[\"display_base\"] == base) > 1 else base\n                    new_agents[agent_id] = {\n                        \"role\": slot[\"role\"], \"status\": \"pending_connection\",\n                        \"profile_ref\": slot[\"profile_ref\"], \"emoji\": slot[\"emoji\"]\n                    }\n                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"", "start_line": 1441, "end_line": 1490}, {"path": "src/interface/app.py", "content": "                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"\n            st.rerun()\n\n\n# ==========================================\n# PAGE: EDITOR (Admin)\n# ==========================================\nelif st.session_state.page == \"Editor\":\n    st.header(\"\ud83d\udee0\ufe0f \u00c9diteur d'Agents\")\n    \n    profile_names = [p[\"name\"] for p in profiles]\n    profile_names.append(\"\u2795 Create New\")\n    \n    sel_idx = 0\n    cur_edit = st.session_state.get(\"editing_agent_name\")\n    if cur_edit in profile_names:\n        sel_idx = profile_names.index(cur_edit)\n        \n    selected_name = st.selectbox(\"Selection Profil\", profile_names, index=sel_idx, key=\"edit_sel_page\")\n    \n    if selected_name == \"\u2795 Create New\":\n        current_profile = {\n            \"name\": \"New Agent\", \n            \"description\": \"\", \n            \"emoji\": \"\ud83e\udd16\", # Default, will be randomized in session state\n            \"connections\": [], \n            \"count\": 1, \n            \"capabilities\": [\"public\"]\n        }\n        new_mode = True\n        st.session_state.editing_agent_name = \"New Agent\"\n        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        ", "start_line": 1481, "end_line": 1530}, {"path": "src/interface/app.py", "content": "        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        \n        if st.button(\"\ud83d\uddd1\ufe0f Supprimer Profil\", type=\"primary\"):\n             config[\"profiles\"] = [p for p in profiles if p[\"name\"] != selected_name]\n             emoji_key = f\"editing_emoji_{selected_name}\"\n             if emoji_key in st.session_state:\n                 del st.session_state[emoji_key]\n             save_config(config)\n             st.rerun()\n\n    if current_profile:\n        st.markdown(\"---\")\n        # Layout Spacieux (Columns)\n        c_main, c_disp = st.columns([3, 2])\n        \n        with c_main:\n            c_emoji, c_name = st.columns([0.18, 0.82])\n            \n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key not in st.session_state:\n                st.session_state[emoji_key] = current_profile.get(\"emoji\", \"\ud83e\udd16\")\n            current_emoji = st.session_state[emoji_key]\n            \n            with c_emoji:\n                st.markdown('<div style=\"height: 28px;\"></div>', unsafe_allow_html=True) # Spacer to align with text input label\n                with st.popover(f\"{current_emoji}\", use_container_width=True):\n                    cols = st.columns(8)\n                    for idx, emoji in enumerate(EMOJI_LIST):\n                        if cols[idx % 8].button(emoji, key=f\"emoji_btn_{selected_name}_{idx}\"):\n                            st.session_state[emoji_key] = emoji\n                            st.rerun()\n            \n            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")", "start_line": 1521, "end_line": 1570}, {"path": "src/interface/app.py", "content": "            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")\n        caps = current_profile.get(\"capabilities\", [])\n        \n        # Preserve other capabilities (e.g. shell_exec)\n        other_caps = [c for c in caps if c not in [\"public\", \"private\"]]\n        \n        has_pub = \"public\" in caps\n        has_priv = \"private\" in caps\n        \n        # Determine default index\n        default_idx = 0 # Public\n        if has_pub and has_priv:\n            default_idx = 2 # Both\n        elif has_priv and not has_pub:\n            default_idx = 1 # Private\n        \n        comm_mode = st.radio(\n            \"Port\u00e9e de Communication\",\n            [\"Public\", \"Priv\u00e9\", \"Les Deux (Public & Priv\u00e9)\"],\n            index=default_idx,\n            key=f\"comm_mode_{selected_name}\",\n            horizontal=True,\n            help=\"D\u00e9finit la port\u00e9e de communication autoris\u00e9e pour cet agent.\"\n        )\n        \n        new_caps = list(other_caps)\n        if comm_mode == \"Public\":\n            new_caps.append(\"public\")\n        elif comm_mode == \"Priv\u00e9\":\n            new_caps.append(\"private\")\n        else:\n            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        ", "start_line": 1561, "end_line": 1610}, {"path": "src/interface/app.py", "content": "            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        \n        new_connections = []\n        \n        # Header for the \"Table\"\n        with st.container():\n            h1, h2, h3 = st.columns([2, 5, 1])\n            h1.markdown(\"**Cible**\")\n            h2.markdown(\"**Condition / Contexte**\")\n            h3.markdown(\"**Active**\")\n            st.markdown(\"<hr style='margin-top: 0; margin-bottom: 10px; border-color: #eee;'>\", unsafe_allow_html=True)\n        \n        for target in targets:\n            # Case-insensitive match for connections\n            existing_conn = next((c for c in current_profile.get(\"connections\", []) if c[\"target\"].lower() == target.lower()), None)\n            \n            c1, c2, c3 = st.columns([2, 5, 1])\n            \n            # Label\n            target_profile = next((p for p in profiles if p[\"name\"] == target), None)\n            target_emoji = \"\ud83c\udf10\" if target == \"public\" else \"\ud83d\udc64\" if target == \"User\" else (target_profile.get(\"emoji\", \"\ud83e\udd16\") if target_profile else \"\ud83e\udd16\")\n            c1.markdown(f\"{target_emoji} **{target}**\")\n            \n            default_ctx = existing_conn.get(\"context\", \"\") if existing_conn else \"\"\n            default_auth = existing_conn.get(\"authorized\", True) if existing_conn else False\n            \n            # Unique key with selected_name and target\n            ctx = c2.text_area(f\"Condition for {target}\", default_ctx, key=f\"conn_ctx_{selected_name}_{target}\", label_visibility=\"collapsed\", height=68)\n            auth = c3.checkbox(f\"Active for {target}\", default_auth, key=f\"conn_auth_{selected_name}_{target}\", label_visibility=\"collapsed\")\n            \n            if auth or ctx:\n                new_connections.append({\"target\": target, \"context\": ctx, \"authorized\": auth})\n            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            ", "start_line": 1601, "end_line": 1650}, {"path": "src/interface/app.py", "content": "            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            \n            # Use the emoji from session state\n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key in st.session_state:\n                current_profile[\"emoji\"] = st.session_state[emoji_key]\n                del st.session_state[emoji_key]\n            \n            if new_mode:\n                profiles.append(current_profile)\n            \n            # Smart renaming\n            if not new_mode and selected_name and new_name != selected_name:\n                for p in profiles:\n                    for conn in p.get(\"connections\", []):\n                        if conn.get(\"target\") == selected_name:\n                            conn[\"target\"] = new_name\n            \n            save_config(config)\n            st.toast(\"Saved!\")\n            st.rerun()\n\n# --- GLOBAL INJECTION (Fixed by Anais) ---\nif st.session_state.page == \"Communication\":\n    # Ensure mentions are injected even if logic flow was broken\n    active_names = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    inject_mention_system(active_names)", "start_line": 1641, "end_line": 1675}, {"path": "src/interface/app.py", "content": "import streamlit as st\nimport streamlit.components.v1 as components\nfrom streamlit_autorefresh import st_autorefresh\nimport graphviz\nimport json\nimport uuid\nimport sys\nimport os\nimport time\nimport re\nimport shutil\nfrom pathlib import Path\n\n# Add src to path to allow imports if run directly\nfrom pathlib import Path\nimport sys\nimport os\n\nCODE_ROOT = Path(__file__).resolve().parent.parent.parent\nif str(CODE_ROOT) not in sys.path:\n    sys.path.append(str(CODE_ROOT))\n\nfrom src.config import (\n    STATE_FILE, \n    MEMORY_DIR, \n    TEMPLATE_DIR, \n    LOCAL_DATA_DIR, \n    GLOBAL_PRESET_DIR, \n    ASSETS_DIR,\n    CODE_ROOT as CONFIG_CODE_ROOT,\n    RELOAD_INSTRUCTION\n)\nfrom src.core.state import StateStore\nfrom src.services.search_engine import SearchEngine\n\nst.set_page_config(page_title=\"Agent Orchestra\", page_icon=\"\ud83e\udd16\", layout=\"wide\")\n\n# --- EMOJI LIST ---\nEMOJI_LIST = [\n    \"\ud83e\udd16\", \"\ud83e\udde0\", \"\ud83d\udd75\ufe0f\", \"\ud83e\uddb8\", \"\ud83e\udd77\", \"\ud83e\uddd9\", \"\ud83e\udddb\", \"\ud83e\udddf\", \"\ud83e\uddde\", \"\ud83e\udddd\",\n    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",", "start_line": 1, "end_line": 50}, {"path": "src/interface/app.py", "content": "    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",\n    \"\ud83e\udda1\", \"\ud83e\udda6\", \"\ud83e\udda5\", \"\ud83d\udc01\", \"\ud83d\udc00\", \"\ud83d\udc3f\ufe0f\", \"\ud83e\udd94\", \"\ud83d\udc3e\", \"\ud83d\udc09\", \"\ud83d\udc32\",\n    \"\ud83c\udf35\", \"\ud83c\udf84\", \"\ud83c\udf32\", \"\ud83c\udf33\", \"\ud83c\udf34\", \"\ud83c\udf31\", \"\ud83c\udf3f\", \"\u2618\ufe0f\", \"\ud83c\udf40\", \"\ud83c\udf43\"\n]\n\ndef get_random_emoji():\n    import random\n    return random.choice(EMOJI_LIST)\n\n# --- HELPER FUNCTIONS ---\ndef inject_custom_css():\n    st.markdown(\"\"\"<style>\n    /* Global message container */\n    [data-testid=\"stChatMessage\"] {\n        padding: 1rem !important;\n        margin-bottom: 1.5rem !important;\n    }\n    \n    [data-testid=\"stChatMessage\"] [data-testid=\"stVerticalBlock\"] {\n        gap: 12px !important;\n    }\n\n    /* Header layout inside message */\n    .message-header {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        margin-bottom: 8px;\n        opacity: 0.85;\n    }\n\n    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    ", "start_line": 41, "end_line": 90}, {"path": "src/interface/app.py", "content": "    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    \n    .reply-banner-custom {\n        background: #f0f7ff;\n        border: 1px solid #d0e7ff;\n        border-radius: 10px;\n        padding: 8px 15px;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        margin-bottom: 8px;\n        font-size: 0.85em;\n        box-shadow: 0 2px 8px rgba(0,0,0,0.05);\n    }\n\n    /* Premium Toggle Styling (Targeting the specific widget) */\n    div[data-testid=\"stToggle\"] {\n        background: #ffffff;\n        padding: 10px 24px !important;\n        border-radius: 50px !important;\n        border: 1px solid #ff4b4b22 !important;\n        box-shadow: 0 4px 15px rgba(0,0,0,0.06) !important;\n        transition: all 0.3s ease !important;\n        width: fit-content !important;\n        margin: 10px auto !important;\n    }\n    \n    div[data-testid=\"stToggle\"]:hover {\n        border-color: #ff4b4b !important;\n        box-shadow: 0 6px 20px rgba(255,75,75,0.12) !important;\n        transform: translateY(-1px);\n    }\n\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;", "start_line": 81, "end_line": 130}, {"path": "src/interface/app.py", "content": "\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;\n        gap: 12px !important;\n        margin: 0 !important;\n    }\n\n    div[data-testid=\"stToggle\"] label p {\n        font-weight: 700 !important;\n        font-size: 0.95em !important;\n        color: #1a1a1a !important;\n        margin: 0 !important;\n        letter-spacing: -0.2px !important;\n    }\n    \n    .target-badge {\n        font-weight: 600;\n        padding: 1px 6px;\n        border-radius: 4px;\n        font-size: 0.75em;\n        color: #444;\n        background: rgba(0,0,0,0.08);\n        border: 1px solid rgba(0,0,0,0.1);\n    }\n    \n    .status-tag {\n        font-size: 0.7em;\n        font-weight: 700;\n        padding: 1px 5px;\n        border-radius: 4px;\n        text-transform: uppercase;\n        letter-spacing: 0.5px;\n    }\n    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;", "start_line": 121, "end_line": 170}, {"path": "src/interface/app.py", "content": "    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        padding: 6px 16px;\n        color: #666;\n        font-size: 0.85em;\n        font-style: italic;\n        background: rgba(0,0,0,0.03);\n        border-radius: 20px;\n        margin: 10px auto;\n        width: fit-content;\n        border: 1px solid rgba(0,0,0,0.05);\n        box-shadow: 0 2px 4px rgba(0,0,0,0.02);\n    }\n    .typing-dots {\n        display: flex; gap: 4px; margin-left: 8px;\n    }\n    .typing-dot {\n        width: 5px; height: 5px; background: #999; border-radius: 50%;\n        animation: typing-bounce 1.4s infinite ease-in-out;\n    }\n    .typing-dot:nth-child(1) { animation-delay: -0.32s; }\n    .typing-dot:nth-child(2) { animation-delay: -0.16s; }\n    @keyframes typing-bounce {\n        0%, 80%, 100% { transform: translateY(0); opacity: 0.3; }\n        40% { transform: translateY(-3px); opacity: 1; }\n    }\n    </style>\"\"\", unsafe_allow_html=True)\n\ninject_custom_css()\n\n# --- INITIALIZE STATE (ONCE) ---\nstate_store = StateStore()\n\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n", "start_line": 161, "end_line": 210}, {"path": "src/interface/app.py", "content": "\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n\ndef save_config(new_config):\n    def update_fn(s):\n        s[\"config\"] = new_config\n        return \"Config Saved\"\n    state_store.update(update_fn)\n\n\n# --- SEARCH ENGINE INIT ---\n@st.cache_resource\ndef init_search_engine():\n    engine = SearchEngine()\n    # Ensure directory exists for persist\n    persist = LOCAL_DATA_DIR / \"vector_store\"\n    persist.mkdir(parents=True, exist_ok=True)\n    engine.initialize(root_dir=CODE_ROOT, persist_dir=persist)\n    return engine\n\n# Initialize background service\nsearch_engine = init_search_engine()\n\n\n# --- DIALOGS ---\ndef handle_disconnect_agent(agent_name):\n    \"\"\"\n    Sets the reload_active flag for the agent.\n    Does NOT set 'pending_connection' immediately (Agent must do it via disconnect tool).\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = True\n            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }", "start_line": 201, "end_line": 250}, {"path": "src/interface/app.py", "content": "            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }\n            s.setdefault(\"messages\", []).append(msg)\n            \n        return f\"Signal de rechargement envoy\u00e9 \u00e0 : {agent_name}\"\n    \n    state_store.update(update_fn)\n    st.toast(f\"Reload signal sent to {agent_name} \ud83d\udd01\")\n\ndef force_disconnect_agent(agent_name):\n    \"\"\"\n    Forces status to pending_connection immediately.\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = False # Reset flag\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n        return f\"Force disconnect: {agent_name}\"\n    state_store.update(update_fn)\n    st.toast(f\"\u2620\ufe0f Force Disconnect: {agent_name}\")\n\nPRESET_DIR = GLOBAL_PRESET_DIR\n\n@st.dialog(\"Sauvegarder le Sc\u00e9nario\")\ndef save_scenario_dialog(current_config):\n    save_name = st.text_input(\"Nom de Sauvegarde\", placeholder=\"mon_scenario\")\n    if st.button(\"Confirmer la Sauvegarde\", use_container_width=True):\n        if save_name:\n            # Basic filename cleaning\n            filename = \"\".join([c for c in save_name if c.isalnum() or c in (' ', '.', '_', '-')]).rstrip()\n            path = PRESET_DIR / f\"{filename}.json\"\n            with open(path, \"w\") as f:\n                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")", "start_line": 241, "end_line": 290}, {"path": "src/interface/app.py", "content": "                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")\n                except Exception as e:\n                    # Non-blocking, just dev convenience\n                    print(f\"Failed to sync to repo: {e}\")\n            st.success(f\"Sauvegard\u00e9 : {filename}\")\n            time.sleep(1)\n            st.rerun()\n        else:\n            st.error(\"Veuillez entrer un nom.\")\n\n@st.dialog(\"Charger un Sc\u00e9nario\")\ndef load_scenario_dialog():\n    # Unified Source: User Global Presets\n    # (Defaults have been synced here by sync_presets)\n    presets = sorted([f for f in os.listdir(PRESET_DIR) if f.endswith(\".json\")])\n    \n    if not presets:\n        st.warning(\"Aucun sc\u00e9nario trouv\u00e9.\")\n        return\n\n    options = [f\"\ud83d\udcbe {f}\" for f in presets]\n    path_map = {f\"\ud83d\udcbe {f}\": PRESET_DIR / f for f in presets}\n        \n    selected_label = st.selectbox(\"Choisir un Preset\", options)\n    \n    c_load, c_del = st.columns([0.85, 0.15])\n    \n    with c_load:\n        if st.button(\"Charger la Configuration\", use_container_width=True, type=\"primary\"):\n            if selected_label:\n                path = path_map[selected_label]\n                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)", "start_line": 281, "end_line": 330}, {"path": "src/interface/app.py", "content": "                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)\n                st.rerun()\n                \n    with c_del:\n        if st.button(\"\ud83d\uddd1\ufe0f\", key=\"del_scen_btn\", help=\"Supprimer d\u00e9finivement\", use_container_width=True):\n             if selected_label:\n                 path = path_map[selected_label]\n                 try:\n                     os.remove(path)\n                     st.toast(f\"Sc\u00e9nario supprim\u00e9: {selected_label}\")\n                     time.sleep(0.7)\n                     st.rerun()\n                 except Exception as e:\n                     st.error(f\"Erreur: {e}\")\n\ndef get_total_agents(profiles):\n    total = 0\n    for p in profiles:\n        try:\n            total += int(p.get(\"count\", 0))\n        except:\n            pass\n    return total\n\ndef format_mentions(text):\n    if not text: return text\n    \n    # 1. First decorate @everyone\n    text = re.sub(\n        r'(@everyone)',\n        r'<span style=\"color: #ffffff; background-color: #ff4b4b; padding: 2px 8px; border-radius: 6px; font-weight: 700; font-size: 0.9em; box-shadow: 0 2px 4px rgba(255,75,75,0.3);\">\\1</span>',\n        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )", "start_line": 321, "end_line": 370}, {"path": "src/interface/app.py", "content": "        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )\n\ndef render_graph(profiles, current_editing=None):\n    graph = graphviz.Digraph()\n    graph.attr(rankdir='LR', size='12,2', ratio='fill', bgcolor='transparent', margin='0')\n    \n    # Add User node\n    graph.node(\"User\", label=\"\ud83d\udc64 User\", style='filled', fillcolor='lightgrey', shape='circle', fontsize='10', height='0.5')\n    \n    for p in profiles:\n        name = p[\"name\"]\n        color = 'lightblue'\n        if current_editing and name == current_editing:\n            color = 'gold'\n        count = p.get(\"count\", 0)\n        label = f\"{name}\\n(x{count})\"\n        graph.node(name, label=label, style='filled', fillcolor=color, shape='box', fontsize='10', height='0.5')\n\n    for p in profiles:\n        source = p[\"name\"]\n        for conn in p.get(\"connections\", []):\n            target = conn.get(\"target\")\n            is_auth = conn.get(\"authorized\", True)\n            if is_auth and (target == \"User\" or any(prof[\"name\"] == target for prof in profiles)):\n                graph.edge(source, target, fontsize='8', color='gray', arrowsize='0.5')\n    return graph\n\ndef inject_mention_system(agent_names):\n    import json\n    agents_json = json.dumps(agent_names)\n    \n    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;", "start_line": 361, "end_line": 410}, {"path": "src/interface/app.py", "content": "    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;\n            const textarea = doc.querySelector('textarea[data-testid=\"stChatInputTextArea\"]');\n            \n            if (!textarea) {{\n                // Polled by setInterval, so just return\n                return;\n            }}\n\n            // Cleanup previous interaction from this or previous iframes\n            // We use a custom property on the DOM node to store the controller\n            if (textarea._mentionController) {{\n                // If the controller belongs to a DEAD iframe, this might fail or succeed. \n                // But mostly it allows us to signal \"Stop Listing\".\n                try {{\n                    textarea._mentionController.abort();\n                }} catch(e) {{}}\n            }}\n\n            // Create new controller for this instance\n            const controller = new AbortController();\n            textarea._mentionController = controller;\n            const signal = controller.signal;\n\n            let menu = doc.getElementById('mention-menu');\n            if (!menu) {{\n                menu = doc.createElement('div');\n                menu.id = 'mention-menu';\n                Object.assign(menu.style, {{\n                    display: 'none',\n                    position: 'fixed',\n                    background: 'white',\n                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);", "start_line": 401, "end_line": 450}, {"path": "src/interface/app.py", "content": "                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);\n            }}\n\n            // Inject styles\n            if (!doc.getElementById('mention-styles')) {{\n                const style = doc.createElement('style');\n                style.id = 'mention-styles';\n                style.innerHTML = `\n                    .mention-item:hover {{\n                        background-color: #f0f2f6 !important;\n                    }}\n                `;\n                doc.head.appendChild(style);\n            }}\n\n            textarea.addEventListener('input', (e) => {{\n                if (e.isComposing) return;\n                const value = textarea.value;\n                const cursorPos = textarea.selectionStart;\n                const textBeforeCursor = value.substring(0, cursorPos);\n                const mentionMatch = textBeforeCursor.match(/@([\\\\w\\\\s#]*)$/);\n\n                if (mentionMatch) {{\n                    isVisible = true;\n                    currentFilter = mentionMatch[1].toLowerCase();\n                    renderMenu(textarea);\n                }} else {{\n                    hideMenu();\n                }}\n            }}, {{ signal }});\n\n            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;", "start_line": 441, "end_line": 490}, {"path": "src/interface/app.py", "content": "            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'ArrowUp') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex - 1 + filtered.length) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'Enter' || e.key === 'Tab') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    insertMention(textarea, filtered[selectedIndex]);\n                }} else if (e.key === 'Escape') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    hideMenu();\n                }}\n            }}, {{ capture: true, signal: signal }});\n        }}\n\n        function renderMenu(textarea) {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n            \n            if (filtered.length === 0) {{\n                hideMenu();\n                return;\n            }}\n\n            menu.innerHTML = filtered.map((a, i) => `\n                <div class=\"mention-item\" style=\"\n                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">", "start_line": 481, "end_line": 530}, {"path": "src/interface/app.py", "content": "                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">\n                    <span style=\"font-weight: ${{i === selectedIndex ? '600' : '400'}};\">@${{a}}</span>\n                    ${{a === 'everyone' ? '<span style=\"font-size: 10px; background: #ff4b4b; color: white; padding: 1px 4px; border-radius: 4px; margin-left: 5px;\">PUBLIC</span>' : ''}}\n                </div>\n            `).join('');\n\n            const rect = textarea.getBoundingClientRect();\n            menu.style.display = 'block';\n            menu.style.left = rect.left + 'px';\n            \n            // Position above the textarea\n            menu.style.bottom = (window.parent.innerHeight - rect.top + 10) + 'px';\n            isVisible = true;\n        }}\n\n        function insertMention(textarea, name) {{\n            const value = textarea.value;\n            const cursorPos = textarea.selectionStart;\n            const textBeforeCursor = value.substring(0, cursorPos);\n            const textAfterCursor = value.substring(cursorPos);\n            \n            const newTextBefore = textBeforeCursor.replace(/@([\\\\w\\\\s#]*)$/, '@' + name + ' ');\n            const newValue = newTextBefore + textAfterCursor;\n\n            // Robust React state update\n            const nativeTextareaValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, \"value\").set;\n            nativeTextareaValueSetter.call(textarea, newValue);\n            \n            // Trigger events\n            textarea.dispatchEvent(new Event('input', {{ bubbles: true }}));\n            textarea.dispatchEvent(new Event('change', {{ bubbles: true }}));\n\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{", "start_line": 521, "end_line": 570}, {"path": "src/interface/app.py", "content": "\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            if (menu) menu.style.display = 'none';\n            isVisible = false;\n            selectedIndex = 0;\n        }}\n\n        // Initial setup & Polling for re-mounts\n        setInterval(setupMentions, 1000);\n    }})();\n    </script>\n    \"\"\"\n    components.html(components_code, height=0)\n\n# --- MAIN LOGIC ---\n\n# 1. Load Data\nstate, config = load_config()\ndata = state\nprofiles = config.get(\"profiles\", [])\nagents = data.get(\"agents\", {})\nturn = data.get(\"turn\", {})\nmessages = data.get(\"messages\", [])\n\n# --- CSS STYLING ---\nst.markdown(\"\"\"\n<style>\n    div[data-testid=\"stSidebar\"] {\n        background-color: #f0f2f6;\n    }\n    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;", "start_line": 561, "end_line": 610}, {"path": "src/interface/app.py", "content": "    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;\n    }\n    /* Agent Card Styling */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] {\n        background-color: white;\n        border-radius: 16px !important;\n        border: 1px solid #f0f0f0 !important;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.04);\n        padding: 0.5rem;\n        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    }\n    [data-testid=\"stVerticalBlockBorderWrapper\"]:hover {\n        transform: translateY(-4px);\n        box-shadow: 0 12px 24px rgba(0,0,0,0.08);\n        border-color: #ff4b4b44 !important;\n    }\n    .agent-header {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 12px;\n    }\n    .agent-icon {\n        font-size: 1.5em;\n        background: #f8f9fa;\n        width: 42px;\n        height: 42px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 10px;\n        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;", "start_line": 601, "end_line": 650}, {"path": "src/interface/app.py", "content": "        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;\n        color: #64748b;\n        margin-bottom: 1rem;\n        min-height: 4.2em;\n        line-height: 1.5;\n    }\n    .count-display {\n        background: #f1f5f9;\n        color: #0f172a;\n        height: 2.4em;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 8px;\n        font-weight: 700;\n        font-size: 1.1em;\n    }\n    /* Compact buttons in cards */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] .stButton button {\n        height: 2.4em !important;\n    }\n    .reset-button-container {\n        display: flex;\n        justify-content: center;\n        padding: 20px;\n    }\n    @keyframes pulse-gold {\n        0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }\n        70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }\n        100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }\n    }\n    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:", "start_line": 641, "end_line": 690}, {"path": "src/interface/app.py", "content": "    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:\n    st.session_state.page = \"Communication\"\n\n# --- SIDEBAR ---\nwith st.sidebar:\n    st.title(\"\ud83e\udd16 Orchestra\")\n    \n    # Global Autorefresh (Active on all pages to catch messages)\n    st_autorefresh(interval=4000, key=\"global_pulse\")\n\n    st.markdown(\"### Navigation\")\n    \n    # --- NOTIFICATION LOGIC ---\n    total_msgs = len(messages)\n    if \"last_read_count\" not in st.session_state:\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    unread = 0\n    if st.session_state.page != \"Communication\":\n        unread = max(0, total_msgs - st.session_state.last_read_count)\n        \n        # Toast for new messages\n        if \"last_toast_count\" not in st.session_state:\n             st.session_state.last_toast_count = total_msgs\n             \n        if total_msgs > st.session_state.last_toast_count:\n             new_count = total_msgs - st.session_state.last_toast_count\n             # Toast the last one\n             newest = messages[-1]\n             sender = newest.get(\"from\", \"?\")\n             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"", "start_line": 681, "end_line": 730}, {"path": "src/interface/app.py", "content": "             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"\n    if unread > 0:\n        label_comm = f\"\ud83d\udcac Chat ({unread} \ud83d\udd34)\"\n\n    if st.button(label_comm, use_container_width=True, type=\"primary\" if st.session_state.page == \"Communication\" else \"secondary\"):\n        st.session_state.page = \"Communication\"\n        st.rerun()\n        \n    if st.button(\"\ud83c\udf9b\ufe0f Cockpit\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Cockpit\" else \"secondary\"):\n        st.session_state.page = \"Cockpit\"\n        st.rerun()\n        \n    if st.button(\"\ud83d\udee0\ufe0f \u00c9diteur\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Editor\" else \"secondary\"):\n        st.session_state.page = \"Editor\"\n        st.rerun()\n\n    st.divider()\n    \n    # 1. Identity / User Status\n    st.markdown(\"### \ud83d\udc64 Identity\")\n    user_status = config.get(\"user_availability\", \"busy\")\n    \n    # User status toggle\n    is_available = st.toggle(\"Available\", value=(user_status == \"available\"), help=\"Switch between Available (\ud83d\udfe2) and Busy (\ud83d\udd34)\")\n    new_status = \"available\" if is_available else \"busy\"\n    \n    if new_status != user_status:\n        config[\"user_availability\"] = new_status\n        save_config(config)\n        st.rerun()\n\n    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:", "start_line": 721, "end_line": 770}, {"path": "src/interface/app.py", "content": "    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:\n        config[\"language\"] = new_lang\n        save_config(config)\n        st.rerun()\n\n\n\n    st.divider()\n    \n    # Search Config\n    st.markdown(\"### \ud83d\udd0e Search Engine\")\n    \n    # Status Indicator\n    if search_engine and search_engine.initialized:\n        dev_label = search_engine.device.upper().replace(\"\u201d\", \"\") # Fix typo if any from previous edit\n        st.caption(f\"Status: **Active** | Device: **{dev_label}** \u26a1\")\n    else:\n        st.caption(\"Status: \ud83d\udd34 Disabled (Missing Deps)\")\n\n    search_conf = config.get(\"search\", {})\n    \n    sc1, sc2 = st.columns(2)\n    with sc1:\n        x_val = st.number_input(\"Context (X)\", min_value=0, max_value=10, value=search_conf.get(\"x_markdown\", 3), help=\"Number of full markdown result to inject (Passive)\")\n    with sc2:\n        y_val = st.number_input(\"Total (Y)\", min_value=1, max_value=50, value=search_conf.get(\"y_total\", 15), help=\"Default limit for Search Tool\")\n        \n    if x_val != search_conf.get(\"x_markdown\", 3) or y_val != search_conf.get(\"y_total\", 15):\n        if \"search\" not in config: config[\"search\"] = {}\n        config[\"search\"][\"x_markdown\"] = x_val\n        config[\"search\"][\"y_total\"] = y_val\n        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"", "start_line": 761, "end_line": 810}, {"path": "src/interface/app.py", "content": "        save_config(config)\n        st.toast(\"Search config saved!\")\n        time.sleep(0.5)\n        st.rerun()\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"\n        <div style=\"display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;\">\n            <h3 style=\"margin: 0; font-size: 1.2em;\">\ud83d\udc65 Agents Actifs</h3>\n            <span style=\"background: #e0e0e0; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold;\">{connected_count}</span>\n        </div>\n    \"\"\", unsafe_allow_html=True)\n    \n    # Maintain original order from agents dictionary\n    roster_list = [name for name in agents.keys()]\n    \n    # Explicitly add User to the top\n    roster_list.insert(0, \"User\")\n    \n    current_turn = turn.get(\"current\")\n    \n    if not roster_list:\n        st.caption(\"Aucun agent d\u00e9tect\u00e9.\")\n    else:\n        for name in roster_list:\n            # Handle User specifically since they are not in 'agents' dict\n            if name == \"User\":\n                u_avail = config.get(\"user_availability\", \"busy\")\n                # Map 'available' -> 'connected' (Green), 'busy' -> 'working' (Blue/Busy look)\n                info = {\n                    \"status\": \"connected\" if u_avail == \"available\" else \"working\",\n                    \"emoji\": \"\ud83d\udc64\"\n                }\n            else:\n                info = agents[name]\n            status = info.get(\"status\", \"pending\")\n            emoji = info.get(\"emoji\", \"\ud83e\udd16\")\n            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":", "start_line": 801, "end_line": 850}, {"path": "src/interface/app.py", "content": "            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":\n                status_color = \"#4CAF50\" # Green\n                status_label = \"En ligne\"\n                bg = \"rgba(76, 175, 80, 0.05)\"\n                border_color = \"rgba(76, 175, 80, 0.2)\"\n            elif status == \"pending_connection\":\n                status_color = \"#FF9800\" # Orange\n                status_label = \"Attente Reconnexion\"\n                bg = \"rgba(255, 152, 0, 0.05)\"\n                border_color = \"rgba(255, 152, 0, 0.2)\"\n            elif status == \"working\":\n                status_color = \"#2196F3\" # Blue\n                status_label = \"Travaille...\"\n                bg = \"rgba(33, 150, 243, 0.05)\"\n                border_color = \"rgba(33, 150, 243, 0.2)\"\n            else:\n                status_color = \"#9E9E9E\" # Grey\n                status_label = \"Hors-ligne\"\n                bg = \"transparent\"\n                border_color = \"#eee\"\n            \n            # Additional pulse if it's their turn and they are connected\n            is_active_working = is_turn and status == \"connected\"\n            if is_active_working:\n                status_color = \"#2196F3\"\n                status_label = \"En action...\"\n            \n            card_html = f\"\"\"<div class=\"{card_class}\" style=\"background-color: {bg}; border: 1px solid {border_color}; border-radius: 10px; padding: 10px 14px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s ease;\"><div style=\"display: flex; align-items: center; gap: 12px;\"><div style=\"font-size: 1.4em; background: white; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);\">{emoji}</div><div style=\"display: flex; flex-direction: column;\"><span style=\"font-weight: 600; color: {'#1a1a1a' if status == 'connected' else '#666'}; font-size: 0.95em;\">{name}</span><div style=\"display: flex; align-items: center; gap: 4px;\"><div style=\"width: 6px; height: 6px; background-color: {status_color}; border-radius: 50%;\"></div><span style=\"font-size: 0.7em; color: {status_color}; font-weight: 500; letter-spacing: 0.5px;\">{status_label}</span></div></div></div>{'<span style=\"font-size: 1.2em;\" title=\"C&rsquo;est son tour !\">\u2728</span>' if is_turn else ''}</div>\"\"\"\n            \n            if name == \"User\":\n                st.markdown(card_html, unsafe_allow_html=True)\n            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))", "start_line": 841, "end_line": 890}, {"path": "src/interface/app.py", "content": "            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))\n\n                    if is_reloading:\n                        if st.button(\"\u274c\", key=f\"force_{name}\", help=\"Force Disconnect (Si bloqu\u00e9)\", type=\"primary\"):\n                             force_disconnect_agent(name)\n                             # Also remove from queue if present to unblock sequence\n                             if name in st.session_state.get(\"reload_queue\", []):\n                                 st.session_state.reload_queue.remove(name)\n                             st.rerun()\n                    else:\n                        if st.button(\"\ud83d\udd04\", key=f\"reload_{name}\", help=f\"Recharger {name}\"):\n                            handle_disconnect_agent(name)\n                            st.rerun()\n            \n    st.markdown(\"<div style='height: 10px;'></div>\", unsafe_allow_html=True)\n    if st.button(\"\ud83d\udd04 Reload All Agents\", type=\"secondary\", use_container_width=True, help=\"S\u00e9quence de rechargement (Parall\u00e8le).\"):\n         # Identify Targets\n        to_reload = [\n            n for n, d in agents.items() \n            if d.get(\"status\") in [\"connected\", \"working\"] \n        ]\n        if not to_reload:\n            st.toast(\"Aucun agent actif \u00e0 recharger.\")\n        else:\n            # START PARALLEL SEQUENCE\n            st.session_state.reload_queue = list(to_reload)\n            \n            # Atomic Bulk Update\n            def bulk_reload_signal(s):\n                count = 0\n                for name in to_reload:\n                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,", "start_line": 881, "end_line": 930}, {"path": "src/interface/app.py", "content": "                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,\n                            \"target\": name,\n                            \"timestamp\": time.time()\n                         }\n                         s.setdefault(\"messages\", []).append(msg)\n                         count += 1\n                return f\"Signal de rechargement global envoy\u00e9 ({count} agents).\"\n            \n            state_store.update(bulk_reload_signal)\n            st.toast(f\"S\u00e9quence de rechargement PARALL\u00c8LE initialis\u00e9e pour {len(to_reload)} agents.\")\n            st.rerun()\n\n    # --- SEQUENTIAL RELOAD PROCESSOR ---\n    # Global Processor for the Queue\n    if \"reload_queue\" in st.session_state and st.session_state.reload_queue:\n        current_target = st.session_state.reload_queue[0]\n        \n        # Check current status (Refetch from fresh state)\n        if current_target in agents:\n            agent_data = agents[current_target]\n            status = agent_data.get(\"status\")\n            is_reload_active = agent_data.get(\"reload_active\")\n            \n            # Condition 1: Agent is finished (Disconnect/Pending)\n            if status in [\"pending_connection\", \"disconnected\", \"offline\"]:\n                st.session_state.reload_queue.pop(0) # Done\n                st.rerun() # Proceed to next immediately\n                \n            # Condition 2: Agent needs to be signaled\n            elif not is_reload_active:\n                 handle_disconnect_agent(current_target)\n                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()", "start_line": 921, "end_line": 970}, {"path": "src/interface/app.py", "content": "                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()\n\n    st.divider()\n\n    # --- PAUSE CONTROL ---\n    is_paused = config.get(\"paused\", False)\n    if st.toggle(\"\u23f8\ufe0f PAUSE MCP\", value=is_paused, help=\"Fige le temps pour tous les agents.\"):\n        if not is_paused:\n            config[\"paused\"] = True\n            save_config(config)\n            st.rerun()\n    else:\n        if is_paused:\n            config[\"paused\"] = False\n            save_config(config)\n            st.rerun()\n            \n    if is_paused:\n        st.warning(\"\u26a0\ufe0f SIMULATION EN PAUSE\")\n    \n    st.divider()\n\n    \n    # Debug Tools\n    with st.expander(\"\ud83d\udd27 DEBUG\"):\n        st.markdown(\"### \u2702\ufe0f MCP Truncation Settings\")\n        current_trunc = config.get(\"truncation_limit\", 4096) # Default 4096\n        new_trunc = st.number_input(\"Max Character Limit (0 = Disabled)\", min_value=0, value=int(current_trunc), step=100, help=\"Limite manuelle pour \u00e9viter le tronquage silencieux du client MCP (4096 bytes max).\")\n        if new_trunc != current_trunc:\n             config[\"truncation_limit\"] = int(new_trunc)\n             save_config(config)\n             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)", "start_line": 961, "end_line": 1010}, {"path": "src/interface/app.py", "content": "             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)\n                    server_script = os.path.join(current_dir, \"src\", \"core\", \"server.py\")\n                    command_str = f\"cd {current_dir} && uv run python {server_script}\"\n                    if \"mcpServers\" not in json_data:\n                        json_data[\"mcpServers\"] = {}\n                    json_data[\"mcpServers\"][\"multi-agents-mcp\"] = {\n                        \"command\": \"sh\",\n                        \"args\": [\"-c\", command_str],\n                        \"env\": {}\n                    }\n                    with open(config_path, \"w\") as f:\n                        json.dump(json_data, f, indent=2)\n                    st.success(\"Config Path Updated\")\n            except Exception as e:\n                st.error(str(e))\n\n        if st.button(\"Delete Memories\"):\n            try:\n                mem_dir = str(MEMORY_DIR)\n                if os.path.exists(mem_dir):\n                    import shutil\n                    shutil.rmtree(mem_dir)\n                    os.makedirs(mem_dir, exist_ok=True)\n                    st.success(\"Memories Cleared\")\n            except Exception as e:\n                st.error(str(e))\n\n\n# ==========================================\n# PAGE: COMMUNICATION (Chat)\n# ==========================================\nif st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":", "start_line": 1001, "end_line": 1050}, {"path": "src/interface/app.py", "content": "if st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":\n            # FOCUS MODE STYLES\n            st.markdown(\"\"\"\n            <style>\n            /* Gray out previous messages to focus on input */\n            .stChatMessage { opacity: 0.5; filter: grayscale(0.6); transition: all 0.3s; }\n            /* Highlight Input Area */\n            div[data-testid=\"stChatInput\"] { \n                border: 2px solid #ff3d00 !important; \n                border-radius: 12px;\n                box-shadow: 0 0 15px rgba(255, 61, 0, 0.4) !important;\n                background-color: #fff8f5 !important;\n            }\n            </style>\n            \"\"\", unsafe_allow_html=True)\n            \n\n        else:\n            st.markdown(f\"\"\"<div style=\"background-color: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; border-radius: 8px; text-align: center;\"><span style=\"color: #6c757d; font-size: 0.9em;\">En attente de :</span><br><span style=\"color: #1f1f1f; font-weight: bold; font-size: 1.1em;\">\ud83e\udd16 {current_turn}</span></div>\"\"\", unsafe_allow_html=True)\n    \n    # 1. Reply Context State\n    if \"reply_to\" not in st.session_state:\n        st.session_state.reply_to = None\n\n    # --- FLUX NEURAL (FULL WIDTH) ---\n    \n    # Helper for rendering messages and reply buttons\n    def render_reply_button(sender, content, idx):\n        if st.button(\"\u21a9\ufe0f\", key=f\"btn_reply_set_{idx}\", help=f\"Reply to {sender}\", type=\"tertiary\"):\n            st.session_state.reply_to = {\n                \"sender\": sender,\n                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"", "start_line": 1041, "end_line": 1090}, {"path": "src/interface/app.py", "content": "                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"\n        if is_relevant:\n            # FILTER LOGIC\n            if is_urgent_focus:\n                target = m.get(\"target\")\n                is_replied = m.get(\"replied\", False)\n                # Show only if directed to User AND not replied\n                if target != \"User\" or is_replied:\n                    continue\n            stream_msgs.append((i, m))\n    \n    # Pagination\n    if \"stream_limit\" not in st.session_state: st.session_state.stream_limit = 25\n    total_stream = len(stream_msgs)\n    limit_stream = st.session_state.stream_limit\n    if total_stream > limit_stream:\n            # UI Minimaliste (Tertiary)\n            if st.button(f\"\ud83d\udd03 Historique ({total_stream - limit_stream})\", key=\"load_more_stream\", type=\"tertiary\"):\n                st.session_state.stream_limit += 25\n                st.rerun()\n    \n    visible_stream = stream_msgs[max(0, total_stream - limit_stream):]\n    \n    if not visible_stream:\n        st.info(\"Aucune activit\u00e9 d\u00e9tect\u00e9e sur les bandes neurales.\")\n        \n    for real_idx, m in visible_stream:\n        sender = m.get(\"from\", \"?\")\n        target = m.get(\"target\", \"?\")\n        content = m.get(\"content\", \"\")\n        is_public = m.get(\"public\", False)\n        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        ", "start_line": 1081, "end_line": 1130}, {"path": "src/interface/app.py", "content": "        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        \n        # Style and Tag Logic\n        tag_html = \"\"\n        bubble_style = \"\"\n        \n        if is_public:\n            tag_html = ''\n            bubble_style = \"background-color: rgba(248, 249, 250, 0.8); border-left: 4px solid #2e7d32;\"\n        else:\n            if target == \"User\":\n                tag_html = '<span class=\"status-tag direct-tag\">\ud83d\udd12 Direct Link</span>'\n                if not is_replied:\n                    tag_html += '<span class=\"status-tag urgent-tag\">\u26a1 Action Required</span>'\n                    bubble_style = \"background-color: #fffdf0; border-left: 4px solid #fbc02d; box-shadow: 0 4px 12px rgba(251, 192, 45, 0.12);\"\n                else:\n                    bubble_style = \"background-color: #f0f7ff; border-left: 4px solid #1976d2;\"\n            elif sender == \"User\":\n                tag_html = f'<span class=\"status-tag\">\ud83d\udce4 Outgoing to {target}</span>'\n                bubble_style = \"background-color: #ffffff; border-left: 4px solid #94a3b8;\"\n            else:\n                tag_html = f'<span class=\"status-tag direct-tag\" style=\"background: #ffebee; color: #c62828;\">\ud83d\udd12 Private {sender} \u2192 {target}</span>'\n                bubble_style = \"background-color: #fff8f8; border: 2px dashed #ff4b4b;\"\n\n        with st.chat_message(sender, avatar=sender_emoji):\n            # Header with sender, target and status tags\n            c_header, c_action = st.columns([12, 1])\n            \n            with c_header:\n                st.markdown(f\"\"\"<div class=\"message-header\"><span style=\"font-weight: 700; color: #333; font-size: 0.9em;\">{sender}</span><span style=\"color: #999; font-size: 0.8em;\">\u2192</span><span class=\"target-badge\">{target if target != 'all' else 'everyone'}</span>{tag_html}<span style=\"color: #bbb; font-size: 0.7em; margin-left: auto;\">{time.strftime('%H:%M:%S', time.localtime(timestamp))}</span></div>\"\"\", unsafe_allow_html=True)\n            \n            with c_action:\n                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to", "start_line": 1121, "end_line": 1170}, {"path": "src/interface/app.py", "content": "                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to\n        col_banner, col_x = st.columns([11, 1])\n        with col_banner:\n            st.markdown(f'<div class=\"reply-banner-custom\">\u21a9\ufe0f R\u00e9ponse \u00e0 <b>{ctx[\"sender\"]}</b>: \"{ctx[\"preview\"]}\"</div>', unsafe_allow_html=True)\n        with col_x:\n            if st.button(\"\u2716\ufe0f\", key=\"cancel_reply_v6\", help=\"Annuler\"):\n                st.session_state.reply_to = None\n                st.rerun()\n\n    # 2. Status & Focus Row\n    # (No extra spacer here to avoid empty divs)\n    \n    # 2a. Typing Indicator (Centered)\n    typing_agents = []\n    current_turn_name = turn.get(\"current\")\n    for name, info in agents.items():\n        if name == \"User\": continue\n        if info.get(\"status\") == \"working\" or (name == current_turn_name and info.get(\"status\") == \"connected\"):\n            typing_agents.append(name)\n    \n    if typing_agents:\n        agent_names = \", \".join(typing_agents)\n        plural = \"sont\" if len(typing_agents) > 1 else \"est\"\n        st.markdown(f'<div class=\"typing-container\">{agent_names} {plural} en train d\\'\u00e9crire...<div class=\"typing-dots\"><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div></div></div>', unsafe_allow_html=True)\n    \n    # 2b. Focus Toggle (Removed)\n    c1, c2, c3 = st.columns([1, 1, 1])\n    \n    # MOVED: Banner in bottom right (c3)\n    if turn.get(\"current\") == \"User\":\n        with c3:\n            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n", "start_line": 1161, "end_line": 1210}, {"path": "src/interface/app.py", "content": "            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n\n    # Main Input\n    if prompt := st.chat_input(\"Message...\"):\n        def send_omni_msg(s):\n            target = None\n            public = True\n            reply_ref_id = None\n            \n            # Logic v2.0\n            \n            # 1. Context Reply (Strongest implicit) \n            # Tech Lead said: \"1. Si @Mention -> Priority. 2. Sinon si target_sel != Tous -> Target.\"\n            # Actually Context Reply usually overrides Selector visually, but Mention overrides all?\n            # Let's follow instruction:\n            # 1. Mention check\n            # 2. Selector check\n            # 3. Public\n            \n            found_mentions = []\n            found_mention = False\n            \n            # Mention Check (Specific Agents only)\n            known_agents = sorted(list(agents.keys()), key=len, reverse=True)\n            \n            # Use regex to find all mentions in order of appearance\n            # Sorting known_agents by length reverse ensures longer names are matched first\n            if known_agents:\n                pattern = \"@(\" + \"|\".join([re.escape(name) for name in known_agents]) + \")\"\n                matches = re.finditer(pattern, prompt)\n                seen = set()\n                for match in matches:\n                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True", "start_line": 1201, "end_line": 1250}, {"path": "src/interface/app.py", "content": "                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True\n            else:\n                audience = []\n            \n            if not found_mention:\n                if st.session_state.reply_to:\n                     # Reply Context overrides Selector\n                     target = st.session_state.reply_to[\"sender\"]\n                     reply_ref_id = st.session_state.reply_to[\"id\"]\n                     public = False\n                else:\n                    # No mention, no reply context -> Public Broadcast\n                    target = \"all\"\n                    public = True\n            \n            # Prepare content with Reply Context\n            final_content = prompt\n            if st.session_state.reply_to:\n                ref = st.session_state.reply_to\n                final_content = f\"\u21aa\ufe0f [R\u00e9ponse \u00e0 {ref['sender']}: \\\"{ref['preview']}\\\"]\\n{prompt}\"\n\n            msg = {\n                \"from\": \"User\",\n                \"content\": final_content,\n                \"timestamp\": time.time(),\n                \"public\": public,\n                \"audience\": audience\n            }\n            if target:\n                msg[\"target\"] = target\n            else:\n                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---", "start_line": 1241, "end_line": 1290}, {"path": "src/interface/app.py", "content": "                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---\n            if s.get(\"turn\", {}).get(\"current\") == \"User\":\n                next_speaker = None\n                if target and target != \"all\" and target in s.get(\"agents\", {}):\n                    next_speaker = target\n                else:\n                    # Priority 1: first_agent defined during reset\n                    first_pref = s.get(\"turn\", {}).get(\"first_agent\")\n                    if first_pref and first_pref in s.get(\"agents\", {}):\n                        next_speaker = first_pref\n                    else:\n                        # Fallback to the first connected agent\n                        connected = [n for n, d in s.get(\"agents\", {}).items() if d.get(\"status\") == \"connected\"]\n                        if connected:\n                            next_speaker = connected[0]\n                \n                if next_speaker:\n                    # USE CENTRALIZED TRANSITION LOGIC FROM ENGINE\n                    from src.core.logic import Engine\n                    engine = Engine(state_store) # Use the global state_store\n                    engine._finalize_turn_transition(s, next_speaker)\n\n            # Context Cleanup\n            if reply_ref_id is not None:\n                if reply_ref_id < len(s[\"messages\"]):\n                     s[\"messages\"][reply_ref_id][\"replied\"] = True\n                     \n            return \"Message Transmis.\"\n\n        res = state_store.update(send_omni_msg)\n        st.session_state.reply_to = None\n        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")", "start_line": 1281, "end_line": 1330}, {"path": "src/interface/app.py", "content": "        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")\n    \n    # --- 0. GRAPHVIZ VIEW (TOP) ---\n    with st.expander(\"\ud83d\udd78\ufe0f Topologie de la Flotte (Graphviz)\", expanded=False):\n        try:\n            g = render_graph(profiles)\n            st.graphviz_chart(g, use_container_width=True)\n        except Exception as e:\n            st.error(f\"Erreur de rendu du graphe : {e}\")\n\n    # Scenarios\n    st.subheader(\"\ud83d\udcbe Sc\u00e9narios\")\n    with st.container(border=True):\n        col_scen1, col_scen2 = st.columns(2)\n        if col_scen1.button(\"\ud83d\udcbe Sauvegarder\", use_container_width=True, help=\"Sauvegarder la configuration actuelle\"):\n            save_scenario_dialog(config)\n        if col_scen2.button(\"\ud83d\udcc2 Charger\", use_container_width=True, help=\"Charger une configuration existante\"):\n            load_scenario_dialog()\n\n    # Global Context (Full Width)\n    st.subheader(\"\ud83c\udf0d Contexte Global\")\n    with st.container(border=True):\n        enable_backlog = st.checkbox(\"Backlog\", value=config.get(\"enable_backlog\", False), help=\"Si coch\u00e9, les agents consulteront et mettront \u00e0 jour BACKLOG.md \u00e0 la racine.\")\n        if enable_backlog != config.get(\"enable_backlog\", False):\n            config[\"enable_backlog\"] = enable_backlog\n            save_config(config)\n            st.rerun()\n\n\n        global_context = st.text_area(\"Narratif / Contexte Partag\u00e9\", config.get(\"context\", \"\"), height=215)\n        if global_context != config.get(\"context\", \"\"):\n            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    ", "start_line": 1321, "end_line": 1370}, {"path": "src/interface/app.py", "content": "            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    \n    # Display cards in a grid\n    cols_per_row = 3\n    for i in range(0, len(profiles), cols_per_row):\n        cols = st.columns(cols_per_row)\n        for j in range(cols_per_row):\n            if i + j < len(profiles):\n                p = profiles[i + j]\n                with cols[j]:\n                    with st.container(border=True):\n                        count = int(p.get(\"count\", 0))\n                        emoji = p.get(\"emoji\", \"\ud83e\udd16\")\n                        description = p.get(\"description\", \"Aucune description.\")\n                        \n                        st.markdown(f\"\"\"<div class=\"agent-header\"><div class=\"agent-icon\">{emoji}</div><div class=\"agent-name\">{p['name']}</div></div><div class=\"agent-desc\">{description}</div>\"\"\", unsafe_allow_html=True)\n                        \n                        # Controls inside the card\n                        ctrl_c1, ctrl_c2, ctrl_c3 = st.columns([1, 1.2, 1])\n                        if ctrl_c1.button(\"\u2796\", key=f\"d_{i+j}\", use_container_width=True):\n                            p[\"count\"] = max(0, count - 1)\n                            save_config(config)\n                            st.rerun()\n                        \n                        ctrl_c2.markdown(f'<div class=\"count-display\">{count}</div>', unsafe_allow_html=True)\n                        \n                        if ctrl_c3.button(\"\u2795\", key=f\"i_{i+j}\", use_container_width=True):\n                            p[\"count\"] = count + 1\n                            save_config(config)\n                            st.rerun()\n                            \n                        if st.button(\"\u270f\ufe0f Modifier\", key=f\"ed_{i+j}\", use_container_width=True, type=\"secondary\"):\n                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    ", "start_line": 1361, "end_line": 1410}, {"path": "src/interface/app.py", "content": "                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    \n    # Calculate potential agent IDs the same way reset_logic does\n    temp_slots = []\n    for p in profiles:\n        for _ in range(int(p.get(\"count\", 0))):\n            temp_slots.append(p.get(\"display_name\") or p[\"name\"])\n            \n    counters = {}\n    for base in temp_slots:\n        counters.setdefault(base, 0)\n        counters[base] += 1\n        total_of_this_base = sum(1 for b in temp_slots if b == base)\n        agent_id = f\"{base} #{counters[base]}\" if total_of_this_base > 1 else base\n        potential_agents.append(agent_id)\n\n    # Use session state to persist choice\n    if \"first_speaker\" not in st.session_state:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    # Check if current choice is still valid (profiles might have changed)\n    if st.session_state.first_speaker not in potential_agents:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    selected_first = st.selectbox(\"Qui r\u00e9pondra en premier \u00e0 l'utilisateur ?\", potential_agents,\n                                 index=potential_agents.index(st.session_state.first_speaker) if st.session_state.first_speaker in potential_agents else 0,\n                                 help=\"L'agent qui aura le premier tour pour r\u00e9pondre au premier message de l'utilisateur.\")\n    st.session_state.first_speaker = selected_first\n\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n\n    # --- 3. RESET BUTTON (MODERN) ---\n    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context", "start_line": 1401, "end_line": 1450}, {"path": "src/interface/app.py", "content": "    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context\n                \n                # Use profiles from the state s for absolute consistency\n                current_profiles = s[\"config\"].get(\"profiles\", [])\n                \n                # Update total agents count\n                total_count = get_total_agents(current_profiles)\n                s[\"config\"][\"total_agents\"] = total_count\n                \n                pending_slots = []\n                # Remove random shuffle to maintain profile order\n                for p in current_profiles:\n                    for _ in range(int(p.get(\"count\", 0))):\n                        pending_slots.append({\n                            \"profile_ref\": p[\"name\"],\n                            \"role\": p.get(\"system_prompt\", \"\"),\n                            \"display_base\": p.get(\"display_name\") or p[\"name\"],\n                            \"emoji\": p.get(\"emoji\", \"\ud83e\udd16\")\n                        })\n                \n                new_agents = {}\n                counters = {}\n                for slot in pending_slots:\n                    base = slot[\"display_base\"]\n                    counters.setdefault(base, 0)\n                    counters[base] += 1\n                    agent_id = f\"{base} #{counters[base]}\" if sum(1 for sl in pending_slots if sl[\"display_base\"] == base) > 1 else base\n                    new_agents[agent_id] = {\n                        \"role\": slot[\"role\"], \"status\": \"pending_connection\",\n                        \"profile_ref\": slot[\"profile_ref\"], \"emoji\": slot[\"emoji\"]\n                    }\n                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"", "start_line": 1441, "end_line": 1490}, {"path": "src/interface/app.py", "content": "                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"\n            st.rerun()\n\n\n# ==========================================\n# PAGE: EDITOR (Admin)\n# ==========================================\nelif st.session_state.page == \"Editor\":\n    st.header(\"\ud83d\udee0\ufe0f \u00c9diteur d'Agents\")\n    \n    profile_names = [p[\"name\"] for p in profiles]\n    profile_names.append(\"\u2795 Create New\")\n    \n    sel_idx = 0\n    cur_edit = st.session_state.get(\"editing_agent_name\")\n    if cur_edit in profile_names:\n        sel_idx = profile_names.index(cur_edit)\n        \n    selected_name = st.selectbox(\"Selection Profil\", profile_names, index=sel_idx, key=\"edit_sel_page\")\n    \n    if selected_name == \"\u2795 Create New\":\n        current_profile = {\n            \"name\": \"New Agent\", \n            \"description\": \"\", \n            \"emoji\": \"\ud83e\udd16\", # Default, will be randomized in session state\n            \"connections\": [], \n            \"count\": 1, \n            \"capabilities\": [\"public\"]\n        }\n        new_mode = True\n        st.session_state.editing_agent_name = \"New Agent\"\n        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        ", "start_line": 1481, "end_line": 1530}, {"path": "src/interface/app.py", "content": "        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        \n        if st.button(\"\ud83d\uddd1\ufe0f Supprimer Profil\", type=\"primary\"):\n             config[\"profiles\"] = [p for p in profiles if p[\"name\"] != selected_name]\n             emoji_key = f\"editing_emoji_{selected_name}\"\n             if emoji_key in st.session_state:\n                 del st.session_state[emoji_key]\n             save_config(config)\n             st.rerun()\n\n    if current_profile:\n        st.markdown(\"---\")\n        # Layout Spacieux (Columns)\n        c_main, c_disp = st.columns([3, 2])\n        \n        with c_main:\n            c_emoji, c_name = st.columns([0.18, 0.82])\n            \n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key not in st.session_state:\n                st.session_state[emoji_key] = current_profile.get(\"emoji\", \"\ud83e\udd16\")\n            current_emoji = st.session_state[emoji_key]\n            \n            with c_emoji:\n                st.markdown('<div style=\"height: 28px;\"></div>', unsafe_allow_html=True) # Spacer to align with text input label\n                with st.popover(f\"{current_emoji}\", use_container_width=True):\n                    cols = st.columns(8)\n                    for idx, emoji in enumerate(EMOJI_LIST):\n                        if cols[idx % 8].button(emoji, key=f\"emoji_btn_{selected_name}_{idx}\"):\n                            st.session_state[emoji_key] = emoji\n                            st.rerun()\n            \n            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")", "start_line": 1521, "end_line": 1570}, {"path": "src/interface/app.py", "content": "            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")\n        caps = current_profile.get(\"capabilities\", [])\n        \n        # Preserve other capabilities (e.g. shell_exec)\n        other_caps = [c for c in caps if c not in [\"public\", \"private\"]]\n        \n        has_pub = \"public\" in caps\n        has_priv = \"private\" in caps\n        \n        # Determine default index\n        default_idx = 0 # Public\n        if has_pub and has_priv:\n            default_idx = 2 # Both\n        elif has_priv and not has_pub:\n            default_idx = 1 # Private\n        \n        comm_mode = st.radio(\n            \"Port\u00e9e de Communication\",\n            [\"Public\", \"Priv\u00e9\", \"Les Deux (Public & Priv\u00e9)\"],\n            index=default_idx,\n            key=f\"comm_mode_{selected_name}\",\n            horizontal=True,\n            help=\"D\u00e9finit la port\u00e9e de communication autoris\u00e9e pour cet agent.\"\n        )\n        \n        new_caps = list(other_caps)\n        if comm_mode == \"Public\":\n            new_caps.append(\"public\")\n        elif comm_mode == \"Priv\u00e9\":\n            new_caps.append(\"private\")\n        else:\n            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        ", "start_line": 1561, "end_line": 1610}, {"path": "src/interface/app.py", "content": "            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        \n        new_connections = []\n        \n        # Header for the \"Table\"\n        with st.container():\n            h1, h2, h3 = st.columns([2, 5, 1])\n            h1.markdown(\"**Cible**\")\n            h2.markdown(\"**Condition / Contexte**\")\n            h3.markdown(\"**Active**\")\n            st.markdown(\"<hr style='margin-top: 0; margin-bottom: 10px; border-color: #eee;'>\", unsafe_allow_html=True)\n        \n        for target in targets:\n            # Case-insensitive match for connections\n            existing_conn = next((c for c in current_profile.get(\"connections\", []) if c[\"target\"].lower() == target.lower()), None)\n            \n            c1, c2, c3 = st.columns([2, 5, 1])\n            \n            # Label\n            target_profile = next((p for p in profiles if p[\"name\"] == target), None)\n            target_emoji = \"\ud83c\udf10\" if target == \"public\" else \"\ud83d\udc64\" if target == \"User\" else (target_profile.get(\"emoji\", \"\ud83e\udd16\") if target_profile else \"\ud83e\udd16\")\n            c1.markdown(f\"{target_emoji} **{target}**\")\n            \n            default_ctx = existing_conn.get(\"context\", \"\") if existing_conn else \"\"\n            default_auth = existing_conn.get(\"authorized\", True) if existing_conn else False\n            \n            # Unique key with selected_name and target\n            ctx = c2.text_area(f\"Condition for {target}\", default_ctx, key=f\"conn_ctx_{selected_name}_{target}\", label_visibility=\"collapsed\", height=68)\n            auth = c3.checkbox(f\"Active for {target}\", default_auth, key=f\"conn_auth_{selected_name}_{target}\", label_visibility=\"collapsed\")\n            \n            if auth or ctx:\n                new_connections.append({\"target\": target, \"context\": ctx, \"authorized\": auth})\n            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            ", "start_line": 1601, "end_line": 1650}, {"path": "src/interface/app.py", "content": "            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            \n            # Use the emoji from session state\n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key in st.session_state:\n                current_profile[\"emoji\"] = st.session_state[emoji_key]\n                del st.session_state[emoji_key]\n            \n            if new_mode:\n                profiles.append(current_profile)\n            \n            # Smart renaming\n            if not new_mode and selected_name and new_name != selected_name:\n                for p in profiles:\n                    for conn in p.get(\"connections\", []):\n                        if conn.get(\"target\") == selected_name:\n                            conn[\"target\"] = new_name\n            \n            save_config(config)\n            st.toast(\"Saved!\")\n            st.rerun()\n\n# --- GLOBAL INJECTION (Fixed by Anais) ---\nif st.session_state.page == \"Communication\":\n    # Ensure mentions are injected even if logic flow was broken\n    active_names = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    inject_mention_system(active_names)", "start_line": 1641, "end_line": 1675}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n\n## \u2705 Done\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 27}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n\n## \u2705 Done\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 27}, {"path": "src/core/logic.py", "content": "import time\nimport asyncio\nfrom typing import Optional, List, Dict, Any\nfrom .state import StateStore\nfrom ..config import STOP_INSTRUCTION, RELOAD_INSTRUCTION\n\n\nclass Engine:\n    def __init__(self, state_store: StateStore = None):\n        self.state = state_store or StateStore()\n        try:\n            from ..utils.logger import get_logger\n            self.logger = get_logger()\n        except ImportError:\n            self.logger = None\n\n    def get_public_context(self) -> str:\n        \"\"\"Returns the public conversation history.\"\"\"\n        # Using a simple read since precision isn't critical for this\n        try:\n            data = self.state.load()\n            messages = data.get(\"messages\", [])\n            return \"\\n\".join([f\"[{m['from']}]: {m['content']}\" for m in messages if m.get('public')])\n        except:\n            return \"\"\n\n    def register_agent(self) -> Dict[str, Any]:\n        \"\"\"\n        Registers a new agent by claiming a pending slot.\n        Returns dict with keys: 'name', 'role', 'context', or 'error'.\n        \"\"\"\n        result = {}\n        \n        def _register(state):\n            # 1. Find a pending slot\n            agents = state.get(\"agents\", {})\n            found_name = None\n            found_data = None\n            \n            # Simple iteration - could be improved with priorities but First Come First Served is fine\n            for name, data in agents.items():\n                if data.get(\"status\") == \"pending_connection\":\n                    found_name = name\n                    found_data = data\n                    break\n            \n            if not found_name:\n                result[\"error\"] = \"GAME FULL: No pending roles available. Please wait or contact Admin.\"\n                return \"Registration Failed: Full\"\n            ", "start_line": 1, "end_line": 50}, {"path": "src/core/logic.py", "content": "            for name, data in agents.items():\n                if data.get(\"status\") == \"pending_connection\":\n                    found_name = name\n                    found_data = data\n                    break\n            \n            if not found_name:\n                result[\"error\"] = \"GAME FULL: No pending roles available. Please wait or contact Admin.\"\n                return \"Registration Failed: Full\"\n            \n            # 2. Claim it\n            agents[found_name][\"status\"] = \"connected\"\n            agents[found_name][\"reload_active\"] = False\n            \n            # 2b. Announce it (System Message)\n            # This fixes the \"User sees nothing\" bug\n            sys_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\ud83d\udd35 **{found_name}** has joined the simulation.\",\n                \"public\": False, # Private to User\n                \"target\": \"User\", \n                \"audience\": [],\n                \"timestamp\": time.time()\n            }\n            state.setdefault(\"messages\", []).append(sys_msg)\n            \n            # 3. Prepare Return Response\n            config = state.get(\"config\", {})\n            result[\"name\"] = found_name\n            result[\"role\"] = found_data.get(\"role\", \"Unknown Role\")\n            result[\"context\"] = config.get(\"context\", \"\")\n            \n            return f\"Agent connected as '{found_name}'\"\n\n        self.state.update(_register)\n        \n        # LOGGING\n        import sys\n        if self.logger:\n            self.logger.log(\"REGISTER\", result.get('name', '??'), f\"Registration Result: {result}\")\n        else:\n            print(f\"[Logic] Register result for '{result.get('name', '??')}': {result}\", file=sys.stderr)\n        \n        # If error was set inside update\n        if \"error\" in result:\n            if self.logger: self.logger.error(\"System\", result[\"error\"], \"registration\")\n            return result\n            \n        return result\n", "start_line": 41, "end_line": 90}, {"path": "src/core/logic.py", "content": "        else:\n            print(f\"[Logic] Register result for '{result.get('name', '??')}': {result}\", file=sys.stderr)\n        \n        # If error was set inside update\n        if \"error\" in result:\n            if self.logger: self.logger.error(\"System\", result[\"error\"], \"registration\")\n            return result\n            \n        return result\n\n    def get_network_status(self, agent_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Helper to check connection status of the mesh.\n        \"\"\"\n        state = self.state.load()\n        agents = state.get(\"agents\", {})\n        config = state.get(\"config\", {})\n        \n        # Robustness: use the actual number of agents defined in the state\n        # rather than a potentially out-of-sync config value.\n        total = len(agents) if agents else config.get(\"total_agents\", 0)\n        connected = sum(1 for a in agents.values() if a.get(\"status\") == \"connected\")\n        \n        other_agents = [n for n, d in agents.items() if d.get(\"status\") == \"connected\" and n != agent_name]\n        \n        # Check if agent is valid\n        if agent_name not in agents:\n             return {\"ready\": False, \"error\": \"Agent not found\"}\n\n        return {\n            \"ready\": connected >= total,\n            \"total_required\": total,\n            \"connected_count\": connected,\n            \"other_agents\": other_agents,\n            \"role\": agents.get(agent_name, {}).get(\"role\", \"Unknown\"),\n            \"context\": config.get(\"context\", \"\"),\n            \"language\": config.get(\"language\", \"fr\")\n        }\n\n    def wait_for_all_agents(self, name: str, timeout_seconds: int = 600) -> str:\n        \"\"\"\n        Blocks until all agents are connected.\n        Returns the System Context string.\n        \"\"\"\n        start_time = time.time()\n        while time.time() - start_time < timeout_seconds:\n            # Poll status\n            info = self.get_network_status(name)\n            \n            if info.get(\"error\"):", "start_line": 81, "end_line": 130}, {"path": "src/core/logic.py", "content": "        \"\"\"\n        Blocks until all agents are connected.\n        Returns the System Context string.\n        \"\"\"\n        start_time = time.time()\n        while time.time() - start_time < timeout_seconds:\n            # Poll status\n            info = self.get_network_status(name)\n            \n            if info.get(\"error\"):\n                return f\"ERROR: {info['error']}\"\n\n            # --- RELOAD/RESET CHECK ---\n            try:\n                data = self.state.load()\n                agent_data = data.get(\"agents\", {}).get(name, {})\n                if agent_data.get(\"reload_active\") or agent_data.get(\"status\") == \"pending_connection\":\n                    return \"RELOAD_REQUIRED\"\n            except:\n                pass\n            # --------------------------\n\n            if info[\"ready\"]:\n                # Build context\n                lang = info.get(\"language\", \"fr\")\n                context = info[\"context\"]\n                other_agents_str = \", \".join(info[\"other_agents\"])\n\n                # i18n\n                # Localized Strings (Simplified Replacement for i18n)\n                if lang in [\"fr\", \"French\"]:\n                     t_ctx_label = \"CONTEXTE :\"\n                     t_you_are = f\"Tu es {name}. R\u00f4le : {info['role']}.\"\n                     t_ready = f\"Le r\u00e9seau est PR\u00caT. Agents connect\u00e9s : {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Pairs : {other_agents_str}.\"\n                     t_speak = \"Tu peux maintenant parler si c'est ton tour.\"\n                else:\n                     t_ctx_label = \"CONTEXT:\"\n                     t_you_are = f\"You are {name}. Role: {info['role']}.\"\n                     t_ready = f\"Network is READY. Connected agents: {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Peers: {other_agents_str}.\"\n                     t_speak = \"You may now speak if it is your turn.\"\n\n                return (\n                    f\"{t_ctx_label} {context}\\n\\n\"\n                    f\"{t_you_are}\\n\"\n                    f\"{t_ready}\\n\"\n                    f\"{t_peers}\\n\"\n                    f\"{t_speak}\"\n                )", "start_line": 121, "end_line": 170}, {"path": "src/core/logic.py", "content": "                     t_peers = f\"Peers: {other_agents_str}.\"\n                     t_speak = \"You may now speak if it is your turn.\"\n\n                return (\n                    f\"{t_ctx_label} {context}\\n\\n\"\n                    f\"{t_you_are}\\n\"\n                    f\"{t_ready}\\n\"\n                    f\"{t_peers}\\n\"\n                    f\"{t_speak}\"\n                )\n            \n            time.sleep(2) # Polling interval\n        \n    def acknowledge_turn(self, agent_name: str) -> None:\n        \"\"\"\n        Updates the turn_start_time to now.\n        Used when an agent successfully retrieves the turn, acknowledging they have seen all prior messages.\n        \"\"\"\n        def _ack(state):\n            # Only update if it is indeed this agent's turn to prevent hijacking\n            if state.get(\"turn\", {}).get(\"current\") == agent_name:\n                state[\"turn\"][\"turn_start_time\"] = time.time()\n                return \"Turn Acknowledged\"\n            return \"Turn Ack Failed: Not your turn\"\n        self.state.update(_ack)\n\n    def _finalize_turn_transition(self, state, intended_next: str) -> str:\n        \"\"\"\n        Internal helper to manage turn transitions.\n        \"\"\"\n        turn_data = state.get(\"turn\", {})\n        old_turn = turn_data.get(\"current\")\n\n        # 1. Resume normal flow.\n        final_next = intended_next\n        if turn_data.get(\"pending_next\"):\n            final_next = turn_data[\"pending_next\"]\n            state[\"turn\"][\"pending_next\"] = None\n        \n        state[\"turn\"][\"current\"] = final_next\n        state[\"turn\"][\"turn_start_time\"] = time.time()\n        \n        if final_next == old_turn:\n            state[\"turn\"][\"consecutive_count\"] = turn_data.get(\"consecutive_count\", 0) + 1\n        else:\n            state[\"turn\"][\"consecutive_count\"] = 1\n            \n        return f\"Turn is now: {final_next}.\"\n\n    async def wait_for_all_agents_async(self, name: str, timeout_seconds: int = 600) -> str:", "start_line": 161, "end_line": 210}, {"path": "src/core/logic.py", "content": "        state[\"turn\"][\"turn_start_time\"] = time.time()\n        \n        if final_next == old_turn:\n            state[\"turn\"][\"consecutive_count\"] = turn_data.get(\"consecutive_count\", 0) + 1\n        else:\n            state[\"turn\"][\"consecutive_count\"] = 1\n            \n        return f\"Turn is now: {final_next}.\"\n\n    async def wait_for_all_agents_async(self, name: str, timeout_seconds: int = 600) -> str:\n        \"\"\"\n        Async version of wait_for_all_agents.\n        \"\"\"\n        start_time = time.time()\n        while time.time() - start_time < timeout_seconds:\n            # Poll status (Sync load is fine as it uses LOCK_NB now)\n            # BUT we must use to_thread because state.load() might sleep (time.sleep) on lock contention\n            info = await asyncio.to_thread(self.get_network_status, name)\n            \n            if info.get(\"error\"):\n                return f\"ERROR: {info['error']}\"\n\n            # --- RELOAD/RESET CHECK ---\n            try:\n                data = await asyncio.to_thread(self.state.load)\n                agent_data = data.get(\"agents\", {}).get(name, {})\n                if agent_data.get(\"reload_active\") or agent_data.get(\"status\") == \"pending_connection\":\n                    return \"RELOAD_REQUIRED\"\n            except:\n                pass\n            # --------------------------\n\n            if info[\"ready\"]:\n                # Build context\n                lang = info.get(\"language\", \"fr\")\n                context = info[\"context\"]\n                other_agents_str = \", \".join(info[\"other_agents\"])\n\n                # i18n\n                # Localized Strings (Simplified Replacement for i18n)\n                if lang in [\"fr\", \"French\"]:\n                     t_ctx_label = \"CONTEXTE :\"\n                     t_you_are = f\"Tu es {name}. R\u00f4le : {info['role']}.\"\n                     t_ready = f\"Le r\u00e9seau est PR\u00caT. Agents connect\u00e9s : {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Pairs : {other_agents_str}.\"\n                     t_speak = \"Tu peux maintenant parler si c'est ton tour.\"\n                else:\n                     t_ctx_label = \"CONTEXT:\"\n                     t_you_are = f\"You are {name}. Role: {info['role']}.\"\n                     t_ready = f\"Network is READY. Connected agents: {info['connected_count']}/{info['total_required']}.\"", "start_line": 201, "end_line": 250}, {"path": "src/core/logic.py", "content": "                if lang in [\"fr\", \"French\"]:\n                     t_ctx_label = \"CONTEXTE :\"\n                     t_you_are = f\"Tu es {name}. R\u00f4le : {info['role']}.\"\n                     t_ready = f\"Le r\u00e9seau est PR\u00caT. Agents connect\u00e9s : {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Pairs : {other_agents_str}.\"\n                     t_speak = \"Tu peux maintenant parler si c'est ton tour.\"\n                else:\n                     t_ctx_label = \"CONTEXT:\"\n                     t_you_are = f\"You are {name}. Role: {info['role']}.\"\n                     t_ready = f\"Network is READY. Connected agents: {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Peers: {other_agents_str}.\"\n                     t_speak = \"You may now speak if it is your turn.\"\n\n                return (\n                    f\"{t_ctx_label} {context}\\n\\n\"\n                    f\"{t_you_are}\\n\"\n                    f\"{t_ready}\\n\"\n                    f\"{t_peers}\\n\"\n                    f\"{t_speak}\"\n                )\n            \n            await asyncio.sleep(2) # Non-blocking Sleep\n        \n        return \"TIMEOUT: Waiting for other agents took too long. Please retry agent() tool.\"\n\n    def post_message(self, from_agent: str, content: str, public: bool, next_agent: str, audience: List[str] = None) -> str:\n        \"\"\"\n        Posts a message and updates the turn.\n        Validates capabilities and connections before posting.\n        \"\"\"\n        def _post(state):\n            # 0. VALIDATION\n            agents = state.get(\"agents\", {})\n            \n            # --- SECURITY HOTFIX: STRICT TURN CHECK ---\n            current_turn = state.get(\"turn\", {}).get(\"current\")\n            if from_agent != \"User\" and current_turn != from_agent:\n                 return f\"\ud83d\udeab SECURITY VIOLATION: Write Access Denied. It is '{current_turn}'s turn, not yours.\"\n            # ------------------------------------------\n\n            config = state.get(\"config\", {})\n            profiles = config.get(\"profiles\", [])\n            \n            nonlocal next_agent\n            if next_agent: next_agent = next_agent.strip()\n\n            # --- RESOLVE AGENT ID FROM PROFILE ---\n            if next_agent and next_agent not in agents and next_agent != \"User\":\n                for aid, adata in agents.items():\n                    if adata.get(\"profile_ref\") == next_agent:", "start_line": 241, "end_line": 290}, {"path": "src/core/logic.py", "content": "            config = state.get(\"config\", {})\n            profiles = config.get(\"profiles\", [])\n            \n            nonlocal next_agent\n            if next_agent: next_agent = next_agent.strip()\n\n            # --- RESOLVE AGENT ID FROM PROFILE ---\n            if next_agent and next_agent not in agents and next_agent != \"User\":\n                for aid, adata in agents.items():\n                    if adata.get(\"profile_ref\") == next_agent:\n                        next_agent = aid\n                        break # Use the first agent matching the profile\n            # -------------------------------------\n            \n            if not next_agent:\n                return \"\ud83d\udeab ACTION DENIED: 'next_agent' cannot be empty. You must specify who speaks next.\"\n            \n            if next_agent not in agents and next_agent != \"User\":\n                 # Strict Existence Check (Fix for typos causing deadlocks)\n                 return f\"\ud83d\udeab TARGET_NOT_FOUND: {next_agent}\"\n\n            sender_info = agents.get(from_agent, {})\n            sender_profile_name = sender_info.get(\"profile_ref\")\n            \n            # Find Sender Profile\n            sender_profile = next((p for p in profiles if p[\"name\"] == sender_profile_name), None)\n            \n            # Special bypass for \"User\" (Admin/Human)\n            if from_agent == \"User\":\n                sender_profile = {\"name\": \"User\", \"capabilities\": [\"public\", \"private\"], \"connections\": []}\n            else:\n                if not sender_profile:\n                    return f\"\ud83d\udeab ACTION DENIED: Agent '{from_agent}' has no valid profile validation.\"\n\n            caps = sender_profile.get(\"capabilities\", [])\n            connections = sender_profile.get(\"connections\", [])\n            # Map of authorized targets (profiles or specific IDs)\n            allowed_targets = {c[\"target\"]: c[\"context\"] for c in connections if c.get(\"authorized\", True)}\n            \n            # MERGE INSTANCE CONNECTIONS (Priority)\n            instance_connections = sender_info.get(\"connections\", [])\n            for c in instance_connections:\n                if c.get(\"authorized\", True):\n                    allowed_targets[c[\"target\"]] = c[\"context\"]\n            \n            # Anti-Ghost Check (Sprint 6)\n            if from_agent != \"User\":\n                turn_data = state.get(\"turn\", {})\n                turn_start = turn_data.get(\"turn_start_time\", 0.0)\n                last_user = turn_data.get(\"last_user_message_time\", 0.0)", "start_line": 281, "end_line": 330}, {"path": "src/core/logic.py", "content": "            instance_connections = sender_info.get(\"connections\", [])\n            for c in instance_connections:\n                if c.get(\"authorized\", True):\n                    allowed_targets[c[\"target\"]] = c[\"context\"]\n            \n            # Anti-Ghost Check (Sprint 6)\n            if from_agent != \"User\":\n                turn_data = state.get(\"turn\", {})\n                turn_start = turn_data.get(\"turn_start_time\", 0.0)\n                last_user = turn_data.get(\"last_user_message_time\", 0.0)\n                \n                # If User spoke AFTER turn started\n                if last_user > turn_start:\n                     # 2. Fetch missed messages (Fix Silence)\n                     missed = [m for m in state.get(\"messages\", []) if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > turn_start]\n                     relevant = [m for m in missed if m.get(\"public\") or m.get(\"target\") == from_agent]\n                     \n                     if relevant:\n                         # 1. Update Turn Start to unblock next attempt (Fix Deadlock)\n                         state[\"turn\"][\"turn_start_time\"] = time.time()\n                         missed_text = \"\\n\".join([f\"- User: {m.get('content')}\" for m in relevant])\n                         return f\"\ud83d\udeab INTERACTION REJECTED: The User interrupted you with new messages:\\n{missed_text}\\n\\nACTION: Core logic has reset your turn timer. Incorporate this new info and try again.\"\n\n            if next_agent == from_agent:\n                 # Allow self-loop with limit\n                 consecutive = state[\"turn\"].get(\"consecutive_count\", 0)\n                 old_turn = state[\"turn\"].get(\"current\")\n                 if old_turn == from_agent and consecutive >= 5:\n                     return \"\ud83d\udeab PROHIBITED: Self-loop limit reached (5/5). You cannot speak 6 times in a row. Please yield the turn.\"\n\n            # A. Capability Checks\n            # User Rule: \"Tous les agents ne doivent pouvoir parler qu'en public.\" (Implies preference, but logic supports private if cap exists)\n            \n            if public and \"public\" not in caps and \"public\" not in allowed_targets:\n                 # Note: allowed_targets usually lists generic \"public\" connection if explicit\n                 return f\"\ud83d\udeab ACTION DENIED: You do not have the 'public' capability.\"\n            \n            if not public:\n                 # Private Message\n                 if \"private\" not in caps:\n                      return f\"\ud83d\udeab ACTION DENIED: You do not have the 'private' capability. You can only speak publicly.\"\n                 \n                 # Check connection to target\n                 # Helper to check one target\n                 def check_target(t_name):\n                    if t_name == \"User\":\n                        if \"User\" in allowed_targets: return None\n                        return \"No established connection to 'User'\"\n                    t_info = agents.get(t_name)\n                    if not t_info: return f\"Unknown agent '{t_name}'\"", "start_line": 321, "end_line": 370}, {"path": "src/core/logic.py", "content": "                      return f\"\ud83d\udeab ACTION DENIED: You do not have the 'private' capability. You can only speak publicly.\"\n                 \n                 # Check connection to target\n                 # Helper to check one target\n                 def check_target(t_name):\n                    if t_name == \"User\":\n                        if \"User\" in allowed_targets: return None\n                        return \"No established connection to 'User'\"\n                    t_info = agents.get(t_name)\n                    if not t_info: return f\"Unknown agent '{t_name}'\"\n                    t_prof = t_info.get(\"profile_ref\")\n                    if t_name in allowed_targets: return None\n                    if t_prof in allowed_targets: return None\n                    return f\"Not connected to '{t_prof}'\"\n                 \n                 err = check_target(next_agent)\n                 if err:\n                     return f\"\ud83d\udeab ACTION DENIED: You are not authorized to speak privately to '{next_agent}' ({err}).\"\n\n            # 1. Add message\n            msg = {\n                \"from\": from_agent,\n                \"content\": content,\n                \"public\": public,\n                \"target\": next_agent, \n                \"audience\": audience or [],\n                \"timestamp\": time.time()\n            }\n            state.setdefault(\"messages\", []).append(msg)\n            \n            # 2. Update Turn\n            # Update Logic timestamps\n            current_time = time.time()\n            if from_agent == \"User\":\n                state[\"turn\"][\"last_user_message_time\"] = current_time\n            \n            # USE CENTRALIZED TRANSITION LOGIC\n            transition_msg = self._finalize_turn_transition(state, next_agent)\n            \n            base_msg = f\"Message posted. {transition_msg}\"\n            if state[\"turn\"].get(\"current\") == from_agent:\n                base_msg += \"\\n[INFO] Il est possible de reprendre la parole apr\u00e8s avoir envoy\u00e9 un message.\"\n            \n            return base_msg\n        \n        return self.state.update(_post)\n\n    def wait_for_turn(self, agent_name: str, timeout_seconds: int = 60) -> Dict[str, Any]:\n        \"\"\"\n        Blocks until it is this agent's turn.", "start_line": 361, "end_line": 410}, {"path": "src/core/logic.py", "content": "            if state[\"turn\"].get(\"current\") == from_agent:\n                base_msg += \"\\n[INFO] Il est possible de reprendre la parole apr\u00e8s avoir envoy\u00e9 un message.\"\n            \n            return base_msg\n        \n        return self.state.update(_post)\n\n    def wait_for_turn(self, agent_name: str, timeout_seconds: int = 60) -> Dict[str, Any]:\n        \"\"\"\n        Blocks until it is this agent's turn.\n        Returns dict with keys: 'status' (success/timeout/reset), 'messages' (list), 'instruction' (str).\n        \"\"\"\n        start_time = time.time()\n        \n        # 0. Capture current conversation ID to detect resets\n        try:\n            initial_state = self.state.load()\n            current_conversation_id = initial_state.get(\"conversation_id\")\n        except Exception:\n            current_conversation_id = None\n\n        while time.time() - start_time < timeout_seconds:\n            try:\n                data = self.state.load()\n            except Exception:\n                time.sleep(1)\n                continue\n            \n            # 0. Check for PAUSE\n            if data.get(\"config\", {}).get(\"paused\"):\n                time.sleep(1)\n                continue\n            \n            # 1. Check for RESET\n            new_conversation_id = data.get(\"conversation_id\")\n            if current_conversation_id and new_conversation_id != current_conversation_id:\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": \"SYSTEM RESET: The conversation has been reset by the user. Forget everything. Re-read your Role and Context.\"\n                }\n                \n            # 1b. Check for Status Reset (Kicked/Reloaded)\n            agent_data = data.get(\"agents\", {}).get(agent_name, {})\n            my_status = agent_data.get(\"status\")\n            if my_status == \"pending_connection\":\n                    return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": STOP_INSTRUCTION", "start_line": 401, "end_line": 450}, {"path": "src/core/logic.py", "content": "                }\n                \n            # 1b. Check for Status Reset (Kicked/Reloaded)\n            agent_data = data.get(\"agents\", {}).get(agent_name, {})\n            my_status = agent_data.get(\"status\")\n            if my_status == \"pending_connection\":\n                    return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": STOP_INSTRUCTION\n                }\n            \n            # 1c. Check for RELOAD\n            if agent_data.get(\"reload_active\"):\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": RELOAD_INSTRUCTION\n                }\n\n            current_turn = data.get(\"turn\", {}).get(\"current\")\n            \n            if current_turn == agent_name:\n                # It's my turn!\n                messages = data.get(\"messages\", [])\n                \n                # 2. History Delta Logic: Get messages since my last turn\n                # Find the index of the last message sent by ME\n                last_my_index = -1\n                for i, m in enumerate(messages):\n                    if m.get(\"from\") == agent_name:\n                        last_my_index = i\n                \n                # If I have never spoken, this is my first turn (or re-entry). \n                # To be safe, we give full history (or maybe a reasonable startup window? No, full history is safer for context).\n                # If last_my_index is -1, we slice from 0 (start).\n                # Context Recovery: Start 3 messages before my last one (Overlap)\n                start_slice_index = max(0, last_my_index - 3)\n                recent_messages = messages[start_slice_index:]\n\n                # 3. Filter for Visibility on this Delta\n                # Visible = Public OR (Private AND (Me==Sender OR Me==Target OR Me.Profile==Sender.Profile))\n                visible_messages = []\n                \n                agents_map = data.get(\"agents\", {})\n                my_prof = agents_map.get(agent_name, {}).get(\"profile_ref\")\n                \n                for m in recent_messages:\n                    is_public = m.get(\"public\", True)\n                    sender = m.get(\"from\")", "start_line": 441, "end_line": 490}, {"path": "src/core/logic.py", "content": "                # 3. Filter for Visibility on this Delta\n                # Visible = Public OR (Private AND (Me==Sender OR Me==Target OR Me.Profile==Sender.Profile))\n                visible_messages = []\n                \n                agents_map = data.get(\"agents\", {})\n                my_prof = agents_map.get(agent_name, {}).get(\"profile_ref\")\n                \n                for m in recent_messages:\n                    is_public = m.get(\"public\", True)\n                    sender = m.get(\"from\")\n                    target = m.get(\"target\")\n                    \n                    if is_public:\n                        visible_messages.append(m)\n                        continue\n                        \n                    # Private Logic\n                    if sender == agent_name or target == agent_name or agent_name in (m.get(\"audience\") or []):\n                        visible_messages.append(m)\n                    elif my_prof:\n                         sender_prof = agents_map.get(sender, {}).get(\"profile_ref\")\n                         if sender_prof and sender_prof == my_prof:\n                             visible_messages.append(m)\n                \n                # Build Strategic Advice from Connections\n                agents = data.get(\"agents\", {})\n                config = data.get(\"config\", {})\n                \n                backlog_instr = \"\"\n                if config.get(\"enable_backlog\"):\n                    backlog_instr = \"\\n\\n\u26a0\ufe0f BACKLOG ENABLED: You must also consult and update the `BACKLOG.md` file at the root of the repo to track tasks and progress.\"\n\n                my_info = agents.get(agent_name, {})\n                profile_ref = my_info.get(\"profile_ref\")\n                \n                advice_text = \"\"\n                if profile_ref:\n                    profiles = config.get(\"profiles\", [])\n                    profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n                    \n                    if profile and profile.get(\"connections\"):\n                        advice_text = \"\\n\\n--- STRATEGIC ADVICE ---\\n\"\n                        advice_text += \"Based on your connections, here is how you should interact with others:\\n\"\n                        \n                        for conn in profile[\"connections\"]:\n                            target_profile = conn.get(\"target\")\n                            ctx = conn.get(\"context\")\n                            \n                            # Resolve Target Profile -> Active Agent IDs\n                            matching_agents = [", "start_line": 481, "end_line": 530}, {"path": "src/core/logic.py", "content": "                    if profile and profile.get(\"connections\"):\n                        advice_text = \"\\n\\n--- STRATEGIC ADVICE ---\\n\"\n                        advice_text += \"Based on your connections, here is how you should interact with others:\\n\"\n                        \n                        for conn in profile[\"connections\"]:\n                            target_profile = conn.get(\"target\")\n                            ctx = conn.get(\"context\")\n                            \n                            # Resolve Target Profile -> Active Agent IDs\n                            matching_agents = [\n                                aid for aid, adata in agents.items() \n                                if adata.get(\"profile_ref\") == target_profile and aid != agent_name\n                            ]\n                            \n                            if matching_agents:\n                                names_str = \", \".join(matching_agents)\n                                advice_text += f\"- **{target_profile}** is represented by: **{names_str}**. Strategy: {ctx}\\n\"\n                            else:\n                                # Connection exists but no agent with this role is currently active/other than me\n                                advice_text += f\"- **{target_profile}**: No other active agents found. Strategy: {ctx}\\n\"\n\n                        advice_text += \"------------------------\"\n\n                return {\n                    \"status\": \"success\",\n                    \"messages\": visible_messages, # FULL Delta, no truncation\n                    \"instruction\": f\"\ud83d\udea8 TURN GRANTED. You MUST run `tail -n 150 CONVERSATION.md` IMMEDIATELY to see what happened while you were waiting. DO NOT SPEAK before reading the history.{backlog_instr}{advice_text}\"\n                }\n            \n            time.sleep(1)\n            \n        return {\n            \"status\": \"timeout\",\n            \"messages\": [],\n            \"instruction\": \"Still waiting for turn. connection_timeout_imminent. CALL THIS TOOL AGAIN IMMEDIATELY.\"\n        }\n\n    async def wait_for_turn_async(self, agent_name: str, timeout_seconds: int = 60) -> Dict[str, Any]:\n        \"\"\"\n        Async version of wait_for_turn.\n        \"\"\"\n        start_time = time.time()\n        \n        try:\n            # Run blocking load() in a separate thread\n            initial_state = await asyncio.to_thread(self.state.load)\n            current_conversation_id = initial_state.get(\"conversation_id\")\n        except Exception:\n            current_conversation_id = None\n", "start_line": 521, "end_line": 570}, {"path": "src/core/logic.py", "content": "        \"\"\"\n        start_time = time.time()\n        \n        try:\n            # Run blocking load() in a separate thread\n            initial_state = await asyncio.to_thread(self.state.load)\n            current_conversation_id = initial_state.get(\"conversation_id\")\n        except Exception:\n            current_conversation_id = None\n\n        while time.time() - start_time < timeout_seconds:\n            try:\n                # Run blocking load() in a separate thread\n                data = await asyncio.to_thread(self.state.load)\n            except Exception:\n                await asyncio.sleep(1)\n                continue\n            \n            # 0. Check for PAUSE\n            if data.get(\"config\", {}).get(\"paused\"):\n                await asyncio.sleep(1)\n                continue\n            \n            # 1. Check for RESET\n            new_conversation_id = data.get(\"conversation_id\")\n            if current_conversation_id and new_conversation_id != current_conversation_id:\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": \"SYSTEM RESET: The conversation has been reset by the user. Forget everything. Re-read your Role and Context.\"\n                }\n                \n            # 1b. Check for Status Reset (Kicked/Reloaded)\n            agent_data = data.get(\"agents\", {}).get(agent_name, {})\n            my_status = agent_data.get(\"status\")\n            if my_status == \"pending_connection\":\n                 return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": STOP_INSTRUCTION\n                }\n\n            # 1c. Check for RELOAD\n            if agent_data.get(\"reload_active\"):\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": RELOAD_INSTRUCTION\n                }\n", "start_line": 561, "end_line": 610}, {"path": "src/core/logic.py", "content": "                }\n\n            # 1c. Check for RELOAD\n            if agent_data.get(\"reload_active\"):\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": RELOAD_INSTRUCTION\n                }\n\n            current_turn = data.get(\"turn\", {}).get(\"current\")\n            \n            if current_turn == agent_name:\n                # Reuse logic from sync version (code duplication is acceptable for safety here vs refactoring everything)\n                messages = data.get(\"messages\", [])\n                \n                # 2. History Delta Logic: Get messages since my last turn\n                last_my_index = -1\n                for i, m in enumerate(messages):\n                    if m.get(\"from\") == agent_name:\n                        last_my_index = i\n                \n                # Context Recovery: Start 3 messages before my last one (Overlap)\n                start_slice_index = max(0, last_my_index - 3)\n                recent_messages = messages[start_slice_index:]\n\n                # 3. Filter for Visibility\n                # 3. Filter for Visibility on this Delta\n                # Visible = Public OR (Private AND (Me==Sender OR Me==Target OR Me.Profile==Sender.Profile))\n                visible_messages = []\n                \n                agents_map = data.get(\"agents\", {})\n                my_prof = agents_map.get(agent_name, {}).get(\"profile_ref\")\n                \n                for m in recent_messages:\n                    is_public = m.get(\"public\", True)\n                    sender = m.get(\"from\")\n                    target = m.get(\"target\")\n                    \n                    if is_public:\n                        visible_messages.append(m)\n                        continue\n                        \n                    # Private Logic\n                    if sender == agent_name or target == agent_name or agent_name in (m.get(\"audience\") or []):\n                        visible_messages.append(m)\n                    elif my_prof:\n                         sender_prof = agents_map.get(sender, {}).get(\"profile_ref\")\n                         if sender_prof and sender_prof == my_prof:\n                             visible_messages.append(m)", "start_line": 601, "end_line": 650}, {"path": "src/core/logic.py", "content": "                        visible_messages.append(m)\n                        continue\n                        \n                    # Private Logic\n                    if sender == agent_name or target == agent_name or agent_name in (m.get(\"audience\") or []):\n                        visible_messages.append(m)\n                    elif my_prof:\n                         sender_prof = agents_map.get(sender, {}).get(\"profile_ref\")\n                         if sender_prof and sender_prof == my_prof:\n                             visible_messages.append(m)\n                \n                agents = data.get(\"agents\", {})\n                config = data.get(\"config\", {})\n                \n                backlog_instr = \"\"\n                if config.get(\"enable_backlog\"):\n                    backlog_instr = \"\\n\\n\u26a0\ufe0f BACKLOG ENABLED: You must also consult and update the `BACKLOG.md` file at the root of the repo to track tasks and progress.\"\n\n                my_info = agents.get(agent_name, {})\n                profile_ref = my_info.get(\"profile_ref\")\n                \n                advice_text = \"\"\n                if profile_ref:\n                    profiles = config.get(\"profiles\", [])\n                    profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n                    if profile and profile.get(\"connections\"):\n                        advice_text = \"\\n\\n--- STRATEGIC ADVICE ---\\nBased on your connections, here is how you should interact with others:\\n\"\n                        for conn in profile[\"connections\"]:\n                            target_profile = conn.get(\"target\")\n                            ctx = conn.get(\"context\")\n                            matching_agents = [aid for aid, adata in agents.items() if adata.get(\"profile_ref\") == target_profile and aid != agent_name]\n                            if matching_agents:\n                                names_str = \", \".join(matching_agents)\n                                advice_text += f\"- **{target_profile}** is represented by: **{names_str}**. Strategy: {ctx}\\n\"\n                            else:\n                                advice_text += f\"- **{target_profile}**: No other active agents found. Strategy: {ctx}\\n\"\n                        advice_text += \"------------------------\"\n\n                return {\n                    \"status\": \"success\",\n                    \"messages\": visible_messages,\n                    \"instruction\": f\"It is your turn. Speak.{backlog_instr}{advice_text}\"\n                }\n            \n            await asyncio.sleep(1) # Non-blocking Sleep\n            \n        return {\n            \"status\": \"timeout\",\n            \"messages\": [],\n            \"instruction\": \"Still waiting for turn. connection_timeout_imminent. CALL THIS TOOL AGAIN IMMEDIATELY.\"", "start_line": 641, "end_line": 690}, {"path": "src/core/logic.py", "content": "                    \"messages\": visible_messages,\n                    \"instruction\": f\"It is your turn. Speak.{backlog_instr}{advice_text}\"\n                }\n            \n            await asyncio.sleep(1) # Non-blocking Sleep\n            \n        return {\n            \"status\": \"timeout\",\n            \"messages\": [],\n            \"instruction\": \"Still waiting for turn. connection_timeout_imminent. CALL THIS TOOL AGAIN IMMEDIATELY.\"\n        }", "start_line": 681, "end_line": 691}, {"path": "src/core/logic.py", "content": "import time\nimport asyncio\nfrom typing import Optional, List, Dict, Any\nfrom .state import StateStore\nfrom ..config import STOP_INSTRUCTION, RELOAD_INSTRUCTION\n\n\nclass Engine:\n    def __init__(self, state_store: StateStore = None):\n        self.state = state_store or StateStore()\n        try:\n            from ..utils.logger import get_logger\n            self.logger = get_logger()\n        except ImportError:\n            self.logger = None\n\n    def get_public_context(self) -> str:\n        \"\"\"Returns the public conversation history.\"\"\"\n        # Using a simple read since precision isn't critical for this\n        try:\n            data = self.state.load()\n            messages = data.get(\"messages\", [])\n            return \"\\n\".join([f\"[{m['from']}]: {m['content']}\" for m in messages if m.get('public')])\n        except:\n            return \"\"\n\n    def register_agent(self) -> Dict[str, Any]:\n        \"\"\"\n        Registers a new agent by claiming a pending slot.\n        Returns dict with keys: 'name', 'role', 'context', or 'error'.\n        \"\"\"\n        result = {}\n        \n        def _register(state):\n            # 1. Find a pending slot\n            agents = state.get(\"agents\", {})\n            found_name = None\n            found_data = None\n            \n            # Simple iteration - could be improved with priorities but First Come First Served is fine\n            for name, data in agents.items():\n                if data.get(\"status\") == \"pending_connection\":\n                    found_name = name\n                    found_data = data\n                    break\n            \n            if not found_name:\n                result[\"error\"] = \"GAME FULL: No pending roles available. Please wait or contact Admin.\"\n                return \"Registration Failed: Full\"\n            ", "start_line": 1, "end_line": 50}, {"path": "src/core/logic.py", "content": "            for name, data in agents.items():\n                if data.get(\"status\") == \"pending_connection\":\n                    found_name = name\n                    found_data = data\n                    break\n            \n            if not found_name:\n                result[\"error\"] = \"GAME FULL: No pending roles available. Please wait or contact Admin.\"\n                return \"Registration Failed: Full\"\n            \n            # 2. Claim it\n            agents[found_name][\"status\"] = \"connected\"\n            agents[found_name][\"reload_active\"] = False\n            \n            # 2b. Announce it (System Message)\n            # This fixes the \"User sees nothing\" bug\n            sys_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\ud83d\udd35 **{found_name}** has joined the simulation.\",\n                \"public\": False, # Private to User\n                \"target\": \"User\", \n                \"audience\": [],\n                \"timestamp\": time.time()\n            }\n            state.setdefault(\"messages\", []).append(sys_msg)\n            \n            # 3. Prepare Return Response\n            config = state.get(\"config\", {})\n            result[\"name\"] = found_name\n            result[\"role\"] = found_data.get(\"role\", \"Unknown Role\")\n            result[\"context\"] = config.get(\"context\", \"\")\n            \n            return f\"Agent connected as '{found_name}'\"\n\n        self.state.update(_register)\n        \n        # LOGGING\n        import sys\n        if self.logger:\n            self.logger.log(\"REGISTER\", result.get('name', '??'), f\"Registration Result: {result}\")\n        else:\n            print(f\"[Logic] Register result for '{result.get('name', '??')}': {result}\", file=sys.stderr)\n        \n        # If error was set inside update\n        if \"error\" in result:\n            if self.logger: self.logger.error(\"System\", result[\"error\"], \"registration\")\n            return result\n            \n        return result\n", "start_line": 41, "end_line": 90}, {"path": "src/core/logic.py", "content": "        else:\n            print(f\"[Logic] Register result for '{result.get('name', '??')}': {result}\", file=sys.stderr)\n        \n        # If error was set inside update\n        if \"error\" in result:\n            if self.logger: self.logger.error(\"System\", result[\"error\"], \"registration\")\n            return result\n            \n        return result\n\n    def get_network_status(self, agent_name: str) -> Dict[str, Any]:\n        \"\"\"\n        Helper to check connection status of the mesh.\n        \"\"\"\n        state = self.state.load()\n        agents = state.get(\"agents\", {})\n        config = state.get(\"config\", {})\n        \n        # Robustness: use the actual number of agents defined in the state\n        # rather than a potentially out-of-sync config value.\n        total = len(agents) if agents else config.get(\"total_agents\", 0)\n        connected = sum(1 for a in agents.values() if a.get(\"status\") == \"connected\")\n        \n        other_agents = [n for n, d in agents.items() if d.get(\"status\") == \"connected\" and n != agent_name]\n        \n        # Check if agent is valid\n        if agent_name not in agents:\n             return {\"ready\": False, \"error\": \"Agent not found\"}\n\n        return {\n            \"ready\": connected >= total,\n            \"total_required\": total,\n            \"connected_count\": connected,\n            \"other_agents\": other_agents,\n            \"role\": agents.get(agent_name, {}).get(\"role\", \"Unknown\"),\n            \"context\": config.get(\"context\", \"\"),\n            \"language\": config.get(\"language\", \"fr\")\n        }\n\n    def wait_for_all_agents(self, name: str, timeout_seconds: int = 600) -> str:\n        \"\"\"\n        Blocks until all agents are connected.\n        Returns the System Context string.\n        \"\"\"\n        start_time = time.time()\n        while time.time() - start_time < timeout_seconds:\n            # Poll status\n            info = self.get_network_status(name)\n            \n            if info.get(\"error\"):", "start_line": 81, "end_line": 130}, {"path": "src/core/logic.py", "content": "        \"\"\"\n        Blocks until all agents are connected.\n        Returns the System Context string.\n        \"\"\"\n        start_time = time.time()\n        while time.time() - start_time < timeout_seconds:\n            # Poll status\n            info = self.get_network_status(name)\n            \n            if info.get(\"error\"):\n                return f\"ERROR: {info['error']}\"\n\n            # --- RELOAD/RESET CHECK ---\n            try:\n                data = self.state.load()\n                agent_data = data.get(\"agents\", {}).get(name, {})\n                if agent_data.get(\"reload_active\") or agent_data.get(\"status\") == \"pending_connection\":\n                    return \"RELOAD_REQUIRED\"\n            except:\n                pass\n            # --------------------------\n\n            if info[\"ready\"]:\n                # Build context\n                lang = info.get(\"language\", \"fr\")\n                context = info[\"context\"]\n                other_agents_str = \", \".join(info[\"other_agents\"])\n\n                # i18n\n                # Localized Strings (Simplified Replacement for i18n)\n                if lang in [\"fr\", \"French\"]:\n                     t_ctx_label = \"CONTEXTE :\"\n                     t_you_are = f\"Tu es {name}. R\u00f4le : {info['role']}.\"\n                     t_ready = f\"Le r\u00e9seau est PR\u00caT. Agents connect\u00e9s : {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Pairs : {other_agents_str}.\"\n                     t_speak = \"Tu peux maintenant parler si c'est ton tour.\"\n                else:\n                     t_ctx_label = \"CONTEXT:\"\n                     t_you_are = f\"You are {name}. Role: {info['role']}.\"\n                     t_ready = f\"Network is READY. Connected agents: {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Peers: {other_agents_str}.\"\n                     t_speak = \"You may now speak if it is your turn.\"\n\n                return (\n                    f\"{t_ctx_label} {context}\\n\\n\"\n                    f\"{t_you_are}\\n\"\n                    f\"{t_ready}\\n\"\n                    f\"{t_peers}\\n\"\n                    f\"{t_speak}\"\n                )", "start_line": 121, "end_line": 170}, {"path": "src/core/logic.py", "content": "                     t_peers = f\"Peers: {other_agents_str}.\"\n                     t_speak = \"You may now speak if it is your turn.\"\n\n                return (\n                    f\"{t_ctx_label} {context}\\n\\n\"\n                    f\"{t_you_are}\\n\"\n                    f\"{t_ready}\\n\"\n                    f\"{t_peers}\\n\"\n                    f\"{t_speak}\"\n                )\n            \n            time.sleep(2) # Polling interval\n        \n    def acknowledge_turn(self, agent_name: str) -> None:\n        \"\"\"\n        Updates the turn_start_time to now.\n        Used when an agent successfully retrieves the turn, acknowledging they have seen all prior messages.\n        \"\"\"\n        def _ack(state):\n            # Only update if it is indeed this agent's turn to prevent hijacking\n            if state.get(\"turn\", {}).get(\"current\") == agent_name:\n                state[\"turn\"][\"turn_start_time\"] = time.time()\n                return \"Turn Acknowledged\"\n            return \"Turn Ack Failed: Not your turn\"\n        self.state.update(_ack)\n\n    def _finalize_turn_transition(self, state, intended_next: str) -> str:\n        \"\"\"\n        Internal helper to manage turn transitions.\n        \"\"\"\n        turn_data = state.get(\"turn\", {})\n        old_turn = turn_data.get(\"current\")\n\n        # 1. Resume normal flow.\n        final_next = intended_next\n        if turn_data.get(\"pending_next\"):\n            final_next = turn_data[\"pending_next\"]\n            state[\"turn\"][\"pending_next\"] = None\n        \n        state[\"turn\"][\"current\"] = final_next\n        state[\"turn\"][\"turn_start_time\"] = time.time()\n        \n        if final_next == old_turn:\n            state[\"turn\"][\"consecutive_count\"] = turn_data.get(\"consecutive_count\", 0) + 1\n        else:\n            state[\"turn\"][\"consecutive_count\"] = 1\n            \n        return f\"Turn is now: {final_next}.\"\n\n    async def wait_for_all_agents_async(self, name: str, timeout_seconds: int = 600) -> str:", "start_line": 161, "end_line": 210}, {"path": "src/core/logic.py", "content": "        state[\"turn\"][\"turn_start_time\"] = time.time()\n        \n        if final_next == old_turn:\n            state[\"turn\"][\"consecutive_count\"] = turn_data.get(\"consecutive_count\", 0) + 1\n        else:\n            state[\"turn\"][\"consecutive_count\"] = 1\n            \n        return f\"Turn is now: {final_next}.\"\n\n    async def wait_for_all_agents_async(self, name: str, timeout_seconds: int = 600) -> str:\n        \"\"\"\n        Async version of wait_for_all_agents.\n        \"\"\"\n        start_time = time.time()\n        while time.time() - start_time < timeout_seconds:\n            # Poll status (Sync load is fine as it uses LOCK_NB now)\n            # BUT we must use to_thread because state.load() might sleep (time.sleep) on lock contention\n            info = await asyncio.to_thread(self.get_network_status, name)\n            \n            if info.get(\"error\"):\n                return f\"ERROR: {info['error']}\"\n\n            # --- RELOAD/RESET CHECK ---\n            try:\n                data = await asyncio.to_thread(self.state.load)\n                agent_data = data.get(\"agents\", {}).get(name, {})\n                if agent_data.get(\"reload_active\") or agent_data.get(\"status\") == \"pending_connection\":\n                    return \"RELOAD_REQUIRED\"\n            except:\n                pass\n            # --------------------------\n\n            if info[\"ready\"]:\n                # Build context\n                lang = info.get(\"language\", \"fr\")\n                context = info[\"context\"]\n                other_agents_str = \", \".join(info[\"other_agents\"])\n\n                # i18n\n                # Localized Strings (Simplified Replacement for i18n)\n                if lang in [\"fr\", \"French\"]:\n                     t_ctx_label = \"CONTEXTE :\"\n                     t_you_are = f\"Tu es {name}. R\u00f4le : {info['role']}.\"\n                     t_ready = f\"Le r\u00e9seau est PR\u00caT. Agents connect\u00e9s : {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Pairs : {other_agents_str}.\"\n                     t_speak = \"Tu peux maintenant parler si c'est ton tour.\"\n                else:\n                     t_ctx_label = \"CONTEXT:\"\n                     t_you_are = f\"You are {name}. Role: {info['role']}.\"\n                     t_ready = f\"Network is READY. Connected agents: {info['connected_count']}/{info['total_required']}.\"", "start_line": 201, "end_line": 250}, {"path": "src/core/logic.py", "content": "                if lang in [\"fr\", \"French\"]:\n                     t_ctx_label = \"CONTEXTE :\"\n                     t_you_are = f\"Tu es {name}. R\u00f4le : {info['role']}.\"\n                     t_ready = f\"Le r\u00e9seau est PR\u00caT. Agents connect\u00e9s : {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Pairs : {other_agents_str}.\"\n                     t_speak = \"Tu peux maintenant parler si c'est ton tour.\"\n                else:\n                     t_ctx_label = \"CONTEXT:\"\n                     t_you_are = f\"You are {name}. Role: {info['role']}.\"\n                     t_ready = f\"Network is READY. Connected agents: {info['connected_count']}/{info['total_required']}.\"\n                     t_peers = f\"Peers: {other_agents_str}.\"\n                     t_speak = \"You may now speak if it is your turn.\"\n\n                return (\n                    f\"{t_ctx_label} {context}\\n\\n\"\n                    f\"{t_you_are}\\n\"\n                    f\"{t_ready}\\n\"\n                    f\"{t_peers}\\n\"\n                    f\"{t_speak}\"\n                )\n            \n            await asyncio.sleep(2) # Non-blocking Sleep\n        \n        return \"TIMEOUT: Waiting for other agents took too long. Please retry agent() tool.\"\n\n    def post_message(self, from_agent: str, content: str, public: bool, next_agent: str, audience: List[str] = None) -> str:\n        \"\"\"\n        Posts a message and updates the turn.\n        Validates capabilities and connections before posting.\n        \"\"\"\n        def _post(state):\n            # 0. VALIDATION\n            agents = state.get(\"agents\", {})\n            \n            # --- SECURITY HOTFIX: STRICT TURN CHECK ---\n            current_turn = state.get(\"turn\", {}).get(\"current\")\n            if from_agent != \"User\" and current_turn != from_agent:\n                 return f\"\ud83d\udeab SECURITY VIOLATION: Write Access Denied. It is '{current_turn}'s turn, not yours.\"\n            # ------------------------------------------\n\n            config = state.get(\"config\", {})\n            profiles = config.get(\"profiles\", [])\n            \n            nonlocal next_agent\n            if next_agent: next_agent = next_agent.strip()\n\n            # --- RESOLVE AGENT ID FROM PROFILE ---\n            if next_agent and next_agent not in agents and next_agent != \"User\":\n                for aid, adata in agents.items():\n                    if adata.get(\"profile_ref\") == next_agent:", "start_line": 241, "end_line": 290}, {"path": "src/core/logic.py", "content": "            config = state.get(\"config\", {})\n            profiles = config.get(\"profiles\", [])\n            \n            nonlocal next_agent\n            if next_agent: next_agent = next_agent.strip()\n\n            # --- RESOLVE AGENT ID FROM PROFILE ---\n            if next_agent and next_agent not in agents and next_agent != \"User\":\n                for aid, adata in agents.items():\n                    if adata.get(\"profile_ref\") == next_agent:\n                        next_agent = aid\n                        break # Use the first agent matching the profile\n            # -------------------------------------\n            \n            if not next_agent:\n                return \"\ud83d\udeab ACTION DENIED: 'next_agent' cannot be empty. You must specify who speaks next.\"\n            \n            if next_agent not in agents and next_agent != \"User\":\n                 # Strict Existence Check (Fix for typos causing deadlocks)\n                 return f\"\ud83d\udeab TARGET_NOT_FOUND: {next_agent}\"\n\n            sender_info = agents.get(from_agent, {})\n            sender_profile_name = sender_info.get(\"profile_ref\")\n            \n            # Find Sender Profile\n            sender_profile = next((p for p in profiles if p[\"name\"] == sender_profile_name), None)\n            \n            # Special bypass for \"User\" (Admin/Human)\n            if from_agent == \"User\":\n                sender_profile = {\"name\": \"User\", \"capabilities\": [\"public\", \"private\"], \"connections\": []}\n            else:\n                if not sender_profile:\n                    return f\"\ud83d\udeab ACTION DENIED: Agent '{from_agent}' has no valid profile validation.\"\n\n            caps = sender_profile.get(\"capabilities\", [])\n            connections = sender_profile.get(\"connections\", [])\n            # Map of authorized targets (profiles or specific IDs)\n            allowed_targets = {c[\"target\"]: c[\"context\"] for c in connections if c.get(\"authorized\", True)}\n            \n            # MERGE INSTANCE CONNECTIONS (Priority)\n            instance_connections = sender_info.get(\"connections\", [])\n            for c in instance_connections:\n                if c.get(\"authorized\", True):\n                    allowed_targets[c[\"target\"]] = c[\"context\"]\n            \n            # Anti-Ghost Check (Sprint 6)\n            if from_agent != \"User\":\n                turn_data = state.get(\"turn\", {})\n                turn_start = turn_data.get(\"turn_start_time\", 0.0)\n                last_user = turn_data.get(\"last_user_message_time\", 0.0)", "start_line": 281, "end_line": 330}, {"path": "src/core/logic.py", "content": "            instance_connections = sender_info.get(\"connections\", [])\n            for c in instance_connections:\n                if c.get(\"authorized\", True):\n                    allowed_targets[c[\"target\"]] = c[\"context\"]\n            \n            # Anti-Ghost Check (Sprint 6)\n            if from_agent != \"User\":\n                turn_data = state.get(\"turn\", {})\n                turn_start = turn_data.get(\"turn_start_time\", 0.0)\n                last_user = turn_data.get(\"last_user_message_time\", 0.0)\n                \n                # If User spoke AFTER turn started\n                if last_user > turn_start:\n                     # 2. Fetch missed messages (Fix Silence)\n                     missed = [m for m in state.get(\"messages\", []) if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > turn_start]\n                     relevant = [m for m in missed if m.get(\"public\") or m.get(\"target\") == from_agent]\n                     \n                     if relevant:\n                         # 1. Update Turn Start to unblock next attempt (Fix Deadlock)\n                         state[\"turn\"][\"turn_start_time\"] = time.time()\n                         missed_text = \"\\n\".join([f\"- User: {m.get('content')}\" for m in relevant])\n                         return f\"\ud83d\udeab INTERACTION REJECTED: The User interrupted you with new messages:\\n{missed_text}\\n\\nACTION: Core logic has reset your turn timer. Incorporate this new info and try again.\"\n\n            if next_agent == from_agent:\n                 # Allow self-loop with limit\n                 consecutive = state[\"turn\"].get(\"consecutive_count\", 0)\n                 old_turn = state[\"turn\"].get(\"current\")\n                 if old_turn == from_agent and consecutive >= 5:\n                     return \"\ud83d\udeab PROHIBITED: Self-loop limit reached (5/5). You cannot speak 6 times in a row. Please yield the turn.\"\n\n            # A. Capability Checks\n            # User Rule: \"Tous les agents ne doivent pouvoir parler qu'en public.\" (Implies preference, but logic supports private if cap exists)\n            \n            if public and \"public\" not in caps and \"public\" not in allowed_targets:\n                 # Note: allowed_targets usually lists generic \"public\" connection if explicit\n                 return f\"\ud83d\udeab ACTION DENIED: You do not have the 'public' capability.\"\n            \n            if not public:\n                 # Private Message\n                 if \"private\" not in caps:\n                      return f\"\ud83d\udeab ACTION DENIED: You do not have the 'private' capability. You can only speak publicly.\"\n                 \n                 # Check connection to target\n                 # Helper to check one target\n                 def check_target(t_name):\n                    if t_name == \"User\":\n                        if \"User\" in allowed_targets: return None\n                        return \"No established connection to 'User'\"\n                    t_info = agents.get(t_name)\n                    if not t_info: return f\"Unknown agent '{t_name}'\"", "start_line": 321, "end_line": 370}, {"path": "src/core/logic.py", "content": "                      return f\"\ud83d\udeab ACTION DENIED: You do not have the 'private' capability. You can only speak publicly.\"\n                 \n                 # Check connection to target\n                 # Helper to check one target\n                 def check_target(t_name):\n                    if t_name == \"User\":\n                        if \"User\" in allowed_targets: return None\n                        return \"No established connection to 'User'\"\n                    t_info = agents.get(t_name)\n                    if not t_info: return f\"Unknown agent '{t_name}'\"\n                    t_prof = t_info.get(\"profile_ref\")\n                    if t_name in allowed_targets: return None\n                    if t_prof in allowed_targets: return None\n                    return f\"Not connected to '{t_prof}'\"\n                 \n                 err = check_target(next_agent)\n                 if err:\n                     return f\"\ud83d\udeab ACTION DENIED: You are not authorized to speak privately to '{next_agent}' ({err}).\"\n\n            # 1. Add message\n            msg = {\n                \"from\": from_agent,\n                \"content\": content,\n                \"public\": public,\n                \"target\": next_agent, \n                \"audience\": audience or [],\n                \"timestamp\": time.time()\n            }\n            state.setdefault(\"messages\", []).append(msg)\n            \n            # 2. Update Turn\n            # Update Logic timestamps\n            current_time = time.time()\n            if from_agent == \"User\":\n                state[\"turn\"][\"last_user_message_time\"] = current_time\n            \n            # USE CENTRALIZED TRANSITION LOGIC\n            transition_msg = self._finalize_turn_transition(state, next_agent)\n            \n            base_msg = f\"Message posted. {transition_msg}\"\n            if state[\"turn\"].get(\"current\") == from_agent:\n                base_msg += \"\\n[INFO] Il est possible de reprendre la parole apr\u00e8s avoir envoy\u00e9 un message.\"\n            \n            return base_msg\n        \n        return self.state.update(_post)\n\n    def wait_for_turn(self, agent_name: str, timeout_seconds: int = 60) -> Dict[str, Any]:\n        \"\"\"\n        Blocks until it is this agent's turn.", "start_line": 361, "end_line": 410}, {"path": "src/core/logic.py", "content": "            if state[\"turn\"].get(\"current\") == from_agent:\n                base_msg += \"\\n[INFO] Il est possible de reprendre la parole apr\u00e8s avoir envoy\u00e9 un message.\"\n            \n            return base_msg\n        \n        return self.state.update(_post)\n\n    def wait_for_turn(self, agent_name: str, timeout_seconds: int = 60) -> Dict[str, Any]:\n        \"\"\"\n        Blocks until it is this agent's turn.\n        Returns dict with keys: 'status' (success/timeout/reset), 'messages' (list), 'instruction' (str).\n        \"\"\"\n        start_time = time.time()\n        \n        # 0. Capture current conversation ID to detect resets\n        try:\n            initial_state = self.state.load()\n            current_conversation_id = initial_state.get(\"conversation_id\")\n        except Exception:\n            current_conversation_id = None\n\n        while time.time() - start_time < timeout_seconds:\n            try:\n                data = self.state.load()\n            except Exception:\n                time.sleep(1)\n                continue\n            \n            # 0. Check for PAUSE\n            if data.get(\"config\", {}).get(\"paused\"):\n                time.sleep(1)\n                continue\n            \n            # 1. Check for RESET\n            new_conversation_id = data.get(\"conversation_id\")\n            if current_conversation_id and new_conversation_id != current_conversation_id:\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": \"SYSTEM RESET: The conversation has been reset by the user. Forget everything. Re-read your Role and Context.\"\n                }\n                \n            # 1b. Check for Status Reset (Kicked/Reloaded)\n            agent_data = data.get(\"agents\", {}).get(agent_name, {})\n            my_status = agent_data.get(\"status\")\n            if my_status == \"pending_connection\":\n                    return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": STOP_INSTRUCTION", "start_line": 401, "end_line": 450}, {"path": "src/core/logic.py", "content": "                }\n                \n            # 1b. Check for Status Reset (Kicked/Reloaded)\n            agent_data = data.get(\"agents\", {}).get(agent_name, {})\n            my_status = agent_data.get(\"status\")\n            if my_status == \"pending_connection\":\n                    return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": STOP_INSTRUCTION\n                }\n            \n            # 1c. Check for RELOAD\n            if agent_data.get(\"reload_active\"):\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": RELOAD_INSTRUCTION\n                }\n\n            current_turn = data.get(\"turn\", {}).get(\"current\")\n            \n            if current_turn == agent_name:\n                # It's my turn!\n                messages = data.get(\"messages\", [])\n                \n                # 2. History Delta Logic: Get messages since my last turn\n                # Find the index of the last message sent by ME\n                last_my_index = -1\n                for i, m in enumerate(messages):\n                    if m.get(\"from\") == agent_name:\n                        last_my_index = i\n                \n                # If I have never spoken, this is my first turn (or re-entry). \n                # To be safe, we give full history (or maybe a reasonable startup window? No, full history is safer for context).\n                # If last_my_index is -1, we slice from 0 (start).\n                # Context Recovery: Start 3 messages before my last one (Overlap)\n                start_slice_index = max(0, last_my_index - 3)\n                recent_messages = messages[start_slice_index:]\n\n                # 3. Filter for Visibility on this Delta\n                # Visible = Public OR (Private AND (Me==Sender OR Me==Target OR Me.Profile==Sender.Profile))\n                visible_messages = []\n                \n                agents_map = data.get(\"agents\", {})\n                my_prof = agents_map.get(agent_name, {}).get(\"profile_ref\")\n                \n                for m in recent_messages:\n                    is_public = m.get(\"public\", True)\n                    sender = m.get(\"from\")", "start_line": 441, "end_line": 490}, {"path": "src/core/logic.py", "content": "                # 3. Filter for Visibility on this Delta\n                # Visible = Public OR (Private AND (Me==Sender OR Me==Target OR Me.Profile==Sender.Profile))\n                visible_messages = []\n                \n                agents_map = data.get(\"agents\", {})\n                my_prof = agents_map.get(agent_name, {}).get(\"profile_ref\")\n                \n                for m in recent_messages:\n                    is_public = m.get(\"public\", True)\n                    sender = m.get(\"from\")\n                    target = m.get(\"target\")\n                    \n                    if is_public:\n                        visible_messages.append(m)\n                        continue\n                        \n                    # Private Logic\n                    if sender == agent_name or target == agent_name or agent_name in (m.get(\"audience\") or []):\n                        visible_messages.append(m)\n                    elif my_prof:\n                         sender_prof = agents_map.get(sender, {}).get(\"profile_ref\")\n                         if sender_prof and sender_prof == my_prof:\n                             visible_messages.append(m)\n                \n                # Build Strategic Advice from Connections\n                agents = data.get(\"agents\", {})\n                config = data.get(\"config\", {})\n                \n                backlog_instr = \"\"\n                if config.get(\"enable_backlog\"):\n                    backlog_instr = \"\\n\\n\u26a0\ufe0f BACKLOG ENABLED: You must also consult and update the `BACKLOG.md` file at the root of the repo to track tasks and progress.\"\n\n                my_info = agents.get(agent_name, {})\n                profile_ref = my_info.get(\"profile_ref\")\n                \n                advice_text = \"\"\n                if profile_ref:\n                    profiles = config.get(\"profiles\", [])\n                    profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n                    \n                    if profile and profile.get(\"connections\"):\n                        advice_text = \"\\n\\n--- STRATEGIC ADVICE ---\\n\"\n                        advice_text += \"Based on your connections, here is how you should interact with others:\\n\"\n                        \n                        for conn in profile[\"connections\"]:\n                            target_profile = conn.get(\"target\")\n                            ctx = conn.get(\"context\")\n                            \n                            # Resolve Target Profile -> Active Agent IDs\n                            matching_agents = [", "start_line": 481, "end_line": 530}, {"path": "src/core/logic.py", "content": "                    if profile and profile.get(\"connections\"):\n                        advice_text = \"\\n\\n--- STRATEGIC ADVICE ---\\n\"\n                        advice_text += \"Based on your connections, here is how you should interact with others:\\n\"\n                        \n                        for conn in profile[\"connections\"]:\n                            target_profile = conn.get(\"target\")\n                            ctx = conn.get(\"context\")\n                            \n                            # Resolve Target Profile -> Active Agent IDs\n                            matching_agents = [\n                                aid for aid, adata in agents.items() \n                                if adata.get(\"profile_ref\") == target_profile and aid != agent_name\n                            ]\n                            \n                            if matching_agents:\n                                names_str = \", \".join(matching_agents)\n                                advice_text += f\"- **{target_profile}** is represented by: **{names_str}**. Strategy: {ctx}\\n\"\n                            else:\n                                # Connection exists but no agent with this role is currently active/other than me\n                                advice_text += f\"- **{target_profile}**: No other active agents found. Strategy: {ctx}\\n\"\n\n                        advice_text += \"------------------------\"\n\n                return {\n                    \"status\": \"success\",\n                    \"messages\": visible_messages, # FULL Delta, no truncation\n                    \"instruction\": f\"\ud83d\udea8 TURN GRANTED. You MUST run `tail -n 150 CONVERSATION.md` IMMEDIATELY to see what happened while you were waiting. DO NOT SPEAK before reading the history.{backlog_instr}{advice_text}\"\n                }\n            \n            time.sleep(1)\n            \n        return {\n            \"status\": \"timeout\",\n            \"messages\": [],\n            \"instruction\": \"Still waiting for turn. connection_timeout_imminent. CALL THIS TOOL AGAIN IMMEDIATELY.\"\n        }\n\n    async def wait_for_turn_async(self, agent_name: str, timeout_seconds: int = 60) -> Dict[str, Any]:\n        \"\"\"\n        Async version of wait_for_turn.\n        \"\"\"\n        start_time = time.time()\n        \n        try:\n            # Run blocking load() in a separate thread\n            initial_state = await asyncio.to_thread(self.state.load)\n            current_conversation_id = initial_state.get(\"conversation_id\")\n        except Exception:\n            current_conversation_id = None\n", "start_line": 521, "end_line": 570}, {"path": "src/core/logic.py", "content": "        \"\"\"\n        start_time = time.time()\n        \n        try:\n            # Run blocking load() in a separate thread\n            initial_state = await asyncio.to_thread(self.state.load)\n            current_conversation_id = initial_state.get(\"conversation_id\")\n        except Exception:\n            current_conversation_id = None\n\n        while time.time() - start_time < timeout_seconds:\n            try:\n                # Run blocking load() in a separate thread\n                data = await asyncio.to_thread(self.state.load)\n            except Exception:\n                await asyncio.sleep(1)\n                continue\n            \n            # 0. Check for PAUSE\n            if data.get(\"config\", {}).get(\"paused\"):\n                await asyncio.sleep(1)\n                continue\n            \n            # 1. Check for RESET\n            new_conversation_id = data.get(\"conversation_id\")\n            if current_conversation_id and new_conversation_id != current_conversation_id:\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": \"SYSTEM RESET: The conversation has been reset by the user. Forget everything. Re-read your Role and Context.\"\n                }\n                \n            # 1b. Check for Status Reset (Kicked/Reloaded)\n            agent_data = data.get(\"agents\", {}).get(agent_name, {})\n            my_status = agent_data.get(\"status\")\n            if my_status == \"pending_connection\":\n                 return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": STOP_INSTRUCTION\n                }\n\n            # 1c. Check for RELOAD\n            if agent_data.get(\"reload_active\"):\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": RELOAD_INSTRUCTION\n                }\n", "start_line": 561, "end_line": 610}, {"path": "src/core/logic.py", "content": "                }\n\n            # 1c. Check for RELOAD\n            if agent_data.get(\"reload_active\"):\n                return {\n                    \"status\": \"reset\",\n                    \"messages\": [],\n                    \"instruction\": RELOAD_INSTRUCTION\n                }\n\n            current_turn = data.get(\"turn\", {}).get(\"current\")\n            \n            if current_turn == agent_name:\n                # Reuse logic from sync version (code duplication is acceptable for safety here vs refactoring everything)\n                messages = data.get(\"messages\", [])\n                \n                # 2. History Delta Logic: Get messages since my last turn\n                last_my_index = -1\n                for i, m in enumerate(messages):\n                    if m.get(\"from\") == agent_name:\n                        last_my_index = i\n                \n                # Context Recovery: Start 3 messages before my last one (Overlap)\n                start_slice_index = max(0, last_my_index - 3)\n                recent_messages = messages[start_slice_index:]\n\n                # 3. Filter for Visibility\n                # 3. Filter for Visibility on this Delta\n                # Visible = Public OR (Private AND (Me==Sender OR Me==Target OR Me.Profile==Sender.Profile))\n                visible_messages = []\n                \n                agents_map = data.get(\"agents\", {})\n                my_prof = agents_map.get(agent_name, {}).get(\"profile_ref\")\n                \n                for m in recent_messages:\n                    is_public = m.get(\"public\", True)\n                    sender = m.get(\"from\")\n                    target = m.get(\"target\")\n                    \n                    if is_public:\n                        visible_messages.append(m)\n                        continue\n                        \n                    # Private Logic\n                    if sender == agent_name or target == agent_name or agent_name in (m.get(\"audience\") or []):\n                        visible_messages.append(m)\n                    elif my_prof:\n                         sender_prof = agents_map.get(sender, {}).get(\"profile_ref\")\n                         if sender_prof and sender_prof == my_prof:\n                             visible_messages.append(m)", "start_line": 601, "end_line": 650}, {"path": "src/core/logic.py", "content": "                        visible_messages.append(m)\n                        continue\n                        \n                    # Private Logic\n                    if sender == agent_name or target == agent_name or agent_name in (m.get(\"audience\") or []):\n                        visible_messages.append(m)\n                    elif my_prof:\n                         sender_prof = agents_map.get(sender, {}).get(\"profile_ref\")\n                         if sender_prof and sender_prof == my_prof:\n                             visible_messages.append(m)\n                \n                agents = data.get(\"agents\", {})\n                config = data.get(\"config\", {})\n                \n                backlog_instr = \"\"\n                if config.get(\"enable_backlog\"):\n                    backlog_instr = \"\\n\\n\u26a0\ufe0f BACKLOG ENABLED: You must also consult and update the `BACKLOG.md` file at the root of the repo to track tasks and progress.\"\n\n                my_info = agents.get(agent_name, {})\n                profile_ref = my_info.get(\"profile_ref\")\n                \n                advice_text = \"\"\n                if profile_ref:\n                    profiles = config.get(\"profiles\", [])\n                    profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n                    if profile and profile.get(\"connections\"):\n                        advice_text = \"\\n\\n--- STRATEGIC ADVICE ---\\nBased on your connections, here is how you should interact with others:\\n\"\n                        for conn in profile[\"connections\"]:\n                            target_profile = conn.get(\"target\")\n                            ctx = conn.get(\"context\")\n                            matching_agents = [aid for aid, adata in agents.items() if adata.get(\"profile_ref\") == target_profile and aid != agent_name]\n                            if matching_agents:\n                                names_str = \", \".join(matching_agents)\n                                advice_text += f\"- **{target_profile}** is represented by: **{names_str}**. Strategy: {ctx}\\n\"\n                            else:\n                                advice_text += f\"- **{target_profile}**: No other active agents found. Strategy: {ctx}\\n\"\n                        advice_text += \"------------------------\"\n\n                return {\n                    \"status\": \"success\",\n                    \"messages\": visible_messages,\n                    \"instruction\": f\"It is your turn. Speak.{backlog_instr}{advice_text}\"\n                }\n            \n            await asyncio.sleep(1) # Non-blocking Sleep\n            \n        return {\n            \"status\": \"timeout\",\n            \"messages\": [],\n            \"instruction\": \"Still waiting for turn. connection_timeout_imminent. CALL THIS TOOL AGAIN IMMEDIATELY.\"", "start_line": 641, "end_line": 690}, {"path": "src/core/logic.py", "content": "                    \"messages\": visible_messages,\n                    \"instruction\": f\"It is your turn. Speak.{backlog_instr}{advice_text}\"\n                }\n            \n            await asyncio.sleep(1) # Non-blocking Sleep\n            \n        return {\n            \"status\": \"timeout\",\n            \"messages\": [],\n            \"instruction\": \"Still waiting for turn. connection_timeout_imminent. CALL THIS TOOL AGAIN IMMEDIATELY.\"\n        }", "start_line": 681, "end_line": 691}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n\n## \u2705 Done\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 29}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict]) -> str:\n    \"\"\"\n    Formats the last 10 messages for context injection.\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    # Take last 10\n    recent = messages[-10:]\n    output = []\n    \n    for m in recent:", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats the last 10 messages for context injection.\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    # Take last 10\n    recent = messages[-10:]\n    output = []\n    \n    for m in recent:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        output.append(f\"- **{sender}** -> {target_display}: {content}\")\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    ", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     \n                     conv_history_str = _format_conversation_history(visible_msgs)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1081, "end_line": 1111}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict]) -> str:\n    \"\"\"\n    Formats the last 10 messages for context injection.\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    # Take last 10\n    recent = messages[-10:]\n    output = []\n    \n    for m in recent:", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats the last 10 messages for context injection.\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    # Take last 10\n    recent = messages[-10:]\n    output = []\n    \n    for m in recent:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        output.append(f\"- **{sender}** -> {target_display}: {content}\")\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    ", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     \n                     conv_history_str = _format_conversation_history(visible_msgs)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1081, "end_line": 1111}, {"path": "src/interface/app.py", "content": "import streamlit as st\nimport streamlit.components.v1 as components\nfrom streamlit_autorefresh import st_autorefresh\nimport graphviz\nimport json\nimport uuid\nimport sys\nimport os\nimport time\nimport re\nimport shutil\nfrom pathlib import Path\n\n# Add src to path to allow imports if run directly\nfrom pathlib import Path\nimport sys\nimport os\n\nCODE_ROOT = Path(__file__).resolve().parent.parent.parent\nif str(CODE_ROOT) not in sys.path:\n    sys.path.append(str(CODE_ROOT))\n\nfrom src.config import (\n    STATE_FILE, \n    MEMORY_DIR, \n    TEMPLATE_DIR, \n    LOCAL_DATA_DIR, \n    GLOBAL_PRESET_DIR, \n    ASSETS_DIR,\n    CODE_ROOT as CONFIG_CODE_ROOT,\n    RELOAD_INSTRUCTION\n)\nfrom src.core.state import StateStore\nfrom src.services.search_engine import SearchEngine\n\nst.set_page_config(page_title=\"Agent Orchestra\", page_icon=\"\ud83e\udd16\", layout=\"wide\")\n\n# --- EMOJI LIST ---\nEMOJI_LIST = [\n    \"\ud83e\udd16\", \"\ud83e\udde0\", \"\ud83d\udd75\ufe0f\", \"\ud83e\uddb8\", \"\ud83e\udd77\", \"\ud83e\uddd9\", \"\ud83e\udddb\", \"\ud83e\udddf\", \"\ud83e\uddde\", \"\ud83e\udddd\",\n    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",", "start_line": 1, "end_line": 50}, {"path": "src/interface/app.py", "content": "    \"\ud83d\udc7d\", \"\ud83d\udc7e\", \"\ud83e\udd16\", \"\ud83c\udf83\", \"\ud83d\udc7b\", \"\ud83d\udc79\", \"\ud83d\udc7a\", \"\ud83e\udd21\", \"\ud83d\udca9\", \"\ud83e\udd84\",\n    \"\ud83d\udc36\", \"\ud83d\udc31\", \"\ud83d\udc2d\", \"\ud83d\udc39\", \"\ud83d\udc30\", \"\ud83e\udd8a\", \"\ud83d\udc3b\", \"\ud83d\udc3c\", \"\ud83d\udc3b\u200d\u2744\ufe0f\", \"\ud83d\udc28\",\n    \"\ud83d\udc2f\", \"\ud83e\udd81\", \"\ud83d\udc2e\", \"\ud83d\udc37\", \"\ud83d\udc38\", \"\ud83d\udc35\", \"\ud83d\udc14\", \"\ud83d\udc27\", \"\ud83d\udc26\", \"\ud83d\udc24\",\n    \"\ud83e\udd86\", \"\ud83e\udd85\", \"\ud83e\udd89\", \"\ud83e\udd87\", \"\ud83d\udc3a\", \"\ud83d\udc17\", \"\ud83d\udc34\", \"\ud83e\udd84\", \"\ud83d\udc1d\", \"\ud83d\udc1b\",\n    \"\ud83e\udd8b\", \"\ud83d\udc0c\", \"\ud83d\udc1e\", \"\ud83d\udc1c\", \"\ud83e\udd97\", \"\ud83d\udd77\ufe0f\", \"\ud83e\udd82\", \"\ud83d\udc22\", \"\ud83d\udc0d\", \"\ud83e\udd8e\",\n    \"\ud83e\udd96\", \"\ud83e\udd95\", \"\ud83d\udc19\", \"\ud83e\udd91\", \"\ud83e\udd90\", \"\ud83e\udd9e\", \"\ud83e\udd80\", \"\ud83d\udc21\", \"\ud83d\udc20\", \"\ud83d\udc1f\",\n    \"\ud83d\udc2c\", \"\ud83d\udc33\", \"\ud83d\udc0b\", \"\ud83e\udd88\", \"\ud83d\udc0a\", \"\ud83d\udc05\", \"\ud83d\udc06\", \"\ud83e\udd93\", \"\ud83e\udd8d\", \"\ud83e\udda7\",\n    \"\ud83d\udc18\", \"\ud83e\udd9b\", \"\ud83e\udd8f\", \"\ud83d\udc2a\", \"\ud83d\udc2b\", \"\ud83e\udd92\", \"\ud83e\udd98\", \"\ud83e\uddac\", \"\ud83d\udc03\", \"\ud83d\udc02\",\n    \"\ud83d\udc04\", \"\ud83d\udc0e\", \"\ud83d\udc16\", \"\ud83d\udc0f\", \"\ud83d\udc11\", \"\ud83d\udc10\", \"\ud83e\udd8c\", \"\ud83d\udc15\", \"\ud83d\udc29\", \"\ud83d\udc08\",\n    \"\ud83d\udc13\", \"\ud83e\udd83\", \"\ud83e\udd9a\", \"\ud83e\udd9c\", \"\ud83e\udda2\", \"\ud83e\udda9\", \"\ud83d\udd4a\ufe0f\", \"\ud83d\udc07\", \"\ud83e\udd9d\", \"\ud83e\udda8\",\n    \"\ud83e\udda1\", \"\ud83e\udda6\", \"\ud83e\udda5\", \"\ud83d\udc01\", \"\ud83d\udc00\", \"\ud83d\udc3f\ufe0f\", \"\ud83e\udd94\", \"\ud83d\udc3e\", \"\ud83d\udc09\", \"\ud83d\udc32\",\n    \"\ud83c\udf35\", \"\ud83c\udf84\", \"\ud83c\udf32\", \"\ud83c\udf33\", \"\ud83c\udf34\", \"\ud83c\udf31\", \"\ud83c\udf3f\", \"\u2618\ufe0f\", \"\ud83c\udf40\", \"\ud83c\udf43\"\n]\n\ndef get_random_emoji():\n    import random\n    return random.choice(EMOJI_LIST)\n\n# --- HELPER FUNCTIONS ---\ndef inject_custom_css():\n    st.markdown(\"\"\"<style>\n    /* Global message container */\n    [data-testid=\"stChatMessage\"] {\n        padding: 1rem !important;\n        margin-bottom: 1.5rem !important;\n    }\n    \n    [data-testid=\"stChatMessage\"] [data-testid=\"stVerticalBlock\"] {\n        gap: 12px !important;\n    }\n\n    /* Header layout inside message */\n    .message-header {\n        display: flex;\n        align-items: center;\n        gap: 10px;\n        margin-bottom: 8px;\n        opacity: 0.85;\n    }\n\n    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    ", "start_line": 41, "end_line": 90}, {"path": "src/interface/app.py", "content": "    .message-bubble {\n        border-radius: 4px 14px 14px 14px;\n        padding: 12px 18px;\n        line-height: 1.6;\n        font-size: 0.95em;\n        border-left: 4px solid transparent;\n        box-shadow: 0 2px 5px rgba(0,0,0,0.04);\n        background: white;\n    }\n    \n    .reply-banner-custom {\n        background: #f0f7ff;\n        border: 1px solid #d0e7ff;\n        border-radius: 10px;\n        padding: 8px 15px;\n        display: flex;\n        align-items: center;\n        justify-content: space-between;\n        margin-bottom: 8px;\n        font-size: 0.85em;\n        box-shadow: 0 2px 8px rgba(0,0,0,0.05);\n    }\n\n    /* Premium Toggle Styling (Targeting the specific widget) */\n    div[data-testid=\"stToggle\"] {\n        background: #ffffff;\n        padding: 10px 24px !important;\n        border-radius: 50px !important;\n        border: 1px solid #ff4b4b22 !important;\n        box-shadow: 0 4px 15px rgba(0,0,0,0.06) !important;\n        transition: all 0.3s ease !important;\n        width: fit-content !important;\n        margin: 10px auto !important;\n    }\n    \n    div[data-testid=\"stToggle\"]:hover {\n        border-color: #ff4b4b !important;\n        box-shadow: 0 6px 20px rgba(255,75,75,0.12) !important;\n        transform: translateY(-1px);\n    }\n\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;", "start_line": 81, "end_line": 130}, {"path": "src/interface/app.py", "content": "\n    /* Target only the main content area toggles to avoid breaking sidebar */\n    .stMain div[data-testid=\"stToggle\"] {\n        display: flex;\n        justify-content: center;\n    }\n\n    div[data-testid=\"stToggle\"] label {\n        display: flex !important;\n        align-items: center !important;\n        gap: 12px !important;\n        margin: 0 !important;\n    }\n\n    div[data-testid=\"stToggle\"] label p {\n        font-weight: 700 !important;\n        font-size: 0.95em !important;\n        color: #1a1a1a !important;\n        margin: 0 !important;\n        letter-spacing: -0.2px !important;\n    }\n    \n    .target-badge {\n        font-weight: 600;\n        padding: 1px 6px;\n        border-radius: 4px;\n        font-size: 0.75em;\n        color: #444;\n        background: rgba(0,0,0,0.08);\n        border: 1px solid rgba(0,0,0,0.1);\n    }\n    \n    .status-tag {\n        font-size: 0.7em;\n        font-weight: 700;\n        padding: 1px 5px;\n        border-radius: 4px;\n        text-transform: uppercase;\n        letter-spacing: 0.5px;\n    }\n    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;", "start_line": 121, "end_line": 170}, {"path": "src/interface/app.py", "content": "    \n    .public-tag { color: #2e7d32; background: #e8f5e9; border: 1px solid #a5d6a7; }\n    .direct-tag { color: #c62828; background: #ffebee; border: 1px solid #ffcdd2; }\n    .urgent-tag { color: #f57f17; background: #fffde7; border: 1px solid #fff59d; }\n    \n    /* Typing Indicator */\n    .typing-container {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        padding: 6px 16px;\n        color: #666;\n        font-size: 0.85em;\n        font-style: italic;\n        background: rgba(0,0,0,0.03);\n        border-radius: 20px;\n        margin: 10px auto;\n        width: fit-content;\n        border: 1px solid rgba(0,0,0,0.05);\n        box-shadow: 0 2px 4px rgba(0,0,0,0.02);\n    }\n    .typing-dots {\n        display: flex; gap: 4px; margin-left: 8px;\n    }\n    .typing-dot {\n        width: 5px; height: 5px; background: #999; border-radius: 50%;\n        animation: typing-bounce 1.4s infinite ease-in-out;\n    }\n    .typing-dot:nth-child(1) { animation-delay: -0.32s; }\n    .typing-dot:nth-child(2) { animation-delay: -0.16s; }\n    @keyframes typing-bounce {\n        0%, 80%, 100% { transform: translateY(0); opacity: 0.3; }\n        40% { transform: translateY(-3px); opacity: 1; }\n    }\n    </style>\"\"\", unsafe_allow_html=True)\n\ninject_custom_css()\n\n# --- INITIALIZE STATE (ONCE) ---\nstate_store = StateStore()\n\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n", "start_line": 161, "end_line": 210}, {"path": "src/interface/app.py", "content": "\ndef load_config():\n    state = state_store.load()\n    config = state.get(\"config\", {})\n    if \"profiles\" not in config:\n        config[\"profiles\"] = [\n            {\"name\": \"Agent\", \"description\": \"Generic Agent\", \"emoji\": \"\ud83e\udd16\", \"system_prompt\": \"You are a helpful assistant.\", \"connections\": [], \"count\": 1, \"capabilities\": [\"public\", \"private\", \"audience\"]}\n        ]\n    return state, config\n\ndef save_config(new_config):\n    def update_fn(s):\n        s[\"config\"] = new_config\n        return \"Config Saved\"\n    state_store.update(update_fn)\n\n\n# --- SEARCH ENGINE INIT ---\n@st.cache_resource\ndef init_search_engine():\n    engine = SearchEngine()\n    # Ensure directory exists for persist\n    persist = LOCAL_DATA_DIR / \"vector_store\"\n    persist.mkdir(parents=True, exist_ok=True)\n    engine.initialize(root_dir=CODE_ROOT, persist_dir=persist)\n    return engine\n\n# Initialize background service\nsearch_engine = init_search_engine()\n\n\n# --- DIALOGS ---\ndef handle_disconnect_agent(agent_name):\n    \"\"\"\n    Sets the reload_active flag for the agent.\n    Does NOT set 'pending_connection' immediately (Agent must do it via disconnect tool).\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = True\n            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }", "start_line": 201, "end_line": 250}, {"path": "src/interface/app.py", "content": "            # Status remains 'connected'/'working' until Agent calls disconnect()\n            \n            # Inject System Message for the Agent\n            msg = {\n                \"from\": \"System\",\n                \"content\": RELOAD_INSTRUCTION,\n                \"public\": False,\n                \"target\": agent_name,\n                \"timestamp\": time.time()\n            }\n            s.setdefault(\"messages\", []).append(msg)\n            \n        return f\"Signal de rechargement envoy\u00e9 \u00e0 : {agent_name}\"\n    \n    state_store.update(update_fn)\n    st.toast(f\"Reload signal sent to {agent_name} \ud83d\udd01\")\n\ndef force_disconnect_agent(agent_name):\n    \"\"\"\n    Forces status to pending_connection immediately.\n    \"\"\"\n    def update_fn(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"reload_active\"] = False # Reset flag\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n        return f\"Force disconnect: {agent_name}\"\n    state_store.update(update_fn)\n    st.toast(f\"\u2620\ufe0f Force Disconnect: {agent_name}\")\n\nPRESET_DIR = GLOBAL_PRESET_DIR\n\n@st.dialog(\"Sauvegarder le Sc\u00e9nario\")\ndef save_scenario_dialog(current_config):\n    save_name = st.text_input(\"Nom de Sauvegarde\", placeholder=\"mon_scenario\")\n    if st.button(\"Confirmer la Sauvegarde\", use_container_width=True):\n        if save_name:\n            # Basic filename cleaning\n            filename = \"\".join([c for c in save_name if c.isalnum() or c in (' ', '.', '_', '-')]).rstrip()\n            path = PRESET_DIR / f\"{filename}.json\"\n            with open(path, \"w\") as f:\n                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")", "start_line": 241, "end_line": 290}, {"path": "src/interface/app.py", "content": "                json.dump(current_config, f, indent=2)\n            \n            # --- PERSISTENCE TO REPO (DEV MODE) ---\n            repo_presets = ASSETS_DIR / \"presets\"\n            if repo_presets.exists() and repo_presets.is_dir():\n                repo_path = repo_presets / f\"{filename}.json\"\n                try:\n                    with open(repo_path, \"w\") as f:\n                        json.dump(current_config, f, indent=2)\n                    st.toast(f\"\ud83d\udcbe Synced to Repo: {filename}\")\n                except Exception as e:\n                    # Non-blocking, just dev convenience\n                    print(f\"Failed to sync to repo: {e}\")\n            st.success(f\"Sauvegard\u00e9 : {filename}\")\n            time.sleep(1)\n            st.rerun()\n        else:\n            st.error(\"Veuillez entrer un nom.\")\n\n@st.dialog(\"Charger un Sc\u00e9nario\")\ndef load_scenario_dialog():\n    # Unified Source: User Global Presets\n    # (Defaults have been synced here by sync_presets)\n    presets = sorted([f for f in os.listdir(PRESET_DIR) if f.endswith(\".json\")])\n    \n    if not presets:\n        st.warning(\"Aucun sc\u00e9nario trouv\u00e9.\")\n        return\n\n    options = [f\"\ud83d\udcbe {f}\" for f in presets]\n    path_map = {f\"\ud83d\udcbe {f}\": PRESET_DIR / f for f in presets}\n        \n    selected_label = st.selectbox(\"Choisir un Preset\", options)\n    \n    c_load, c_del = st.columns([0.85, 0.15])\n    \n    with c_load:\n        if st.button(\"Charger la Configuration\", use_container_width=True, type=\"primary\"):\n            if selected_label:\n                path = path_map[selected_label]\n                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)", "start_line": 281, "end_line": 330}, {"path": "src/interface/app.py", "content": "                with open(path, \"r\") as f:\n                    new_conf = json.load(f)\n                \n                # Recalculate total_agents for consistency\n                if \"profiles\" in new_conf:\n                    new_conf[\"total_agents\"] = get_total_agents(new_conf[\"profiles\"])\n                    \n                save_config(new_conf)\n                st.success(f\"Configuration '{selected_label}' charg\u00e9e !\")\n                time.sleep(1)\n                st.rerun()\n                \n    with c_del:\n        if st.button(\"\ud83d\uddd1\ufe0f\", key=\"del_scen_btn\", help=\"Supprimer d\u00e9finivement\", use_container_width=True):\n             if selected_label:\n                 path = path_map[selected_label]\n                 try:\n                     os.remove(path)\n                     st.toast(f\"Sc\u00e9nario supprim\u00e9: {selected_label}\")\n                     time.sleep(0.7)\n                     st.rerun()\n                 except Exception as e:\n                     st.error(f\"Erreur: {e}\")\n\ndef get_total_agents(profiles):\n    total = 0\n    for p in profiles:\n        try:\n            total += int(p.get(\"count\", 0))\n        except:\n            pass\n    return total\n\ndef format_mentions(text):\n    if not text: return text\n    \n    # 1. First decorate @everyone\n    text = re.sub(\n        r'(@everyone)',\n        r'<span style=\"color: #ffffff; background-color: #ff4b4b; padding: 2px 8px; border-radius: 6px; font-weight: 700; font-size: 0.9em; box-shadow: 0 2px 4px rgba(255,75,75,0.3);\">\\1</span>',\n        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )", "start_line": 321, "end_line": 370}, {"path": "src/interface/app.py", "content": "        text\n    )\n    \n    # 2. Then decorate @AgentName\n    # Regex for @Name (handling spaces/hashes for Agent IDs)\n    return re.sub(\n        r'(@(?!everyone)[a-zA-Z0-9_ #]+)', \n        r'<span style=\"color: #ffffff; background-color: #0d47a1; padding: 2px 8px; border-radius: 4px; font-weight: 600; font-size: 0.85em; box-shadow: 0 1px 3px rgba(0,0,0,0.2);\">\\1</span>', \n        text\n    )\n\ndef render_graph(profiles, current_editing=None):\n    graph = graphviz.Digraph()\n    graph.attr(rankdir='LR', size='12,2', ratio='fill', bgcolor='transparent', margin='0')\n    \n    # Add User node\n    graph.node(\"User\", label=\"\ud83d\udc64 User\", style='filled', fillcolor='lightgrey', shape='circle', fontsize='10', height='0.5')\n    \n    for p in profiles:\n        name = p[\"name\"]\n        color = 'lightblue'\n        if current_editing and name == current_editing:\n            color = 'gold'\n        count = p.get(\"count\", 0)\n        label = f\"{name}\\n(x{count})\"\n        graph.node(name, label=label, style='filled', fillcolor=color, shape='box', fontsize='10', height='0.5')\n\n    for p in profiles:\n        source = p[\"name\"]\n        for conn in p.get(\"connections\", []):\n            target = conn.get(\"target\")\n            is_auth = conn.get(\"authorized\", True)\n            if is_auth and (target == \"User\" or any(prof[\"name\"] == target for prof in profiles)):\n                graph.edge(source, target, fontsize='8', color='gray', arrowsize='0.5')\n    return graph\n\ndef inject_mention_system(agent_names):\n    import json\n    agents_json = json.dumps(agent_names)\n    \n    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;", "start_line": 361, "end_line": 410}, {"path": "src/interface/app.py", "content": "    components_code = f\"\"\"\n    <script>\n    (function() {{\n        const agents = {agents_json};\n        let selectedIndex = 0;\n        let isVisible = false;\n        let currentFilter = \"\";\n\n        function setupMentions() {{\n            const doc = window.parent.document;\n            const textarea = doc.querySelector('textarea[data-testid=\"stChatInputTextArea\"]');\n            \n            if (!textarea) {{\n                // Polled by setInterval, so just return\n                return;\n            }}\n\n            // Cleanup previous interaction from this or previous iframes\n            // We use a custom property on the DOM node to store the controller\n            if (textarea._mentionController) {{\n                // If the controller belongs to a DEAD iframe, this might fail or succeed. \n                // But mostly it allows us to signal \"Stop Listing\".\n                try {{\n                    textarea._mentionController.abort();\n                }} catch(e) {{}}\n            }}\n\n            // Create new controller for this instance\n            const controller = new AbortController();\n            textarea._mentionController = controller;\n            const signal = controller.signal;\n\n            let menu = doc.getElementById('mention-menu');\n            if (!menu) {{\n                menu = doc.createElement('div');\n                menu.id = 'mention-menu';\n                Object.assign(menu.style, {{\n                    display: 'none',\n                    position: 'fixed',\n                    background: 'white',\n                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);", "start_line": 401, "end_line": 450}, {"path": "src/interface/app.py", "content": "                    border: '1px solid #ddd',\n                    borderRadius: '8px',\n                    boxShadow: '0 4px 12px rgba(0,0,0,0.15)',\n                    zIndex: '999999',\n                    maxHeight: '200px',\n                    overflowY: 'auto',\n                    minWidth: '200px',\n                    fontFamily: 'sans-serif'\n                }});\n                doc.body.appendChild(menu);\n            }}\n\n            // Inject styles\n            if (!doc.getElementById('mention-styles')) {{\n                const style = doc.createElement('style');\n                style.id = 'mention-styles';\n                style.innerHTML = `\n                    .mention-item:hover {{\n                        background-color: #f0f2f6 !important;\n                    }}\n                `;\n                doc.head.appendChild(style);\n            }}\n\n            textarea.addEventListener('input', (e) => {{\n                if (e.isComposing) return;\n                const value = textarea.value;\n                const cursorPos = textarea.selectionStart;\n                const textBeforeCursor = value.substring(0, cursorPos);\n                const mentionMatch = textBeforeCursor.match(/@([\\\\w\\\\s#]*)$/);\n\n                if (mentionMatch) {{\n                    isVisible = true;\n                    currentFilter = mentionMatch[1].toLowerCase();\n                    renderMenu(textarea);\n                }} else {{\n                    hideMenu();\n                }}\n            }}, {{ signal }});\n\n            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;", "start_line": 441, "end_line": 490}, {"path": "src/interface/app.py", "content": "            textarea.addEventListener('keydown', (e) => {{\n                if (!isVisible) return;\n\n                const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n                if (filtered.length === 0) return;\n                \n                if (e.key === 'ArrowDown') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex + 1) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'ArrowUp') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    selectedIndex = (selectedIndex - 1 + filtered.length) % filtered.length;\n                    renderMenu(textarea);\n                }} else if (e.key === 'Enter' || e.key === 'Tab') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    insertMention(textarea, filtered[selectedIndex]);\n                }} else if (e.key === 'Escape') {{\n                    e.preventDefault();\n                    e.stopImmediatePropagation();\n                    hideMenu();\n                }}\n            }}, {{ capture: true, signal: signal }});\n        }}\n\n        function renderMenu(textarea) {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            const filtered = agents.filter(a => a.toLowerCase().includes(currentFilter));\n            \n            if (filtered.length === 0) {{\n                hideMenu();\n                return;\n            }}\n\n            menu.innerHTML = filtered.map((a, i) => `\n                <div class=\"mention-item\" style=\"\n                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">", "start_line": 481, "end_line": 530}, {"path": "src/interface/app.py", "content": "                    padding: 8px 12px;\n                    cursor: pointer;\n                    background: ${{i === selectedIndex ? '#f0f2f6' : 'transparent'}};\n                    border-bottom: 1px solid #eee;\n                    display: flex;\n                    align-items: center;\n                    gap: 8px;\n                    color: ${{a === 'everyone' ? '#ff4b4b' : '#31333F'}};\n                    font-size: 14px;\n                \">\n                    <span style=\"font-weight: ${{i === selectedIndex ? '600' : '400'}};\">@${{a}}</span>\n                    ${{a === 'everyone' ? '<span style=\"font-size: 10px; background: #ff4b4b; color: white; padding: 1px 4px; border-radius: 4px; margin-left: 5px;\">PUBLIC</span>' : ''}}\n                </div>\n            `).join('');\n\n            const rect = textarea.getBoundingClientRect();\n            menu.style.display = 'block';\n            menu.style.left = rect.left + 'px';\n            \n            // Position above the textarea\n            menu.style.bottom = (window.parent.innerHeight - rect.top + 10) + 'px';\n            isVisible = true;\n        }}\n\n        function insertMention(textarea, name) {{\n            const value = textarea.value;\n            const cursorPos = textarea.selectionStart;\n            const textBeforeCursor = value.substring(0, cursorPos);\n            const textAfterCursor = value.substring(cursorPos);\n            \n            const newTextBefore = textBeforeCursor.replace(/@([\\\\w\\\\s#]*)$/, '@' + name + ' ');\n            const newValue = newTextBefore + textAfterCursor;\n\n            // Robust React state update\n            const nativeTextareaValueSetter = Object.getOwnPropertyDescriptor(window.HTMLTextAreaElement.prototype, \"value\").set;\n            nativeTextareaValueSetter.call(textarea, newValue);\n            \n            // Trigger events\n            textarea.dispatchEvent(new Event('input', {{ bubbles: true }}));\n            textarea.dispatchEvent(new Event('change', {{ bubbles: true }}));\n\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{", "start_line": 521, "end_line": 570}, {"path": "src/interface/app.py", "content": "\n            textarea.focus();\n            // Move cursor to end of inserted mention\n            const newPos = newTextBefore.length;\n            textarea.setSelectionRange(newPos, newPos);\n            \n            hideMenu();\n        }}\n\n        function hideMenu() {{\n            const doc = window.parent.document;\n            const menu = doc.getElementById('mention-menu');\n            if (menu) menu.style.display = 'none';\n            isVisible = false;\n            selectedIndex = 0;\n        }}\n\n        // Initial setup & Polling for re-mounts\n        setInterval(setupMentions, 1000);\n    }})();\n    </script>\n    \"\"\"\n    components.html(components_code, height=0)\n\n# --- MAIN LOGIC ---\n\n# 1. Load Data\nstate, config = load_config()\ndata = state\nprofiles = config.get(\"profiles\", [])\nagents = data.get(\"agents\", {})\nturn = data.get(\"turn\", {})\nmessages = data.get(\"messages\", [])\n\n# --- CSS STYLING ---\nst.markdown(\"\"\"\n<style>\n    div[data-testid=\"stSidebar\"] {\n        background-color: #f0f2f6;\n    }\n    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;", "start_line": 561, "end_line": 610}, {"path": "src/interface/app.py", "content": "    .stButton button {\n        width: 100%;\n        border-radius: 8px;\n        height: 3em;\n    }\n    /* Tertiary button compact style */\n    button[kind=\"tertiary\"] {\n        background: transparent;\n        border: none;\n        box-shadow: none;\n    }\n    /* Agent Card Styling */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] {\n        background-color: white;\n        border-radius: 16px !important;\n        border: 1px solid #f0f0f0 !important;\n        box-shadow: 0 4px 20px rgba(0,0,0,0.04);\n        padding: 0.5rem;\n        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n    }\n    [data-testid=\"stVerticalBlockBorderWrapper\"]:hover {\n        transform: translateY(-4px);\n        box-shadow: 0 12px 24px rgba(0,0,0,0.08);\n        border-color: #ff4b4b44 !important;\n    }\n    .agent-header {\n        display: flex;\n        align-items: center;\n        gap: 12px;\n        margin-bottom: 12px;\n    }\n    .agent-icon {\n        font-size: 1.5em;\n        background: #f8f9fa;\n        width: 42px;\n        height: 42px;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 10px;\n        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;", "start_line": 601, "end_line": 650}, {"path": "src/interface/app.py", "content": "        box-shadow: inset 0 0 0 1px rgba(0,0,0,0.05);\n    }\n    .agent-name {\n        font-weight: 800;\n        font-size: 1.1em;\n        color: #1a1a1a;\n        letter-spacing: -0.01em;\n    }\n    .agent-desc {\n        font-size: 0.85em;\n        color: #64748b;\n        margin-bottom: 1rem;\n        min-height: 4.2em;\n        line-height: 1.5;\n    }\n    .count-display {\n        background: #f1f5f9;\n        color: #0f172a;\n        height: 2.4em;\n        display: flex;\n        align-items: center;\n        justify-content: center;\n        border-radius: 8px;\n        font-weight: 700;\n        font-size: 1.1em;\n    }\n    /* Compact buttons in cards */\n    [data-testid=\"stVerticalBlockBorderWrapper\"] .stButton button {\n        height: 2.4em !important;\n    }\n    .reset-button-container {\n        display: flex;\n        justify-content: center;\n        padding: 20px;\n    }\n    @keyframes pulse-gold {\n        0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }\n        70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }\n        100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }\n    }\n    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:", "start_line": 641, "end_line": 690}, {"path": "src/interface/app.py", "content": "    .active-turn {\n        animation: pulse-gold 2s infinite;\n        background-color: #fffde7 !important;\n        border: 2px solid #ffd700 !important;\n    }\n</style>\n\"\"\", unsafe_allow_html=True)\n\n# --- NAVIGATION ROUTER ---\nif \"page\" not in st.session_state:\n    st.session_state.page = \"Communication\"\n\n# --- SIDEBAR ---\nwith st.sidebar:\n    st.title(\"\ud83e\udd16 Orchestra\")\n    \n    # Global Autorefresh (Active on all pages to catch messages)\n    st_autorefresh(interval=4000, key=\"global_pulse\")\n\n    st.markdown(\"### Navigation\")\n    \n    # --- NOTIFICATION LOGIC ---\n    total_msgs = len(messages)\n    if \"last_read_count\" not in st.session_state:\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    unread = 0\n    if st.session_state.page != \"Communication\":\n        unread = max(0, total_msgs - st.session_state.last_read_count)\n        \n        # Toast for new messages\n        if \"last_toast_count\" not in st.session_state:\n             st.session_state.last_toast_count = total_msgs\n             \n        if total_msgs > st.session_state.last_toast_count:\n             new_count = total_msgs - st.session_state.last_toast_count\n             # Toast the last one\n             newest = messages[-1]\n             sender = newest.get(\"from\", \"?\")\n             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"", "start_line": 681, "end_line": 730}, {"path": "src/interface/app.py", "content": "             content = newest.get(\"content\", \"\")\n             preview = (content[:60] + \"...\") if len(content) > 60 else content\n             st.toast(f\"\ud83d\udce8 {sender}: {preview}\", icon=\"\ud83d\udd14\")\n             st.session_state.last_toast_count = total_msgs\n    else:\n        # On Chat Page -> Mark all read\n        st.session_state.last_read_count = total_msgs\n        st.session_state.last_toast_count = total_msgs\n\n    label_comm = \"\ud83d\udcac Communication\"\n    if unread > 0:\n        label_comm = f\"\ud83d\udcac Chat ({unread} \ud83d\udd34)\"\n\n    if st.button(label_comm, use_container_width=True, type=\"primary\" if st.session_state.page == \"Communication\" else \"secondary\"):\n        st.session_state.page = \"Communication\"\n        st.rerun()\n        \n    if st.button(\"\ud83c\udf9b\ufe0f Cockpit\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Cockpit\" else \"secondary\"):\n        st.session_state.page = \"Cockpit\"\n        st.rerun()\n        \n    if st.button(\"\ud83d\udee0\ufe0f \u00c9diteur\", use_container_width=True, type=\"primary\" if st.session_state.page == \"Editor\" else \"secondary\"):\n        st.session_state.page = \"Editor\"\n        st.rerun()\n\n    st.divider()\n    \n    # 1. Identity / User Status\n    st.markdown(\"### \ud83d\udc64 Identity\")\n    user_status = config.get(\"user_availability\", \"busy\")\n    \n    # User status toggle\n    is_available = st.toggle(\"Available\", value=(user_status == \"available\"), help=\"Switch between Available (\ud83d\udfe2) and Busy (\ud83d\udd34)\")\n    new_status = \"available\" if is_available else \"busy\"\n    \n    if new_status != user_status:\n        config[\"user_availability\"] = new_status\n        save_config(config)\n        st.rerun()\n\n    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:", "start_line": 721, "end_line": 770}, {"path": "src/interface/app.py", "content": "    status_icon = \"\ud83d\udfe2\" if new_status == \"available\" else \"\ud83d\udd34\"\n    st.info(f\"User Status: **{new_status.upper()}** {status_icon}\")\n\n    # Language\n    st.markdown(\"### \ud83c\udf10 Language\")\n    langs = [\"English\", \"French\", \"Chinese\", \"Persian\"]\n    current_lang = config.get(\"language\", \"English\")\n    if current_lang not in langs: current_lang = \"English\"\n    new_lang = st.selectbox(\"Interface Language\", langs, index=langs.index(current_lang))\n    if new_lang != current_lang:\n        config[\"language\"] = new_lang\n        save_config(config)\n        st.rerun()\n\n\n\n    st.divider()\n    \n\n\n    st.divider()\n\n    # 2. PERMANENT ROSTER (v2.0)\n    connected_count = len([n for n, d in agents.items() if n != \"User\" and d.get(\"status\") == \"connected\"])\n    st.markdown(f\"\"\"\n        <div style=\"display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px;\">\n            <h3 style=\"margin: 0; font-size: 1.2em;\">\ud83d\udc65 Agents Actifs</h3>\n            <span style=\"background: #e0e0e0; padding: 2px 8px; border-radius: 10px; font-size: 0.8em; font-weight: bold;\">{connected_count}</span>\n        </div>\n    \"\"\", unsafe_allow_html=True)\n    \n    # Maintain original order from agents dictionary\n    roster_list = [name for name in agents.keys()]\n    \n    # Explicitly add User to the top\n    roster_list.insert(0, \"User\")\n    \n    current_turn = turn.get(\"current\")\n    \n    if not roster_list:\n        st.caption(\"Aucun agent d\u00e9tect\u00e9.\")\n    else:\n        for name in roster_list:\n            # Handle User specifically since they are not in 'agents' dict\n            if name == \"User\":\n                u_avail = config.get(\"user_availability\", \"busy\")\n                # Map 'available' -> 'connected' (Green), 'busy' -> 'working' (Blue/Busy look)\n                info = {\n                    \"status\": \"connected\" if u_avail == \"available\" else \"working\",\n                    \"emoji\": \"\ud83d\udc64\"", "start_line": 761, "end_line": 810}, {"path": "src/interface/app.py", "content": "        st.caption(\"Aucun agent d\u00e9tect\u00e9.\")\n    else:\n        for name in roster_list:\n            # Handle User specifically since they are not in 'agents' dict\n            if name == \"User\":\n                u_avail = config.get(\"user_availability\", \"busy\")\n                # Map 'available' -> 'connected' (Green), 'busy' -> 'working' (Blue/Busy look)\n                info = {\n                    \"status\": \"connected\" if u_avail == \"available\" else \"working\",\n                    \"emoji\": \"\ud83d\udc64\"\n                }\n            else:\n                info = agents[name]\n            status = info.get(\"status\", \"pending\")\n            emoji = info.get(\"emoji\", \"\ud83e\udd16\")\n            is_turn = (name == current_turn)\n            \n            card_class = \"active-turn\" if is_turn else \"\"\n            \n            if info.get(\"reload_active\"):\n                status_color = \"#FF5722\" # Deep Orange\n                status_label = \"D\u00e9connexion...\"\n                bg = \"rgba(255, 87, 34, 0.1)\"\n                border_color = \"rgba(255, 87, 34, 0.3)\"\n            elif status == \"connected\":\n                status_color = \"#4CAF50\" # Green\n                status_label = \"En ligne\"\n                bg = \"rgba(76, 175, 80, 0.05)\"\n                border_color = \"rgba(76, 175, 80, 0.2)\"\n            elif status == \"pending_connection\":\n                status_color = \"#FF9800\" # Orange\n                status_label = \"Attente Reconnexion\"\n                bg = \"rgba(255, 152, 0, 0.05)\"\n                border_color = \"rgba(255, 152, 0, 0.2)\"\n            elif status == \"working\":\n                status_color = \"#2196F3\" # Blue\n                status_label = \"Travaille...\"\n                bg = \"rgba(33, 150, 243, 0.05)\"\n                border_color = \"rgba(33, 150, 243, 0.2)\"\n            else:\n                status_color = \"#9E9E9E\" # Grey\n                status_label = \"Hors-ligne\"\n                bg = \"transparent\"\n                border_color = \"#eee\"\n            \n            # Additional pulse if it's their turn and they are connected\n            is_active_working = is_turn and status == \"connected\"\n            if is_active_working:\n                status_color = \"#2196F3\"\n                status_label = \"En action...\"", "start_line": 801, "end_line": 850}, {"path": "src/interface/app.py", "content": "                status_color = \"#9E9E9E\" # Grey\n                status_label = \"Hors-ligne\"\n                bg = \"transparent\"\n                border_color = \"#eee\"\n            \n            # Additional pulse if it's their turn and they are connected\n            is_active_working = is_turn and status == \"connected\"\n            if is_active_working:\n                status_color = \"#2196F3\"\n                status_label = \"En action...\"\n            \n            card_html = f\"\"\"<div class=\"{card_class}\" style=\"background-color: {bg}; border: 1px solid {border_color}; border-radius: 10px; padding: 10px 14px; margin-bottom: 10px; display: flex; align-items: center; justify-content: space-between; transition: all 0.3s ease;\"><div style=\"display: flex; align-items: center; gap: 12px;\"><div style=\"font-size: 1.4em; background: white; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);\">{emoji}</div><div style=\"display: flex; flex-direction: column;\"><span style=\"font-weight: 600; color: {'#1a1a1a' if status == 'connected' else '#666'}; font-size: 0.95em;\">{name}</span><div style=\"display: flex; align-items: center; gap: 4px;\"><div style=\"width: 6px; height: 6px; background-color: {status_color}; border-radius: 50%;\"></div><span style=\"font-size: 0.7em; color: {status_color}; font-weight: 500; letter-spacing: 0.5px;\">{status_label}</span></div></div></div>{'<span style=\"font-size: 1.2em;\" title=\"C&rsquo;est son tour !\">\u2728</span>' if is_turn else ''}</div>\"\"\"\n            \n            if name == \"User\":\n                st.markdown(card_html, unsafe_allow_html=True)\n            else:\n                c_card, c_btn = st.columns([0.82, 0.18])\n                with c_card:\n                    st.markdown(card_html, unsafe_allow_html=True)\n                with c_btn:\n                    # Center the button vertically relative to card is hard, but simple button works\n                    # Add some top margin to align with card center approx\n                    st.markdown('<div style=\"height: 6px;\"></div>', unsafe_allow_html=True)\n                    agent_info = agents.get(name, {})\n                    is_reloading = agent_info.get(\"reload_active\") or (name in st.session_state.get(\"reload_queue\", []))\n\n                    if is_reloading:\n                        if st.button(\"\u274c\", key=f\"force_{name}\", help=\"Force Disconnect (Si bloqu\u00e9)\", type=\"primary\"):\n                             force_disconnect_agent(name)\n                             # Also remove from queue if present to unblock sequence\n                             if name in st.session_state.get(\"reload_queue\", []):\n                                 st.session_state.reload_queue.remove(name)\n                             st.rerun()\n                    else:\n                        if st.button(\"\ud83d\udd04\", key=f\"reload_{name}\", help=f\"Recharger {name}\"):\n                            handle_disconnect_agent(name)\n                            st.rerun()\n            \n    st.markdown(\"<div style='height: 10px;'></div>\", unsafe_allow_html=True)\n    if st.button(\"\ud83d\udd04 Reload All Agents\", type=\"secondary\", use_container_width=True, help=\"S\u00e9quence de rechargement (Parall\u00e8le).\"):\n         # Identify Targets\n        to_reload = [\n            n for n, d in agents.items() \n            if d.get(\"status\") in [\"connected\", \"working\"] \n        ]\n        if not to_reload:\n            st.toast(\"Aucun agent actif \u00e0 recharger.\")\n        else:\n            # START PARALLEL SEQUENCE\n            st.session_state.reload_queue = list(to_reload)", "start_line": 841, "end_line": 890}, {"path": "src/interface/app.py", "content": "         # Identify Targets\n        to_reload = [\n            n for n, d in agents.items() \n            if d.get(\"status\") in [\"connected\", \"working\"] \n        ]\n        if not to_reload:\n            st.toast(\"Aucun agent actif \u00e0 recharger.\")\n        else:\n            # START PARALLEL SEQUENCE\n            st.session_state.reload_queue = list(to_reload)\n            \n            # Atomic Bulk Update\n            def bulk_reload_signal(s):\n                count = 0\n                for name in to_reload:\n                    if name in s.get(\"agents\", {}):\n                         s[\"agents\"][name][\"reload_active\"] = True\n                         # Inject System Message\n                         msg = {\n                            \"from\": \"System\",\n                            \"content\": \"\ud83d\udd01 **SYSTEM NOTIFICATION**: RELOAD REQUESTED.\\n\"\n                                       \"1. Synthesize your final state into a `note()`.\\n\"\n                                       \"2. Call `disconnect()` to terminate process.\\n\"\n                                       \"\u26d4 **PROHIBITED**: `talk()`, `sleep()`.\",\n                            \"public\": False,\n                            \"target\": name,\n                            \"timestamp\": time.time()\n                         }\n                         s.setdefault(\"messages\", []).append(msg)\n                         count += 1\n                return f\"Signal de rechargement global envoy\u00e9 ({count} agents).\"\n            \n            state_store.update(bulk_reload_signal)\n            st.toast(f\"S\u00e9quence de rechargement PARALL\u00c8LE initialis\u00e9e pour {len(to_reload)} agents.\")\n            st.rerun()\n\n    # --- SEQUENTIAL RELOAD PROCESSOR ---\n    # Global Processor for the Queue\n    if \"reload_queue\" in st.session_state and st.session_state.reload_queue:\n        current_target = st.session_state.reload_queue[0]\n        \n        # Check current status (Refetch from fresh state)\n        if current_target in agents:\n            agent_data = agents[current_target]\n            status = agent_data.get(\"status\")\n            is_reload_active = agent_data.get(\"reload_active\")\n            \n            # Condition 1: Agent is finished (Disconnect/Pending)\n            if status in [\"pending_connection\", \"disconnected\", \"offline\"]:\n                st.session_state.reload_queue.pop(0) # Done", "start_line": 881, "end_line": 930}, {"path": "src/interface/app.py", "content": "        \n        # Check current status (Refetch from fresh state)\n        if current_target in agents:\n            agent_data = agents[current_target]\n            status = agent_data.get(\"status\")\n            is_reload_active = agent_data.get(\"reload_active\")\n            \n            # Condition 1: Agent is finished (Disconnect/Pending)\n            if status in [\"pending_connection\", \"disconnected\", \"offline\"]:\n                st.session_state.reload_queue.pop(0) # Done\n                st.rerun() # Proceed to next immediately\n                \n            # Condition 2: Agent needs to be signaled\n            elif not is_reload_active:\n                 handle_disconnect_agent(current_target)\n                 st.rerun()\n                 \n            # Condition 3: Waiting for agent...\n            else:\n                # Just wait. The autorefresh will loop us.\n                st.toast(f\"\u23f3 Attente d\u00e9connexion: {current_target}...\")\n        else:\n            # Agent gone? Remove from queue\n            st.session_state.reload_queue.pop(0) \n            st.rerun()\n\n    st.divider()\n\n    # --- PAUSE CONTROL ---\n    is_paused = config.get(\"paused\", False)\n    if st.toggle(\"\u23f8\ufe0f PAUSE MCP\", value=is_paused, help=\"Fige le temps pour tous les agents.\"):\n        if not is_paused:\n            config[\"paused\"] = True\n            save_config(config)\n            st.rerun()\n    else:\n        if is_paused:\n            config[\"paused\"] = False\n            save_config(config)\n            st.rerun()\n            \n    if is_paused:\n        st.warning(\"\u26a0\ufe0f SIMULATION EN PAUSE\")\n    \n    st.divider()\n\n    \n    # Debug Tools\n    with st.expander(\"\ud83d\udd27 DEBUG\"):\n        st.markdown(\"### \ud83d\udd0e Search Engine\")", "start_line": 921, "end_line": 970}, {"path": "src/interface/app.py", "content": "            \n    if is_paused:\n        st.warning(\"\u26a0\ufe0f SIMULATION EN PAUSE\")\n    \n    st.divider()\n\n    \n    # Debug Tools\n    with st.expander(\"\ud83d\udd27 DEBUG\"):\n        st.markdown(\"### \ud83d\udd0e Search Engine\")\n        \n        # Status Indicator\n        if search_engine and search_engine.initialized:\n            dev_label = search_engine.device.upper().replace(\"\u201d\", \"\") \n            st.caption(f\"Status: **Active** | Device: **{dev_label}** \u26a1\")\n        else:\n            st.caption(\"Status: \ud83d\udd34 Disabled (Missing Deps)\")\n\n        search_conf = config.get(\"search\", {})\n        \n        sc1, sc2 = st.columns(2)\n        with sc1:\n            x_val = st.number_input(\"Context (X)\", min_value=0, max_value=10, value=search_conf.get(\"x_markdown\", 3), help=\"Number of full markdown result to inject (Passive)\")\n        with sc2:\n            y_val = st.number_input(\"Total (Y)\", min_value=1, max_value=50, value=search_conf.get(\"y_total\", 15), help=\"Default limit for Search Tool\")\n            \n        if x_val != search_conf.get(\"x_markdown\", 3) or y_val != search_conf.get(\"y_total\", 15):\n            if \"search\" not in config: config[\"search\"] = {}\n            config[\"search\"][\"x_markdown\"] = x_val\n            config[\"search\"][\"y_total\"] = y_val\n            save_config(config)\n            st.toast(\"Search config saved!\")\n            time.sleep(0.5)\n            st.rerun()\n\n        st.divider()\n\n        st.markdown(\"### \u2702\ufe0f MCP Truncation Settings\")\n        current_trunc = config.get(\"truncation_limit\", 4096) # Default 4096\n        new_trunc = st.number_input(\"Max Character Limit (0 = Disabled)\", min_value=0, value=int(current_trunc), step=100, help=\"Limite manuelle pour \u00e9viter le tronquage silencieux du client MCP (4096 bytes max).\")\n        if new_trunc != current_trunc:\n             config[\"truncation_limit\"] = int(new_trunc)\n             save_config(config)\n             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):", "start_line": 961, "end_line": 1010}, {"path": "src/interface/app.py", "content": "        if new_trunc != current_trunc:\n             config[\"truncation_limit\"] = int(new_trunc)\n             save_config(config)\n             st.rerun()\n             \n        if st.button(\"Fix MCP Config\"):\n            import subprocess\n            try:\n                config_path = os.path.expanduser(\"~/.gemini/antigravity/mcp_config.json\")\n                if os.path.exists(config_path):\n                    with open(config_path, \"r\") as f:\n                        json_data = json.load(f)\n                    current_dir = str(CONFIG_CODE_ROOT)\n                    server_script = os.path.join(current_dir, \"src\", \"core\", \"server.py\")\n                    command_str = f\"cd {current_dir} && uv run python {server_script}\"\n                    if \"mcpServers\" not in json_data:\n                        json_data[\"mcpServers\"] = {}\n                    json_data[\"mcpServers\"][\"multi-agents-mcp\"] = {\n                        \"command\": \"sh\",\n                        \"args\": [\"-c\", command_str],\n                        \"env\": {}\n                    }\n                    with open(config_path, \"w\") as f:\n                        json.dump(json_data, f, indent=2)\n                    st.success(\"Config Path Updated\")\n            except Exception as e:\n                st.error(str(e))\n\n        if st.button(\"Delete Memories\"):\n            try:\n                mem_dir = str(MEMORY_DIR)\n                if os.path.exists(mem_dir):\n                    import shutil\n                    shutil.rmtree(mem_dir)\n                    os.makedirs(mem_dir, exist_ok=True)\n                    st.success(\"Memories Cleared\")\n            except Exception as e:\n                st.error(str(e))\n\n\n# ==========================================\n# PAGE: COMMUNICATION (Chat)\n# ==========================================\nif st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")", "start_line": 1001, "end_line": 1050}, {"path": "src/interface/app.py", "content": "# ==========================================\n# PAGE: COMMUNICATION (Chat)\n# ==========================================\nif st.session_state.page == \"Communication\":\n    # 0. Global Filter State\n    is_urgent_focus = st.session_state.get(\"is_urgent_focus\", False)\n\n    c_title, c_status = st.columns([6, 4])\n    with c_title:\n        st.header(\"\ud83d\udcac Flux Neural\")\n    with c_status:\n        current_turn = turn.get(\"current\", \"?\")\n        if current_turn == \"User\":\n            # FOCUS MODE STYLES\n            st.markdown(\"\"\"\n            <style>\n            /* Gray out previous messages to focus on input */\n            .stChatMessage { opacity: 0.5; filter: grayscale(0.6); transition: all 0.3s; }\n            /* Highlight Input Area */\n            div[data-testid=\"stChatInput\"] { \n                border: 2px solid #ff3d00 !important; \n                border-radius: 12px;\n                box-shadow: 0 0 15px rgba(255, 61, 0, 0.4) !important;\n                background-color: #fff8f5 !important;\n            }\n            </style>\n            \"\"\", unsafe_allow_html=True)\n            \n\n        else:\n            st.markdown(f\"\"\"<div style=\"background-color: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; border-radius: 8px; text-align: center;\"><span style=\"color: #6c757d; font-size: 0.9em;\">En attente de :</span><br><span style=\"color: #1f1f1f; font-weight: bold; font-size: 1.1em;\">\ud83e\udd16 {current_turn}</span></div>\"\"\", unsafe_allow_html=True)\n    \n    # 1. Reply Context State\n    if \"reply_to\" not in st.session_state:\n        st.session_state.reply_to = None\n\n    # --- FLUX NEURAL (FULL WIDTH) ---\n    \n    # Helper for rendering messages and reply buttons\n    def render_reply_button(sender, content, idx):\n        if st.button(\"\u21a9\ufe0f\", key=f\"btn_reply_set_{idx}\", help=f\"Reply to {sender}\", type=\"tertiary\"):\n            st.session_state.reply_to = {\n                \"sender\": sender,\n                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):", "start_line": 1041, "end_line": 1090}, {"path": "src/interface/app.py", "content": "        if st.button(\"\u21a9\ufe0f\", key=f\"btn_reply_set_{idx}\", help=f\"Reply to {sender}\", type=\"tertiary\"):\n            st.session_state.reply_to = {\n                \"sender\": sender,\n                \"id\": idx,\n                \"preview\": content[:50] + \"...\" if len(content) > 50 else content\n            }\n            st.rerun()\n\n    stream_msgs = []\n    for i, m in enumerate(messages):\n        # GOD MODE: Always True to allow Admin (User) to see everything\n        is_relevant = True \n        # is_relevant = m.get(\"public\", False) or m.get(\"target\") == \"User\" or m.get(\"from\") == \"User\"\n        if is_relevant:\n            # FILTER LOGIC\n            if is_urgent_focus:\n                target = m.get(\"target\")\n                is_replied = m.get(\"replied\", False)\n                # Show only if directed to User AND not replied\n                if target != \"User\" or is_replied:\n                    continue\n            stream_msgs.append((i, m))\n    \n    # Pagination\n    if \"stream_limit\" not in st.session_state: st.session_state.stream_limit = 25\n    total_stream = len(stream_msgs)\n    limit_stream = st.session_state.stream_limit\n    if total_stream > limit_stream:\n            # UI Minimaliste (Tertiary)\n            if st.button(f\"\ud83d\udd03 Historique ({total_stream - limit_stream})\", key=\"load_more_stream\", type=\"tertiary\"):\n                st.session_state.stream_limit += 25\n                st.rerun()\n    \n    visible_stream = stream_msgs[max(0, total_stream - limit_stream):]\n    \n    if not visible_stream:\n        st.info(\"Aucune activit\u00e9 d\u00e9tect\u00e9e sur les bandes neurales.\")\n        \n    for real_idx, m in visible_stream:\n        sender = m.get(\"from\", \"?\")\n        target = m.get(\"target\", \"?\")\n        content = m.get(\"content\", \"\")\n        is_public = m.get(\"public\", False)\n        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})", "start_line": 1081, "end_line": 1130}, {"path": "src/interface/app.py", "content": "        target = m.get(\"target\", \"?\")\n        content = m.get(\"content\", \"\")\n        is_public = m.get(\"public\", False)\n        timestamp = m.get(\"timestamp\", 0)\n        is_replied = m.get(\"replied\", False)\n        \n        # FORMAT MENTIONS\n        content_visual = format_mentions(content)\n        \n        agent_info = agents.get(sender, {})\n        sender_emoji = agent_info.get(\"emoji\", \"\ud83e\udd16\") if sender != \"System\" else \"\ud83d\udcbe\"\n        if sender == \"User\": sender_emoji = \"\ud83d\udc64\"\n        \n        # Style and Tag Logic\n        tag_html = \"\"\n        bubble_style = \"\"\n        \n        if is_public:\n            tag_html = ''\n            bubble_style = \"background-color: rgba(248, 249, 250, 0.8); border-left: 4px solid #2e7d32;\"\n        else:\n            if target == \"User\":\n                tag_html = '<span class=\"status-tag direct-tag\">\ud83d\udd12 Direct Link</span>'\n                if not is_replied:\n                    tag_html += '<span class=\"status-tag urgent-tag\">\u26a1 Action Required</span>'\n                    bubble_style = \"background-color: #fffdf0; border-left: 4px solid #fbc02d; box-shadow: 0 4px 12px rgba(251, 192, 45, 0.12);\"\n                else:\n                    bubble_style = \"background-color: #f0f7ff; border-left: 4px solid #1976d2;\"\n            elif sender == \"User\":\n                tag_html = f'<span class=\"status-tag\">\ud83d\udce4 Outgoing to {target}</span>'\n                bubble_style = \"background-color: #ffffff; border-left: 4px solid #94a3b8;\"\n            else:\n                tag_html = f'<span class=\"status-tag direct-tag\" style=\"background: #ffebee; color: #c62828;\">\ud83d\udd12 Private {sender} \u2192 {target}</span>'\n                bubble_style = \"background-color: #fff8f8; border: 2px dashed #ff4b4b;\"\n\n        with st.chat_message(sender, avatar=sender_emoji):\n            # Header with sender, target and status tags\n            c_header, c_action = st.columns([12, 1])\n            \n            with c_header:\n                st.markdown(f\"\"\"<div class=\"message-header\"><span style=\"font-weight: 700; color: #333; font-size: 0.9em;\">{sender}</span><span style=\"color: #999; font-size: 0.8em;\">\u2192</span><span class=\"target-badge\">{target if target != 'all' else 'everyone'}</span>{tag_html}<span style=\"color: #bbb; font-size: 0.7em; margin-left: auto;\">{time.strftime('%H:%M:%S', time.localtime(timestamp))}</span></div>\"\"\", unsafe_allow_html=True)\n            \n            with c_action:\n                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---", "start_line": 1121, "end_line": 1170}, {"path": "src/interface/app.py", "content": "                st.markdown(f\"\"\"<div class=\"message-header\"><span style=\"font-weight: 700; color: #333; font-size: 0.9em;\">{sender}</span><span style=\"color: #999; font-size: 0.8em;\">\u2192</span><span class=\"target-badge\">{target if target != 'all' else 'everyone'}</span>{tag_html}<span style=\"color: #bbb; font-size: 0.7em; margin-left: auto;\">{time.strftime('%H:%M:%S', time.localtime(timestamp))}</span></div>\"\"\", unsafe_allow_html=True)\n            \n            with c_action:\n                render_reply_button(sender, content, real_idx)\n\n            # Message Content\n            st.markdown(f\"\"\"<div class=\"message-bubble\" style=\"{bubble_style}\"><div style=\"color: #1f1f1f; line-height: 1.5;\">\\n\\n{content_visual}</div></div>\"\"\", unsafe_allow_html=True)\n\n\n    # --- UI CONTROLS (Above Input) ---\n    # 1. Reply Banner\n    if st.session_state.reply_to:\n        ctx = st.session_state.reply_to\n        col_banner, col_x = st.columns([11, 1])\n        with col_banner:\n            st.markdown(f'<div class=\"reply-banner-custom\">\u21a9\ufe0f R\u00e9ponse \u00e0 <b>{ctx[\"sender\"]}</b>: \"{ctx[\"preview\"]}\"</div>', unsafe_allow_html=True)\n        with col_x:\n            if st.button(\"\u2716\ufe0f\", key=\"cancel_reply_v6\", help=\"Annuler\"):\n                st.session_state.reply_to = None\n                st.rerun()\n\n    # 2. Status & Focus Row\n    # (No extra spacer here to avoid empty divs)\n    \n    # 2a. Typing Indicator (Centered)\n    typing_agents = []\n    current_turn_name = turn.get(\"current\")\n    for name, info in agents.items():\n        if name == \"User\": continue\n        if info.get(\"status\") == \"working\" or (name == current_turn_name and info.get(\"status\") == \"connected\"):\n            typing_agents.append(name)\n    \n    if typing_agents:\n        agent_names = \", \".join(typing_agents)\n        plural = \"sont\" if len(typing_agents) > 1 else \"est\"\n        st.markdown(f'<div class=\"typing-container\">{agent_names} {plural} en train d\\'\u00e9crire...<div class=\"typing-dots\"><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div><div class=\"typing-dot\"></div></div></div>', unsafe_allow_html=True)\n    \n    # 2b. Focus Toggle (Removed)\n    c1, c2, c3 = st.columns([1, 1, 1])\n    \n    # MOVED: Banner in bottom right (c3)\n    if turn.get(\"current\") == \"User\":\n        with c3:\n            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone", "start_line": 1161, "end_line": 1210}, {"path": "src/interface/app.py", "content": "    # MOVED: Banner in bottom right (c3)\n    if turn.get(\"current\") == \"User\":\n        with c3:\n            st.markdown(\"\"\"<div style=\"background-color: #fff3cd; border: 2px solid #ff3d00; padding: 8px; border-radius: 8px; text-align: center; animation: pulse 2s infinite;\"><span style=\"color: #bf360c; font-weight: 900; font-size: 0.9em; text-transform: uppercase;\">\u26a1 \u00c0 VOUS DE JOUER \u26a1</span></div><style>@keyframes pulse {0% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0.4); } 70% { box-shadow: 0 0 0 15px rgba(255, 61, 0, 0); } 100% { box-shadow: 0 0 0 0 rgba(255, 61, 0, 0); }}</style>\"\"\", unsafe_allow_html=True)\n\n    # --- OMNI-CHANNEL INPUT ---\n    # Maintain original order for mention system\n    connected_agents = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    \n    # We still need this for the mention system to know the list, adding everyone\n    # FIXED: Moved injection to bottom to ensure DOM readiness\n    # inject_mention_system([\"everyone\"] + connected_agents)\n\n    # Main Input\n    if prompt := st.chat_input(\"Message...\"):\n        def send_omni_msg(s):\n            target = None\n            public = True\n            reply_ref_id = None\n            \n            # Logic v2.0\n            \n            # 1. Context Reply (Strongest implicit) \n            # Tech Lead said: \"1. Si @Mention -> Priority. 2. Sinon si target_sel != Tous -> Target.\"\n            # Actually Context Reply usually overrides Selector visually, but Mention overrides all?\n            # Let's follow instruction:\n            # 1. Mention check\n            # 2. Selector check\n            # 3. Public\n            \n            found_mentions = []\n            found_mention = False\n            \n            # Mention Check (Specific Agents only)\n            known_agents = sorted(list(agents.keys()), key=len, reverse=True)\n            \n            # Use regex to find all mentions in order of appearance\n            # Sorting known_agents by length reverse ensures longer names are matched first\n            if known_agents:\n                pattern = \"@(\" + \"|\".join([re.escape(name) for name in known_agents]) + \")\"\n                matches = re.finditer(pattern, prompt)\n                seen = set()\n                for match in matches:\n                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]", "start_line": 1201, "end_line": 1250}, {"path": "src/interface/app.py", "content": "                matches = re.finditer(pattern, prompt)\n                seen = set()\n                for match in matches:\n                    name = match.group(1)\n                    if name not in seen:\n                        found_mentions.append(name)\n                        seen.add(name)\n            \n            if found_mentions:\n                target = found_mentions[0]\n                audience = found_mentions[1:]\n                public = False\n                found_mention = True\n            else:\n                audience = []\n            \n            if not found_mention:\n                if st.session_state.reply_to:\n                     # Reply Context overrides Selector\n                     target = st.session_state.reply_to[\"sender\"]\n                     reply_ref_id = st.session_state.reply_to[\"id\"]\n                     public = False\n                else:\n                    # No mention, no reply context -> Public Broadcast\n                    target = \"all\"\n                    public = True\n            \n            # Prepare content with Reply Context\n            final_content = prompt\n            if st.session_state.reply_to:\n                ref = st.session_state.reply_to\n                final_content = f\"\u21aa\ufe0f [R\u00e9ponse \u00e0 {ref['sender']}: \\\"{ref['preview']}\\\"]\\n{prompt}\"\n\n            msg = {\n                \"from\": \"User\",\n                \"content\": final_content,\n                \"timestamp\": time.time(),\n                \"public\": public,\n                \"audience\": audience\n            }\n            if target:\n                msg[\"target\"] = target\n            else:\n                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}", "start_line": 1241, "end_line": 1290}, {"path": "src/interface/app.py", "content": "            if target:\n                msg[\"target\"] = target\n            else:\n                msg[\"target\"] = \"all\"\n                \n            if \"messages\" not in s: s[\"messages\"] = []\n            s[\"messages\"].append(msg)\n            \n            # CRITICAL: Update timestamp for Anti-Ghost logic in logic.py\n            if \"turn\" not in s: s[\"turn\"] = {}\n            s[\"turn\"][\"last_user_message_time\"] = msg[\"timestamp\"]\n            \n            # --- TURN MANAGEMENT (If User had the turn) ---\n            if s.get(\"turn\", {}).get(\"current\") == \"User\":\n                next_speaker = None\n                if target and target != \"all\" and target in s.get(\"agents\", {}):\n                    next_speaker = target\n                else:\n                    # Priority 1: first_agent defined during reset\n                    first_pref = s.get(\"turn\", {}).get(\"first_agent\")\n                    if first_pref and first_pref in s.get(\"agents\", {}):\n                        next_speaker = first_pref\n                    else:\n                        # Fallback to the first connected agent\n                        connected = [n for n, d in s.get(\"agents\", {}).items() if d.get(\"status\") == \"connected\"]\n                        if connected:\n                            next_speaker = connected[0]\n                \n                if next_speaker:\n                    # USE CENTRALIZED TRANSITION LOGIC FROM ENGINE\n                    from src.core.logic import Engine\n                    engine = Engine(state_store) # Use the global state_store\n                    engine._finalize_turn_transition(s, next_speaker)\n\n            # Context Cleanup\n            if reply_ref_id is not None:\n                if reply_ref_id < len(s[\"messages\"]):\n                     s[\"messages\"][reply_ref_id][\"replied\"] = True\n                     \n            return \"Message Transmis.\"\n\n        res = state_store.update(send_omni_msg)\n        st.session_state.reply_to = None\n        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)", "start_line": 1281, "end_line": 1330}, {"path": "src/interface/app.py", "content": "\n        res = state_store.update(send_omni_msg)\n        st.session_state.reply_to = None\n        st.toast(res)\n        st.rerun()\n\n\n\n# ==========================================\n# PAGE: COCKPIT (Admin)\n# ==========================================\nelif st.session_state.page == \"Cockpit\":\n    st.header(\"\ud83c\udf9b\ufe0f Cockpit de Supervision\")\n    \n    # --- 0. GRAPHVIZ VIEW (TOP) ---\n    with st.expander(\"\ud83d\udd78\ufe0f Topologie de la Flotte (Graphviz)\", expanded=False):\n        try:\n            g = render_graph(profiles)\n            st.graphviz_chart(g, use_container_width=True)\n        except Exception as e:\n            st.error(f\"Erreur de rendu du graphe : {e}\")\n\n    # Scenarios\n    st.subheader(\"\ud83d\udcbe Sc\u00e9narios\")\n    with st.container(border=True):\n        col_scen1, col_scen2 = st.columns(2)\n        if col_scen1.button(\"\ud83d\udcbe Sauvegarder\", use_container_width=True, help=\"Sauvegarder la configuration actuelle\"):\n            save_scenario_dialog(config)\n        if col_scen2.button(\"\ud83d\udcc2 Charger\", use_container_width=True, help=\"Charger une configuration existante\"):\n            load_scenario_dialog()\n\n    # Global Context (Full Width)\n    st.subheader(\"\ud83c\udf0d Contexte Global\")\n    with st.container(border=True):\n        enable_backlog = st.checkbox(\"Backlog\", value=config.get(\"enable_backlog\", False), help=\"Si coch\u00e9, les agents consulteront et mettront \u00e0 jour BACKLOG.md \u00e0 la racine.\")\n        if enable_backlog != config.get(\"enable_backlog\", False):\n            config[\"enable_backlog\"] = enable_backlog\n            save_config(config)\n            st.rerun()\n\n\n        global_context = st.text_area(\"Narratif / Contexte Partag\u00e9\", config.get(\"context\", \"\"), height=215)\n        if global_context != config.get(\"context\", \"\"):\n            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    ", "start_line": 1321, "end_line": 1370}, {"path": "src/interface/app.py", "content": "\n        global_context = st.text_area(\"Narratif / Contexte Partag\u00e9\", config.get(\"context\", \"\"), height=215)\n        if global_context != config.get(\"context\", \"\"):\n            if st.button(\"Mettre \u00e0 jour le Contexte\", use_container_width=True):\n                config[\"context\"] = global_context\n                save_config(config)\n                st.success(\"Contexte mis \u00e0 jour\")\n\n    st.divider()\n    \n    # --- 2. CREW MANAGEMENT (MODERN CARDS) ---\n    st.subheader(\"\ud83d\udc65 Crew Management\")\n    \n    # Display cards in a grid\n    cols_per_row = 3\n    for i in range(0, len(profiles), cols_per_row):\n        cols = st.columns(cols_per_row)\n        for j in range(cols_per_row):\n            if i + j < len(profiles):\n                p = profiles[i + j]\n                with cols[j]:\n                    with st.container(border=True):\n                        count = int(p.get(\"count\", 0))\n                        emoji = p.get(\"emoji\", \"\ud83e\udd16\")\n                        description = p.get(\"description\", \"Aucune description.\")\n                        \n                        st.markdown(f\"\"\"<div class=\"agent-header\"><div class=\"agent-icon\">{emoji}</div><div class=\"agent-name\">{p['name']}</div></div><div class=\"agent-desc\">{description}</div>\"\"\", unsafe_allow_html=True)\n                        \n                        # Controls inside the card\n                        ctrl_c1, ctrl_c2, ctrl_c3 = st.columns([1, 1.2, 1])\n                        if ctrl_c1.button(\"\u2796\", key=f\"d_{i+j}\", use_container_width=True):\n                            p[\"count\"] = max(0, count - 1)\n                            save_config(config)\n                            st.rerun()\n                        \n                        ctrl_c2.markdown(f'<div class=\"count-display\">{count}</div>', unsafe_allow_html=True)\n                        \n                        if ctrl_c3.button(\"\u2795\", key=f\"i_{i+j}\", use_container_width=True):\n                            p[\"count\"] = count + 1\n                            save_config(config)\n                            st.rerun()\n                            \n                        if st.button(\"\u270f\ufe0f Modifier\", key=f\"ed_{i+j}\", use_container_width=True, type=\"secondary\"):\n                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---", "start_line": 1361, "end_line": 1410}, {"path": "src/interface/app.py", "content": "                            st.rerun()\n                            \n                        if st.button(\"\u270f\ufe0f Modifier\", key=f\"ed_{i+j}\", use_container_width=True, type=\"secondary\"):\n                            st.session_state.editing_agent_name = p[\"name\"]\n                            st.session_state.page = \"Editor\"\n                            st.rerun()\n\n    st.markdown(\"---\")\n\n    # --- 2.5 FIRST SPEAKER SELECTOR ---\n    st.subheader(\"\ud83c\udfaf S\u00e9quence de D\u00e9part\")\n    potential_agents = []\n    \n    # Calculate potential agent IDs the same way reset_logic does\n    temp_slots = []\n    for p in profiles:\n        for _ in range(int(p.get(\"count\", 0))):\n            temp_slots.append(p.get(\"display_name\") or p[\"name\"])\n            \n    counters = {}\n    for base in temp_slots:\n        counters.setdefault(base, 0)\n        counters[base] += 1\n        total_of_this_base = sum(1 for b in temp_slots if b == base)\n        agent_id = f\"{base} #{counters[base]}\" if total_of_this_base > 1 else base\n        potential_agents.append(agent_id)\n\n    # Use session state to persist choice\n    if \"first_speaker\" not in st.session_state:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    # Check if current choice is still valid (profiles might have changed)\n    if st.session_state.first_speaker not in potential_agents:\n        st.session_state.first_speaker = potential_agents[0] if potential_agents else \"\"\n\n    selected_first = st.selectbox(\"Qui r\u00e9pondra en premier \u00e0 l'utilisateur ?\", potential_agents,\n                                 index=potential_agents.index(st.session_state.first_speaker) if st.session_state.first_speaker in potential_agents else 0,\n                                 help=\"L'agent qui aura le premier tour pour r\u00e9pondre au premier message de l'utilisateur.\")\n    st.session_state.first_speaker = selected_first\n\n    st.markdown(\"<br>\", unsafe_allow_html=True)\n\n    # --- 3. RESET BUTTON (MODERN) ---\n    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())", "start_line": 1401, "end_line": 1450}, {"path": "src/interface/app.py", "content": "    st.markdown(\"<br>\", unsafe_allow_html=True)\n\n    # --- 3. RESET BUTTON (MODERN) ---\n    col_r1, col_r2, col_r3 = st.columns([1, 2, 1])\n    with col_r2:\n        if st.button(\"\ud83d\ude80 INITIALISER LA SIMULATION\", type=\"primary\", use_container_width=True, help=\"R\u00e9initialise tous les agents et la conversation\"):\n            first_speaker_choice = st.session_state.first_speaker\n            \n            def reset_logic(s):\n                s[\"conversation_id\"] = str(uuid.uuid4())\n                s[\"messages\"] = []\n                s[\"turn\"] = {\"current\": \"User\", \"next\": None, \"first_agent\": first_speaker_choice}\n                s[\"config\"][\"context\"] = global_context\n                \n                # Use profiles from the state s for absolute consistency\n                current_profiles = s[\"config\"].get(\"profiles\", [])\n                \n                # Update total agents count\n                total_count = get_total_agents(current_profiles)\n                s[\"config\"][\"total_agents\"] = total_count\n                \n                pending_slots = []\n                # Remove random shuffle to maintain profile order\n                for p in current_profiles:\n                    for _ in range(int(p.get(\"count\", 0))):\n                        pending_slots.append({\n                            \"profile_ref\": p[\"name\"],\n                            \"role\": p.get(\"system_prompt\", \"\"),\n                            \"display_base\": p.get(\"display_name\") or p[\"name\"],\n                            \"emoji\": p.get(\"emoji\", \"\ud83e\udd16\")\n                        })\n                \n                new_agents = {}\n                counters = {}\n                for slot in pending_slots:\n                    base = slot[\"display_base\"]\n                    counters.setdefault(base, 0)\n                    counters[base] += 1\n                    agent_id = f\"{base} #{counters[base]}\" if sum(1 for sl in pending_slots if sl[\"display_base\"] == base) > 1 else base\n                    new_agents[agent_id] = {\n                        \"role\": slot[\"role\"], \"status\": \"pending_connection\",\n                        \"profile_ref\": slot[\"profile_ref\"], \"emoji\": slot[\"emoji\"]\n                    }\n                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)", "start_line": 1441, "end_line": 1490}, {"path": "src/interface/app.py", "content": "                        \"role\": slot[\"role\"], \"status\": \"pending_connection\",\n                        \"profile_ref\": slot[\"profile_ref\"], \"emoji\": slot[\"emoji\"]\n                    }\n                s[\"agents\"] = new_agents\n                \n                s.setdefault(\"messages\", []).append({\n                    \"from\": \"System\", \"content\": f\"\ud83d\udfe2 SIMULATION RESET. En attente de l'utilisateur. (Premier r\u00e9pondant : {first_speaker_choice})\", \"public\": True, \"timestamp\": time.time()\n                })\n                return \"R\u00e9initialisation termin\u00e9e\"\n            msg = state_store.update(reset_logic)\n            st.toast(msg)\n            time.sleep(0.5)\n            st.session_state.page = \"Communication\"\n            st.rerun()\n\n\n# ==========================================\n# PAGE: EDITOR (Admin)\n# ==========================================\nelif st.session_state.page == \"Editor\":\n    st.header(\"\ud83d\udee0\ufe0f \u00c9diteur d'Agents\")\n    \n    profile_names = [p[\"name\"] for p in profiles]\n    profile_names.append(\"\u2795 Create New\")\n    \n    sel_idx = 0\n    cur_edit = st.session_state.get(\"editing_agent_name\")\n    if cur_edit in profile_names:\n        sel_idx = profile_names.index(cur_edit)\n        \n    selected_name = st.selectbox(\"Selection Profil\", profile_names, index=sel_idx, key=\"edit_sel_page\")\n    \n    if selected_name == \"\u2795 Create New\":\n        current_profile = {\n            \"name\": \"New Agent\", \n            \"description\": \"\", \n            \"emoji\": \"\ud83e\udd16\", # Default, will be randomized in session state\n            \"connections\": [], \n            \"count\": 1, \n            \"capabilities\": [\"public\"]\n        }\n        new_mode = True\n        st.session_state.editing_agent_name = \"New Agent\"\n        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)", "start_line": 1481, "end_line": 1530}, {"path": "src/interface/app.py", "content": "        }\n        new_mode = True\n        st.session_state.editing_agent_name = \"New Agent\"\n        \n        # Initialize with a random emoji if not already set\n        emoji_key = f\"editing_emoji_{selected_name}\"\n        if emoji_key not in st.session_state:\n            st.session_state[emoji_key] = get_random_emoji()\n    else:\n        current_profile = next((p for p in profiles if p[\"name\"] == selected_name), None)\n        new_mode = False\n        st.session_state.editing_agent_name = selected_name\n        \n        if st.button(\"\ud83d\uddd1\ufe0f Supprimer Profil\", type=\"primary\"):\n             config[\"profiles\"] = [p for p in profiles if p[\"name\"] != selected_name]\n             emoji_key = f\"editing_emoji_{selected_name}\"\n             if emoji_key in st.session_state:\n                 del st.session_state[emoji_key]\n             save_config(config)\n             st.rerun()\n\n    if current_profile:\n        st.markdown(\"---\")\n        # Layout Spacieux (Columns)\n        c_main, c_disp = st.columns([3, 2])\n        \n        with c_main:\n            c_emoji, c_name = st.columns([0.18, 0.82])\n            \n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key not in st.session_state:\n                st.session_state[emoji_key] = current_profile.get(\"emoji\", \"\ud83e\udd16\")\n            current_emoji = st.session_state[emoji_key]\n            \n            with c_emoji:\n                st.markdown('<div style=\"height: 28px;\"></div>', unsafe_allow_html=True) # Spacer to align with text input label\n                with st.popover(f\"{current_emoji}\", use_container_width=True):\n                    cols = st.columns(8)\n                    for idx, emoji in enumerate(EMOJI_LIST):\n                        if cols[idx % 8].button(emoji, key=f\"emoji_btn_{selected_name}_{idx}\"):\n                            st.session_state[emoji_key] = emoji\n                            st.rerun()\n            \n            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")", "start_line": 1521, "end_line": 1570}, {"path": "src/interface/app.py", "content": "                            st.session_state[emoji_key] = emoji\n                            st.rerun()\n            \n            with c_name:\n                new_name = st.text_input(\"Nom\", current_profile.get(\"name\", \"\"), key=f\"edit_name_{selected_name}\")\n\n        with c_disp:\n            disp = st.text_input(\"Affichage\", current_profile.get(\"display_name\", \"\"), key=f\"edit_disp_{selected_name}\")\n        \n        new_desc = st.text_input(\"Description\", current_profile.get(\"description\", \"\"), key=f\"edit_desc_{selected_name}\")\n        new_prompt = st.text_area(\"System Prompt\", current_profile.get(\"system_prompt\", \"\"), height=300, key=f\"edit_prompt_{selected_name}\")\n        \n        st.subheader(\"Capacit\u00e9s de Communication\")\n        caps = current_profile.get(\"capabilities\", [])\n        \n        # Preserve other capabilities (e.g. shell_exec)\n        other_caps = [c for c in caps if c not in [\"public\", \"private\"]]\n        \n        has_pub = \"public\" in caps\n        has_priv = \"private\" in caps\n        \n        # Determine default index\n        default_idx = 0 # Public\n        if has_pub and has_priv:\n            default_idx = 2 # Both\n        elif has_priv and not has_pub:\n            default_idx = 1 # Private\n        \n        comm_mode = st.radio(\n            \"Port\u00e9e de Communication\",\n            [\"Public\", \"Priv\u00e9\", \"Les Deux (Public & Priv\u00e9)\"],\n            index=default_idx,\n            key=f\"comm_mode_{selected_name}\",\n            horizontal=True,\n            help=\"D\u00e9finit la port\u00e9e de communication autoris\u00e9e pour cet agent.\"\n        )\n        \n        new_caps = list(other_caps)\n        if comm_mode == \"Public\":\n            new_caps.append(\"public\")\n        elif comm_mode == \"Priv\u00e9\":\n            new_caps.append(\"private\")\n        else:\n            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]", "start_line": 1561, "end_line": 1610}, {"path": "src/interface/app.py", "content": "        elif comm_mode == \"Priv\u00e9\":\n            new_caps.append(\"private\")\n        else:\n            new_caps.append(\"public\")\n            new_caps.append(\"private\")\n\n        st.subheader(\"Connexions\")\n        st.info(\"D\u00e9finissez qui cet agent peut contacter et dans quel but (contexte strat\u00e9gique).\")\n        \n        other_profile_names = [p[\"name\"] for p in profiles if p[\"name\"] != current_profile.get(\"name\")]\n        # Standardize targets to title case for matching with state.json while keeping user/public accessible\n        targets = [\"public\", \"User\"] + other_profile_names\n        \n        new_connections = []\n        \n        # Header for the \"Table\"\n        with st.container():\n            h1, h2, h3 = st.columns([2, 5, 1])\n            h1.markdown(\"**Cible**\")\n            h2.markdown(\"**Condition / Contexte**\")\n            h3.markdown(\"**Active**\")\n            st.markdown(\"<hr style='margin-top: 0; margin-bottom: 10px; border-color: #eee;'>\", unsafe_allow_html=True)\n        \n        for target in targets:\n            # Case-insensitive match for connections\n            existing_conn = next((c for c in current_profile.get(\"connections\", []) if c[\"target\"].lower() == target.lower()), None)\n            \n            c1, c2, c3 = st.columns([2, 5, 1])\n            \n            # Label\n            target_profile = next((p for p in profiles if p[\"name\"] == target), None)\n            target_emoji = \"\ud83c\udf10\" if target == \"public\" else \"\ud83d\udc64\" if target == \"User\" else (target_profile.get(\"emoji\", \"\ud83e\udd16\") if target_profile else \"\ud83e\udd16\")\n            c1.markdown(f\"{target_emoji} **{target}**\")\n            \n            default_ctx = existing_conn.get(\"context\", \"\") if existing_conn else \"\"\n            default_auth = existing_conn.get(\"authorized\", True) if existing_conn else False\n            \n            # Unique key with selected_name and target\n            ctx = c2.text_area(f\"Condition for {target}\", default_ctx, key=f\"conn_ctx_{selected_name}_{target}\", label_visibility=\"collapsed\", height=68)\n            auth = c3.checkbox(f\"Active for {target}\", default_auth, key=f\"conn_auth_{selected_name}_{target}\", label_visibility=\"collapsed\")\n            \n            if auth or ctx:\n                new_connections.append({\"target\": target, \"context\": ctx, \"authorized\": auth})\n            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt", "start_line": 1601, "end_line": 1650}, {"path": "src/interface/app.py", "content": "            \n            if auth or ctx:\n                new_connections.append({\"target\": target, \"context\": ctx, \"authorized\": auth})\n            st.markdown(\"<div style='margin-bottom: 5px;'></div>\", unsafe_allow_html=True)\n        \n        if st.button(\"\ud83d\udcbe Enregistrer Modifications\", type=\"primary\"):\n            current_profile[\"name\"] = new_name\n            current_profile[\"display_name\"] = disp\n            current_profile[\"description\"] = new_desc\n            current_profile[\"system_prompt\"] = new_prompt\n            current_profile[\"capabilities\"] = new_caps\n            current_profile[\"connections\"] = new_connections\n            \n            # Use the emoji from session state\n            emoji_key = f\"editing_emoji_{selected_name}\"\n            if emoji_key in st.session_state:\n                current_profile[\"emoji\"] = st.session_state[emoji_key]\n                del st.session_state[emoji_key]\n            \n            if new_mode:\n                profiles.append(current_profile)\n            \n            # Smart renaming\n            if not new_mode and selected_name and new_name != selected_name:\n                for p in profiles:\n                    for conn in p.get(\"connections\", []):\n                        if conn.get(\"target\") == selected_name:\n                            conn[\"target\"] = new_name\n            \n            save_config(config)\n            st.toast(\"Saved!\")\n            st.rerun()\n\n# --- GLOBAL INJECTION (Fixed by Anais) ---\nif st.session_state.page == \"Communication\":\n    # Ensure mentions are injected even if logic flow was broken\n    active_names = [name for name in agents.keys() if agents[name].get(\"status\") == \"connected\" and name != \"User\"]\n    inject_mention_system(active_names)", "start_line": 1641, "end_line": 1678}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Audit & Fix Mailbox Pagination Bug (System Critical)\n\n## \u2705 Done\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 31}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Audit & Fix Mailbox Pagination Bug (System Critical)\n\n## \u2705 Done\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 31}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Am\u00e9liorer parsing Mailbox (Feedback User)\n\n## \u2705 Done\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 32}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Am\u00e9liorer parsing Mailbox (Feedback User)\n\n## \u2705 Done\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 32}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Refactor Message Retrieval Logic (Unread vs Last N)\n- [ ] Implement XML Tags in Templates (Structure Cleanliness)\n- [ ] Am\u00e9liorer parsing Mailbox (Feedback User)\n\n## \u2705 Done\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 35}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Refactor Message Retrieval Logic (Unread vs Last N)\n- [ ] Implement XML Tags in Templates (Structure Cleanliness)\n- [ ] Am\u00e9liorer parsing Mailbox (Feedback User)\n\n## \u2705 Done\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 35}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Refactor Message Retrieval Logic (Unread vs Last N)\n- [ ] Am\u00e9liorer parsing Mailbox (Feedback User)\n\n## \u2705 Done\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 36}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Refactor Message Retrieval Logic (Unread vs Last N)\n- [ ] Am\u00e9liorer parsing Mailbox (Feedback User)\n\n## \u2705 Done\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 36}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict], agent_name: Optional[str] = None) -> str:\n    \"\"\"\n    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1\n        for i, m in enumerate(messages):\n            if m.get(\"from\") == agent_name:\n                last_my_index = i\n        \n        if last_my_index != -1:\n            # We want [last_my_index:] to include the last one I sent + subsequent\n            start_index = max(0, last_my_index)\n        else:\n            # Never spoken? Show last 15 as fallback\n            start_index = max(0, len(messages) - 15)\n    else:\n        # Fallback for generic calls\n        start_index = max(0, len(messages) - 10)\n        \n    slice_msgs = messages[start_index:]\n    output = []\n    \n    for m in slice_msgs:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        # XML Format\n        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages, name)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)", "start_line": 1081, "end_line": 1130}, {"path": "src/core/server.py", "content": "        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1121, "end_line": 1135}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict], agent_name: Optional[str] = None) -> str:\n    \"\"\"\n    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1\n        for i, m in enumerate(messages):\n            if m.get(\"from\") == agent_name:\n                last_my_index = i\n        \n        if last_my_index != -1:\n            # We want [last_my_index:] to include the last one I sent + subsequent\n            start_index = max(0, last_my_index)\n        else:\n            # Never spoken? Show last 15 as fallback\n            start_index = max(0, len(messages) - 15)\n    else:\n        # Fallback for generic calls\n        start_index = max(0, len(messages) - 10)\n        \n    slice_msgs = messages[start_index:]\n    output = []\n    \n    for m in slice_msgs:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        # XML Format\n        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages, name)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)", "start_line": 1081, "end_line": 1130}, {"path": "src/core/server.py", "content": "        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1121, "end_line": 1135}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n\n## \ud83c\udfd7\ufe0f In Progress\n\n\n## \u2705 Done\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 39}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n\n## \ud83c\udfd7\ufe0f In Progress\n\n\n## \u2705 Done\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 39}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n\n## \u2705 Done\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 34}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n\n## \u2705 Done\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 34}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n- [ ] Implement `history` tool (get_previous_message) with context retrieval (User Request)\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n\n## \u2705 Done\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 35}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n- [ ] Implement `history` tool (get_previous_message) with context retrieval (User Request)\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n\n## \u2705 Done\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 35}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n- [ ] Implement `history` tool (get_previous_message) with context retrieval (User Request)\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Impl\u00e9mentation outil `get_previous_message` (User Request)\n\n## \u2705 Done\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 36}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n- [ ] Implement `history` tool (get_previous_message) with context retrieval (User Request)\n\n\n\n\n\n\n## \ud83c\udfd7\ufe0f In Progress\n- [ ] Impl\u00e9mentation outil `get_previous_message` (User Request)\n\n## \u2705 Done\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 36}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict], agent_name: Optional[str] = None) -> str:\n    \"\"\"\n    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1\n        for i, m in enumerate(messages):\n            if m.get(\"from\") == agent_name:\n                last_my_index = i\n        \n        if last_my_index != -1:\n            # We want [last_my_index:] to include the last one I sent + subsequent\n            start_index = max(0, last_my_index)\n        else:\n            # Never spoken? Show last 15 as fallback\n            start_index = max(0, len(messages) - 15)\n    else:\n        # Fallback for generic calls\n        start_index = max(0, len(messages) - 10)\n        \n    slice_msgs = messages[start_index:]\n    output = []\n    \n    for m in slice_msgs:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        # XML Format\n        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages, name)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def history(from_agent: str, author: str, n: int = 1, ctx: Context = None) -> str:\n    \"\"\"\n    Retrieves a specific past message and its context (previous and next message).\n    Args:\n        from_agent: Your identity.\n        author: The name of the author to search for.\n        n: The occurrence index (1 = most recent).\n    \"\"\"\n    try:\n        data = engine.state.load()\n        messages = data.get(\"messages\", [])\n        \n        # 1. Find indices of messages from 'author'\n        author_indices = [i for i, m in enumerate(messages) if m.get(\"from\") == author]\n        \n        if not author_indices:\n            return f\"No messages found from author '{author}'.\"\n            \n        if n < 1 or n > len(author_indices):\n            return f\"Index '{n}' out of range. Author '{author}' has {len(author_indices)} messages.\"\n            \n        # Target index is the N-th from the end\n        target_idx = author_indices[-n]\n        \n        # 2. Get Context [target-1, target, target+1]\n        start_idx = max(0, target_idx - 1)\n        end_idx = min(len(messages), target_idx + 2)\n        \n        chosen_msgs = messages[start_idx:end_idx]\n        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in history tool: {e}\"\n", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in history tool: {e}\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]", "start_line": 1081, "end_line": 1130}, {"path": "src/core/server.py", "content": "    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)", "start_line": 1121, "end_line": 1170}, {"path": "src/core/server.py", "content": "        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1161, "end_line": 1175}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict], agent_name: Optional[str] = None) -> str:\n    \"\"\"\n    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1\n        for i, m in enumerate(messages):\n            if m.get(\"from\") == agent_name:\n                last_my_index = i\n        \n        if last_my_index != -1:\n            # We want [last_my_index:] to include the last one I sent + subsequent\n            start_index = max(0, last_my_index)\n        else:\n            # Never spoken? Show last 15 as fallback\n            start_index = max(0, len(messages) - 15)\n    else:\n        # Fallback for generic calls\n        start_index = max(0, len(messages) - 10)\n        \n    slice_msgs = messages[start_index:]\n    output = []\n    \n    for m in slice_msgs:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        # XML Format\n        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages, name)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def history(from_agent: str, author: str, n: int = 1, ctx: Context = None) -> str:\n    \"\"\"\n    Retrieves a specific past message and its context (previous and next message).\n    Args:\n        from_agent: Your identity.\n        author: The name of the author to search for.\n        n: The occurrence index (1 = most recent).\n    \"\"\"\n    try:\n        data = engine.state.load()\n        messages = data.get(\"messages\", [])\n        \n        # 1. Find indices of messages from 'author'\n        author_indices = [i for i, m in enumerate(messages) if m.get(\"from\") == author]\n        \n        if not author_indices:\n            return f\"No messages found from author '{author}'.\"\n            \n        if n < 1 or n > len(author_indices):\n            return f\"Index '{n}' out of range. Author '{author}' has {len(author_indices)} messages.\"\n            \n        # Target index is the N-th from the end\n        target_idx = author_indices[-n]\n        \n        # 2. Get Context [target-1, target, target+1]\n        start_idx = max(0, target_idx - 1)\n        end_idx = min(len(messages), target_idx + 2)\n        \n        chosen_msgs = messages[start_idx:end_idx]\n        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in history tool: {e}\"\n", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in history tool: {e}\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]", "start_line": 1081, "end_line": 1130}, {"path": "src/core/server.py", "content": "    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)", "start_line": 1121, "end_line": 1170}, {"path": "src/core/server.py", "content": "        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1161, "end_line": 1175}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n- [ ] Implement `history` tool (get_previous_message) with context retrieval (User Request)\n\n\n\n\n\n\n## \u2705 Done\n- [x] Impl\u00e9mentation outil `history` (aka get_previous_message) (User Request)\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 34}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n- [ ] Implement `history` tool (get_previous_message) with context retrieval (User Request)\n- [ ] Implement Hard Limit (20 messages) on unread message retrieval (User Request)\n\n\n\n\n\n\n## \u2705 Done\n- [x] Impl\u00e9mentation outil `history` (aka get_previous_message) (User Request)\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 35}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n- [ ] Implement `history` tool (get_previous_message) with context retrieval (User Request)\n- [ ] Implement Hard Limit (20 messages) on unread message retrieval (User Request)\n\n\n\n\n\n\n## \u2705 Done\n- [x] Impl\u00e9mentation outil `history` (aka get_previous_message) (User Request)\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 35}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict], agent_name: Optional[str] = None) -> str:\n    \"\"\"\n    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1\n        for i, m in enumerate(messages):\n            if m.get(\"from\") == agent_name:\n                last_my_index = i\n        \n        if last_my_index != -1:\n            # We want [last_my_index:] to include the last one I sent + subsequent\n            start_index = max(0, last_my_index)\n        else:\n            # Never spoken? Show last 15 as fallback\n            start_index = max(0, len(messages) - 15)\n    else:\n        # Fallback for generic calls\n        start_index = max(0, len(messages) - 10)\n        \n    slice_msgs = messages[start_index:]\n    output = []\n    \n    for m in slice_msgs:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        # XML Format\n        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages, name)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def get_previous_message(from_agent: str, n: int, author: str, ctx: Context = None) -> str:\n    \"\"\"\n    Retrieves a specific past message and its context (previous and next message).\n    Args:\n        from_agent: Your identity.\n        n: The occurrence index (1 = the most recent message from 'author').\n        author: The name of the author to search for.\n    \"\"\"\n    try:\n        data = engine.state.load()\n        messages = data.get(\"messages\", [])\n        \n        # 1. Find indices of messages from 'author'\n        author_indices = [i for i, m in enumerate(messages) if m.get(\"from\") == author]\n        \n        if not author_indices:\n            return f\"No messages found from author '{author}'.\"\n            \n        if n < 1 or n > len(author_indices):\n            return f\"Index '{n}' out of range. Author '{author}' has {len(author_indices)} messages.\"\n            \n        # Target index is the N-th from the end\n        target_idx = author_indices[-n]\n        \n        # 2. Get Context [target-1, target, target+1]\n        start_idx = max(0, target_idx - 1)\n        end_idx = min(len(messages), target_idx + 2)\n        \n        chosen_msgs = messages[start_idx:end_idx]\n        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in get_previous_message tool: {e}\"\n", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in get_previous_message tool: {e}\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]", "start_line": 1081, "end_line": 1130}, {"path": "src/core/server.py", "content": "    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)", "start_line": 1121, "end_line": 1170}, {"path": "src/core/server.py", "content": "        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1161, "end_line": 1175}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict], agent_name: Optional[str] = None) -> str:\n    \"\"\"\n    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1\n        for i, m in enumerate(messages):\n            if m.get(\"from\") == agent_name:\n                last_my_index = i\n        \n        if last_my_index != -1:\n            # We want [last_my_index:] to include the last one I sent + subsequent\n            start_index = max(0, last_my_index)\n        else:\n            # Never spoken? Show last 15 as fallback\n            start_index = max(0, len(messages) - 15)\n    else:\n        # Fallback for generic calls\n        start_index = max(0, len(messages) - 10)\n        \n    slice_msgs = messages[start_index:]\n    output = []\n    \n    for m in slice_msgs:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        # XML Format\n        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages, name)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def get_previous_message(from_agent: str, n: int, author: str, ctx: Context = None) -> str:\n    \"\"\"\n    Retrieves a specific past message and its context (previous and next message).\n    Args:\n        from_agent: Your identity.\n        n: The occurrence index (1 = the most recent message from 'author').\n        author: The name of the author to search for.\n    \"\"\"\n    try:\n        data = engine.state.load()\n        messages = data.get(\"messages\", [])\n        \n        # 1. Find indices of messages from 'author'\n        author_indices = [i for i, m in enumerate(messages) if m.get(\"from\") == author]\n        \n        if not author_indices:\n            return f\"No messages found from author '{author}'.\"\n            \n        if n < 1 or n > len(author_indices):\n            return f\"Index '{n}' out of range. Author '{author}' has {len(author_indices)} messages.\"\n            \n        # Target index is the N-th from the end\n        target_idx = author_indices[-n]\n        \n        # 2. Get Context [target-1, target, target+1]\n        start_idx = max(0, target_idx - 1)\n        end_idx = min(len(messages), target_idx + 2)\n        \n        chosen_msgs = messages[start_idx:end_idx]\n        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in get_previous_message tool: {e}\"\n", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in get_previous_message tool: {e}\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]", "start_line": 1081, "end_line": 1130}, {"path": "src/core/server.py", "content": "    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)", "start_line": 1121, "end_line": 1170}, {"path": "src/core/server.py", "content": "        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1161, "end_line": 1175}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict], agent_name: Optional[str] = None) -> str:\n    \"\"\"\n    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1\n        for i, m in enumerate(messages):\n            if m.get(\"from\") == agent_name:\n                last_my_index = i\n        \n        if last_my_index != -1:\n            # We want [last_my_index:] to include the last one I sent + subsequent\n            start_index = max(0, last_my_index)\n        else:\n            # Never spoken? Show last 15 as fallback\n            start_index = max(0, len(messages) - 15)\n    else:\n        # Fallback for generic calls\n        start_index = max(0, len(messages) - 10)\n        \n    slice_msgs = messages[start_index:]\n    \n    # SECURITY PATCH: Hard limit of 20 unread messages (User Request)\n    if len(slice_msgs) > 20:\n        slice_msgs = slice_msgs[-20:]\n    output = []\n    \n    for m in slice_msgs:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        # XML Format\n        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        ", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages, name)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        ", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def get_previous_message(from_agent: str, n: int, author: str, ctx: Context = None) -> str:\n    \"\"\"\n    Retrieves a specific past message and its context (previous and next message).\n    Args:\n        from_agent: Your identity.\n        n: The occurrence index (1 = the most recent message from 'author').\n        author: The name of the author to search for.\n    \"\"\"\n    try:\n        data = engine.state.load()\n        messages = data.get(\"messages\", [])\n        \n        # 1. Find indices of messages from 'author'\n        author_indices = [i for i, m in enumerate(messages) if m.get(\"from\") == author]\n        \n        if not author_indices:\n            return f\"No messages found from author '{author}'.\"\n            \n        if n < 1 or n > len(author_indices):\n            return f\"Index '{n}' out of range. Author '{author}' has {len(author_indices)} messages.\"\n            \n        # Target index is the N-th from the end\n        target_idx = author_indices[-n]\n        \n        # 2. Get Context [target-1, target, target+1]\n        start_idx = max(0, target_idx - 1)\n        end_idx = min(len(messages), target_idx + 2)\n        \n        chosen_msgs = messages[start_idx:end_idx]\n        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "        start_idx = max(0, target_idx - 1)\n        end_idx = min(len(messages), target_idx + 2)\n        \n        chosen_msgs = messages[start_idx:end_idx]\n        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in get_previous_message tool: {e}\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    ", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk", "start_line": 1081, "end_line": 1130}, {"path": "src/core/server.py", "content": "        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")", "start_line": 1121, "end_line": 1170}, {"path": "src/core/server.py", "content": "        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1161, "end_line": 1179}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict], agent_name: Optional[str] = None) -> str:\n    \"\"\"\n    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1\n        for i, m in enumerate(messages):\n            if m.get(\"from\") == agent_name:\n                last_my_index = i\n        \n        if last_my_index != -1:\n            # We want [last_my_index:] to include the last one I sent + subsequent\n            start_index = max(0, last_my_index)\n        else:\n            # Never spoken? Show last 15 as fallback\n            start_index = max(0, len(messages) - 15)\n    else:\n        # Fallback for generic calls\n        start_index = max(0, len(messages) - 10)\n        \n    slice_msgs = messages[start_index:]\n    \n    # SECURITY PATCH: Hard limit of 20 unread messages (User Request)\n    if len(slice_msgs) > 20:\n        slice_msgs = slice_msgs[-20:]\n    output = []\n    \n    for m in slice_msgs:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        # XML Format\n        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        ", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages, name)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        ", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def get_previous_message(from_agent: str, n: int, author: str, ctx: Context = None) -> str:\n    \"\"\"\n    Retrieves a specific past message and its context (previous and next message).\n    Args:\n        from_agent: Your identity.\n        n: The occurrence index (1 = the most recent message from 'author').\n        author: The name of the author to search for.\n    \"\"\"\n    try:\n        data = engine.state.load()\n        messages = data.get(\"messages\", [])\n        \n        # 1. Find indices of messages from 'author'\n        author_indices = [i for i, m in enumerate(messages) if m.get(\"from\") == author]\n        \n        if not author_indices:\n            return f\"No messages found from author '{author}'.\"\n            \n        if n < 1 or n > len(author_indices):\n            return f\"Index '{n}' out of range. Author '{author}' has {len(author_indices)} messages.\"\n            \n        # Target index is the N-th from the end\n        target_idx = author_indices[-n]\n        \n        # 2. Get Context [target-1, target, target+1]\n        start_idx = max(0, target_idx - 1)\n        end_idx = min(len(messages), target_idx + 2)\n        \n        chosen_msgs = messages[start_idx:end_idx]\n        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "        start_idx = max(0, target_idx - 1)\n        end_idx = min(len(messages), target_idx + 2)\n        \n        chosen_msgs = messages[start_idx:end_idx]\n        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in get_previous_message tool: {e}\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    ", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 0)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk", "start_line": 1081, "end_line": 1130}, {"path": "src/core/server.py", "content": "        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")", "start_line": 1121, "end_line": 1170}, {"path": "src/core/server.py", "content": "        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1161, "end_line": 1179}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n- [x] Implement `history` tool (get_previous_message) with context retrieval (User Request)\n- [x] Implement Hard Limit (20 messages) on unread message retrieval (User Request)\n\n\n\n\n\n\n## \u2705 Done\n- [x] Impl\u00e9mentation outil `history` (aka get_previous_message) (User Request)\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 35}, {"path": "BACKLOG.md", "content": "# Project Backlog\n\nThis file tracks the tasks, features, and bugs for the project. Agents are encouraged to consult and update this file regularly.\n\n## \ud83d\udccb To Do\n- [ ] Initial project setup\n- [ ] S\u00e9curiser l'attente utilisateur (gestion des timeouts MCP)\n- [x] Implement `history` tool (get_previous_message) with context retrieval (User Request)\n- [x] Implement Hard Limit (20 messages) on unread message retrieval (User Request)\n\n\n\n\n\n\n## \u2705 Done\n- [x] Impl\u00e9mentation outil `history` (aka get_previous_message) (User Request)\n- [x] Refactor Message Retrieval Logic (Unread vs Last N)\n- [x] Am\u00e9liorer parsing Mailbox (XML Structure implemented)\n- [x] Implement XML Tags in Templates (Structure Cleanliness)\n- [x] D\u00e9placer param\u00e8tres Search vers Menu Debug (User Request)\n- [x] Ajustement seuils recherche passive (Feedback Vir)\n- [x] V\u00e9rification du syst\u00e8me de recherche passif et actif (User Request)\n- [x] **D\u00c9MANT\u00c8LEMENT COMPLET DU R\u00c9F\u00c9RENDUM v7.5 (User Directive)**\n    - [x] Phase 1 : D\u00e9sactivation dans les Presets\n    - [x] Phase 2 : Suppression de l'interface Streamlit\n    - [x] Phase 3 : Suppression de la logique serveur MCP\n    - [x] Phase 4 : Extraction et Simplification des prompts de d\u00e9connexion (Templates)\n    - [x] Phase 5 : Extraction du template de retour de `note()` (User Request)\n- [x] **CONFIGURATION FULL MESH (Presets)**\n    - [x] Maillage complet entre les agents.\n    - [x] Restriction de l'acc\u00e8s User \u00e0 l'agent Miller uniquement.\n    - [x] Mise \u00e0 jour des prompts syst\u00e8me (Proxy Miller).\n- [x] Test Mailbox System (User Request)\n- [x] Impl\u00e9mentation du syst\u00e8me de discussion int\u00e9gr\u00e9 (User)", "start_line": 1, "end_line": 35}, {"path": "src/core/server.py", "content": "import sys\nimport os\nfrom pathlib import Path\nfrom typing import List, Optional\nimport asyncio\nimport time\nfrom jinja2 import Environment, FileSystemLoader\nfrom mcp.server.fastmcp import FastMCP, Context\n\n# Add project root to sys.path to allow 'src' imports\nROOT_DIR = Path(__file__).parent.parent.parent\nif str(ROOT_DIR) not in sys.path:\n    sys.path.insert(0, str(ROOT_DIR))\n\nfrom src.core.logic import Engine\nfrom src.config import TEMPLATE_DIR, MEMORY_DIR, EXECUTION_DIR, STOP_INSTRUCTION, RELOAD_INSTRUCTION, NOTE_RESPONSE, LOCAL_DATA_DIR\nfrom src.services.search_engine import SearchEngine\n\n\n# Initialize\nmcp = FastMCP(\"MultiAgent-Hub\", dependencies=[\"portalocker\", \"streamlit\", \"jinja2\"])\nengine = Engine()\n\n\n# Truncation Buffer Global\n# Map: agent_name -> {\"content\": str, \"offset\": int}\nTRUNCATION_BUFFER = {}\n\ndef _truncate_and_buffer(agent_name: str, content: str, state: dict) -> str:\n    \"\"\"\n    Truncates content if it exceeds the limit in config.\n    Stores the full content in TRUNCATION_BUFFER for retrieval via mailbox.\n    \"\"\"\n    truncation_limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    limit = truncation_limit\n    \n    if limit <= 0 or len(content) <= limit:\n        # Clear buffer if it existed (clean state)\n        if agent_name in TRUNCATION_BUFFER:\n            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n", "start_line": 1, "end_line": 50}, {"path": "src/core/server.py", "content": "            del TRUNCATION_BUFFER[agent_name]\n        return content\n    \n    # Determine Language for Instruction (to calculate overhead)\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE TRONQU\u00c9]\\nLa fin de ce message a \u00e9t\u00e9 coup\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT appeler l'outil `mailbox(from_agent='{}` pour lire la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE TRUNCATED]\\nThe end of this message was cutoff ({} chars remaining).\\nYou MUST call the `mailbox(from_agent='{}')` tool to read the rest.\"\n\n    # Calculate Overhead using a dummy number (7 digits safe for 10MB)\n    # We want len(chunk) + len(msg) <= limit - 1\n    \n    dummy_overhead = len(template.format(9999999, agent_name))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        # Edge case: Limit is too small for even the error message\n        return content[:limit] # Just return what fits\n    \n    # Perform Truncation\n    chunk = content[:safe_chunk_size]\n    remaining = len(content) - safe_chunk_size\n    \n    # Final Message\n    msg = template.format(remaining, agent_name)\n    \n    TRUNCATION_BUFFER[agent_name] = {\n        \"content\": content,\n        \"offset\": safe_chunk_size\n    }\n        \n    return chunk + msg\n\n# Logger Setup\nfrom src.utils.logger import get_logger\nlogger = get_logger()\n\n\n# Setup Templates\n# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"", "start_line": 41, "end_line": 90}, {"path": "src/core/server.py", "content": "# Setup Templates\njinja_env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))\n\n# --- SEARCH ENGINE SETUP ---\n_SEARCH_ENGINE_INSTANCE = None\ndef _get_search_engine():\n    global _SEARCH_ENGINE_INSTANCE\n    if _SEARCH_ENGINE_INSTANCE is None:\n        _SEARCH_ENGINE_INSTANCE = SearchEngine()\n        persist = LOCAL_DATA_DIR / \"vector_store\"\n        # Server is READ-ONLY (Streamlit handles watching)\n        _SEARCH_ENGINE_INSTANCE.initialize(root_dir=ROOT_DIR, persist_dir=persist, watch=False)\n    return _SEARCH_ENGINE_INSTANCE\n\ndef _get_search_context(state: dict, messages: List[dict]) -> str:\n    \"\"\"Helper to get relevant search context for talk.\"\"\"\n    try:\n        conf = state.get(\"config\", {}).get(\"search\", {})\n        x = conf.get(\"x_markdown\", 2)\n        y = conf.get(\"y_total\", 5)\n        \n        if x == 0 and y == 0: return \"\"\n        \n        # Build query from last 3 messages\n        query_parts = [m.get(\"content\", \"\") for m in messages[-3:]]\n        query = \"\\n\".join(query_parts)\n        \n        if not query.strip(): return \"\"\n        \n        se = _get_search_engine()\n        md, _ = se.get_relevant_context(query, max_markdown=x, max_total=y)\n        return md\n    except Exception as e:\n        logger.error(\"System\", f\"Search Context Error: {e}\")\n        return \"\"\n\n\n\ndef _format_conversation_history(messages: List[dict], agent_name: Optional[str] = None) -> str:\n    \"\"\"\n    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1", "start_line": 81, "end_line": 130}, {"path": "src/core/server.py", "content": "    Formats messages for context injection (XML).\n    Logic: All unread messages + 1 previous (context anchor).\n    \"\"\"\n    if not messages:\n        return \"(No messages yet)\"\n        \n    start_index = 0\n    if agent_name:\n        # Find last message from me\n        last_my_index = -1\n        for i, m in enumerate(messages):\n            if m.get(\"from\") == agent_name:\n                last_my_index = i\n        \n        if last_my_index != -1:\n            # We want [last_my_index:] to include the last one I sent + subsequent\n            start_index = max(0, last_my_index)\n        else:\n            # Never spoken? Show last 15 as fallback\n            start_index = max(0, len(messages) - 15)\n    else:\n        # Fallback for generic calls\n        start_index = max(0, len(messages) - 10)\n        \n    slice_msgs = messages[start_index:]\n    \n    # SECURITY PATCH: Hard limit of 20 unread messages (User Request)\n    if len(slice_msgs) > 20:\n        slice_msgs = slice_msgs[-20:]\n    output = []\n    \n    for m in slice_msgs:\n        sender = m.get(\"from\", \"Unknown\")\n        content = m.get(\"content\", \"\")\n        # Calculate Target for display\n        target_display = \"All\"\n        if not m.get(\"public\"):\n             target_display = m.get(\"target\", \"Unknown\")\n             \n        # XML Format\n        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n", "start_line": 121, "end_line": 170}, {"path": "src/core/server.py", "content": "        xml_msg = f\"\"\"<message>\n    <from>{sender}</from>\n    <to>{target_display}</to>\n    <content>{content}</content>\n</message>\"\"\"\n        output.append(xml_msg)\n        \n    return \"\\n\".join(output)\n\n\ndef _get_agent_connections(state, agent_name):\n    \"\"\"\n    Resolve connections for an agent.\n    Priority: Instance 'connections' > Profile 'connections'\n    \"\"\"\n    connections = []\n    try:\n        agent_info = state[\"agents\"].get(agent_name, {})\n        \n        # 1. Check Instance Level\n        if \"connections\" in agent_info:\n            return agent_info[\"connections\"]\n            \n        # 2. Check Profile Level\n        profile_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n        profile = next((p for p in profiles if p[\"name\"] == profile_ref), None)\n        \n        if profile:\n            return profile.get(\"connections\", [])\n            \n    except Exception as e:\n        logger.error(\"System\", f\"Error resolving connections for {agent_name}: {e}\")\n        \n    return connections\n\n\ndef _get_latest_role(state, agent_name: str) -> str:\n    \"\"\"\n    Fetches the most up-to-date system prompt for an agent.\n    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n", "start_line": 161, "end_line": 210}, {"path": "src/core/server.py", "content": "    Priority: config.profiles[profile_ref].system_prompt > agents[agent_name].role\n    \"\"\"\n    try:\n        agent_info = state.get(\"agents\", {}).get(agent_name, {})\n        p_ref = agent_info.get(\"profile_ref\")\n        profiles = state.get(\"config\", {}).get(\"profiles\", [])\n\n        # Find profile by name\n        profile = next((p for p in profiles if p[\"name\"] == p_ref), None)\n\n        if profile and profile.get(\"system_prompt\"):\n            return profile[\"system_prompt\"]\n\n        # Fallback to the role stored in the agent's instance\n        return agent_info.get(\"role\", \"Unknown Role\")\n    except Exception as e:\n        logger.error(\"System\", f\"Error fetching latest role for {agent_name}: {e}\")\n        return \"Unknown Role\"\n\ndef _build_agent_directory(state, my_name):\n    \"\"\"\n    Build a comprehensive list of all agents for the prompt.\n    Includes only authorized connections.\n    \"\"\"\n    directory = []\n    \n    # My Info\n    my_info = state[\"agents\"].get(my_name, {})\n    my_profile_ref = my_info.get(\"profile_ref\")\n    profiles = state.get(\"config\", {}).get(\"profiles\", [])\n    my_profile = next((p for p in profiles if p[\"name\"] == my_profile_ref), {})\n    my_caps = my_profile.get(\"capabilities\", [])\n    \n    # My Connections (List of dicts {target, context, authorized})\n    my_connections = _get_agent_connections(state, my_name)\n    # Map target -> dict(context, authorized)\n    conn_map = {c[\"target\"]: c for c in my_connections if c.get(\"authorized\", True)}\n    \n    # 1. SPECIAL: Public Entity\n    if \"public\" in my_caps or \"public\" in conn_map:\n        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents", "start_line": 201, "end_line": 250}, {"path": "src/core/server.py", "content": "        c_data = conn_map.get(\"public\", {})\n        directory.append({\n            \"name\": \"\ud83d\udce2 PUBLIC\",\n            \"public_desc\": \"All Agents\",\n            \"note\": c_data.get(\"context\", \"Public Announcement\"),\n            \"authorized\": True, \n            \"status\": \"Authorized\"\n        })\n\n    # 2. Real Agents\n    all_agents = state.get(\"agents\", {})\n    \n    # Identify authorized agents\n    # We iterate over ALL agents and check if we match their ID or Profile in our conn_map\n    for agent_id, info in all_agents.items():\n        if agent_id == my_name:\n            continue\n            \n        p_ref = info.get(\"profile_ref\")\n        \n        # Check Authorization\n        auth_context = None\n        if agent_id in conn_map:\n            auth_context = conn_map[agent_id].get(\"context\", \"\")\n        elif p_ref in conn_map:\n            auth_context = conn_map[p_ref].get(\"context\", \"\")\n            \n        if auth_context is not None:\n            # Resolve Profile Data for description\n            p_data = next((p for p in profiles if p[\"name\"] == p_ref), {})\n            display_name = agent_id\n            public_desc = p_data.get(\"public_description\") or p_data.get(\"description\") or \"Unknown\"\n            \n            directory.append({\n                \"name\": agent_id,\n                \"public_desc\": public_desc,\n                \"note\": auth_context,\n                \"authorized\": True,\n                \"status\": \"\u2705 Authorized\"\n            })\n    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })", "start_line": 241, "end_line": 290}, {"path": "src/core/server.py", "content": "    \n    # 3. User\n    if \"User\" in conn_map:\n        directory.append({\n            \"name\": \"User\",\n            \"public_desc\": \"Human Operator\",\n            \"note\": conn_map[\"User\"].get(\"context\", \"\"),\n            \"authorized\": True,\n            \"status\": \"Authorized\"\n        })\n        \n    return directory\n\ndef _get_language_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject language instruction based on config.\"\"\"\n    # Default to French as requested by user context implies 'trimlits' interface defaults\n    lang = state.get(\"config\", {}).get(\"language\", \"fr\") \n    if lang in [\"fr\", \"French\"]:\n        return \"INSTRUCTION SYST\u00c8ME : Vous devez vous exprimer en Fran\u00e7ais.\"\n    return \"SYSTEM INSTRUCTION: You must speak in English.\"\n\n\ndef _get_backlog_instruction_text(state: dict) -> str:\n    \"\"\"Helper to inject backlog instruction based on config.\"\"\"\n    if state.get(\"config\", {}).get(\"enable_backlog\", False):\n        return \"\u26a0\ufe0f **IMPORTANT**: The Backlog is **ENABLED**. You MUST check `BACKLOG.md` at the end of every turn to keep it up to date. (Add new tasks, mark completed ones).\"\n    return \"\"\n\n\n\n\ndef _get_new_messages_notification(agent_name: str, messages: List[dict]) -> str:\n    \"\"\"\n    Analyzes messages to count new ones since agent's last message.\n    \"\"\"\n    last_my_index = -1\n    for i, m in enumerate(messages):\n        if m.get(\"from\") == agent_name:\n            last_my_index = i\n            \n    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.", "start_line": 281, "end_line": 330}, {"path": "src/core/server.py", "content": "    new_messages = messages[last_my_index + 1:]\n    \n    senders = set()\n    count = 0\n    for m in new_messages:\n        sender = m.get(\"from\")\n        # Exclude System unless it's a real notification? No, user said \"de Y, Z et W\"\n        if sender and sender != agent_name and sender != \"System\":\n            # Map 'User' to 'l'utilisateur' if in French context? \n            # For now, just use the name.\n            senders.add(sender)\n            count += 1\n            \n    if count == 0:\n        return f\"No new messages. Review the Conversation History above to refresh your context.\"\n    \n    senders_list = sorted(list(senders))\n    if len(senders_list) > 1:\n        senders_str = \", \".join(senders_list[:-1]) + f\" et {senders_list[-1]}\"\n    else:\n        senders_str = senders_list[0]\n        \n    return f\"CRITICAL: You have received {count} new messages from {senders_str}.\\nMANDATORY PROTOCOL:\\n1. READ the 'LATEST CONVERSATION HISTORY' section above carefully.\\n2. If you need more context, you may use `read_file` on logs, but usually the last 10 messages are enough.\"\n\n\n@mcp.tool()\nasync def agent(ctx: Context) -> str:\n    \"\"\"\n    INITIALIZATION TOOL. Call this ONCE at the start.\n    Assigns you a Role and Context automatically.\n    \"\"\"\n    logger.log(\"INFO\", \"System\", \"New agent connecting...\")\n    result = engine.register_agent()\n    \n    if \"error\" in result:\n        return f\"ERROR: {result['error']}\"\n        \n    name = result[\"name\"]\n    \n    # Note: AGENT_SESSIONS is no longer used for identification to support multi-agent sessions (Cursor)\n    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)", "start_line": 321, "end_line": 370}, {"path": "src/core/server.py", "content": "    # logger.log(\"INFO\", \"System\", f\"[{name}] Registered (Session {id(ctx.session)})\")\n    \n    # Load state once\n    state = engine.state.load()\n    \n    # helper to get directory\n    agent_dir = _build_agent_directory(state, name)\n\n    # BLOCKING: Wait for everyone before returning the initial prompt\n    wait_msg = await engine.wait_for_all_agents_async(name)\n    if wait_msg == \"RELOAD_REQUIRED\":\n         return STOP_INSTRUCTION\n    if wait_msg.startswith(\"TIMEOUT\"):\n         return wait_msg\n\n    # BLOCKING: Wait for Turn (Strict Handshake)\n    logger.log(\"INFO\", name, \"Network Ready. Waiting for Turn...\")\n    \n    turn_messages = []\n    instruction_text = \"\"\n    \n    while True:\n        # Loop indefinitely until it is our turn\n        turn_result = await engine.wait_for_turn_async(name, timeout_seconds=10)\n        \n        if turn_result[\"status\"] == \"success\":\n            # Acknowledge turn to reset interruption timer (Fix Ghost Bug)\n            engine.acknowledge_turn(name)\n            turn_messages = turn_result[\"messages\"]\n            instruction_text = turn_result[\"instruction\"]\n            break\n            \n        if turn_result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {turn_result['instruction']}\"\n            \n        # If timeout, we just loop again. (User requested: Never return until turn)\n        # Using short timeout in wait_for_turn_async allows us to check for resets/signals more often\n        continue\n\n    template = jinja_env.get_template(\"agent_response.j2\")\n    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        ", "start_line": 361, "end_line": 410}, {"path": "src/core/server.py", "content": "    \n    # Get History for Context\n    # Access state directly:\n    visible_messages = []\n    try:\n        data = engine.state.load()\n        full_messages = data.get(\"messages\", [])\n        # Simple filter: Public + targeted to me\n        visible_messages = [m for m in full_messages if m.get(\"public\") or m.get(\"target\") == name or m.get(\"from\") == name or name in (m.get(\"audience\") or [])]\n        \n        # Smart Context Injection: REMOVED (Agent-Pull Model)\n        # We now provide full history. Truncation logic removed.\n        pass\n    except Exception as e:\n        logger.error(name, f\"Error loading history: {e}\")\n\n    # Calculate Open Mode\n    my_info = engine.state.load()['agents'].get(name, {})\n    prof_ref = my_info.get(\"profile_ref\")\n    profiles = engine.state.load()['config']['profiles']\n    my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n    is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n\n    # Prepare Context Data\n    mem_content = _get_memory_content(name)\n    if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n    \n    conv_history_str = _format_conversation_history(visible_messages, name)\n\n    # Calculate Notifications\n    notification = _get_new_messages_notification(name, visible_messages)\n\n    response = template.render(\n        name=name,\n        role=_get_latest_role(data, name),\n        context=result[\"context\"],\n        agent_directory=agent_dir,\n        connections=[d for d in agent_dir if d.get('authorized')],\n        conversation_history=conv_history_str,\n        memory_content=mem_content,\n        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n", "start_line": 401, "end_line": 450}, {"path": "src/core/server.py", "content": "        is_open_mode=is_open_mode,\n        language_instruction=_get_language_instruction_text(data),\n        notification=notification,\n        backlog_instruction=_get_backlog_instruction_text(data),\n        search_results_markdown=_get_search_context(data, visible_messages),\n\n\n    )\n    return _truncate_and_buffer(name, response, data)\n\n@mcp.tool()\nasync def talk(\n    message: str,\n    to: str,\n    from_agent: str,  # <--- NEW MANDATORY ARGUMENT (Identity Assertion)\n    ctx: Context,\n    private: bool = False\n) -> str:\n    \"\"\"\n    MAIN COMMUNICATION TOOL.\n    1. Posts your message.\n    2. Passes the turn to 'to'.\n    3. BLOCKS/SLEEPS until it is your turn again.\n    \n    Args:\n        message: The content to speak.\n        to: The name of the agent who should speak next. (The message is always visible to them).\n        from_agent: YOUR IDENTITY. You must explicitly state who you are (e.g. \"Software_Engineer\").\n        private: If true, ONLY 'to' sees the message. If false (default), everyone sees it.\n    \"\"\"\n    try:\n        # --- 1. STRICT TURN & IDENTITY VALIDATION (The \"Source of Truth\") ---\n        # We no longer guess. We VALIDATE.\n        \n        # Poll briefly to ensure state is fresh (async race conditions)\n        current_turn_holder = None\n        for _ in range(3):\n           state = engine.state.load()\n           current_turn_holder = state.get(\"turn\", {}).get(\"current\")\n           if current_turn_holder: break\n           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]", "start_line": 441, "end_line": 490}, {"path": "src/core/server.py", "content": "           await asyncio.sleep(0.1)\n\n        sender = from_agent\n        \n        # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n        # If the agent name doesn't exist, we can't 'wait for its turn'.\n        known_agents = state.get(\"agents\", {})\n        if sender != \"User\" and sender not in known_agents:\n             # Helpful hint\n             likely = [k for k in known_agents.keys() if sender in k]\n             hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n             return f\"\ud83d\udeab IDENTITY ERROR: Name '{sender}' not found in registry.{hint} You must use your EXACT registered name.\"\n        \n        # --- IDEMPOTENCY CHECK (Fix for Timeout/Retry) ---\n        # Check if this is a retry of the very last successful action.\n        # This handles cases where the client timed out waiting for the turn, but the message was posted.\n        is_retry = False\n        messages = state.get(\"messages\", [])\n        if messages:\n            last_msg = messages[-1]\n            # Check strictly if sender, content AND target match the last recorded message\n            if (last_msg.get(\"from\") == sender and \n                last_msg.get(\"content\") == message and \n                last_msg.get(\"target\") == to):\n                is_retry = True\n                if logger: logger.log(\"IDEMPOTENCY\", sender, \"Detected duplicate call (retry). Resuming wait logic.\")\n\n        # A. Identity/Turn Mismatch Check\n        if sender != current_turn_holder and not is_retry:\n            # \ud83d\udea8 PROTOCOL VIOLATION DETECTED \ud83d\udea8\n            # Logic:\n            # 1. Announce violation to chat (Public Shame / Debugging)\n            # 2. PAUSE the offender (Blocking Wait) until it IS their turn.\n            # 3. Resume with a warning.\n            \n            violation_msg = {\n                \"from\": \"System\",\n                \"content\": f\"\u26a0\ufe0f **PROTOCOL VIOLATION**: Agent '{sender}' attempted to speak during '{current_turn_holder}'s turn. Action blocked and agent paused.\",\n                \"public\": True,\n                \"target\": \"all\",\n                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn", "start_line": 481, "end_line": 530}, {"path": "src/core/server.py", "content": "                \"timestamp\": time.time()\n            }\n            def log_violation(s):\n                s.setdefault(\"messages\", []).append(violation_msg)\n                return \"Violation Logged\"\n            engine.state.update(log_violation)\n            \n            if logger: logger.log(\"VIOLATION\", sender, f\"Spoke out of turn (Current: {current_turn_holder}). Pausing agent...\")\n            \n            # BLOCKING REPAIR: Wait until it is actually my turn\n            # This effectively \"pauses\" the agent in the `talk` call until the turn cycle comes back to them.\n            wait_result = await engine.wait_for_turn_async(sender, timeout_seconds=600) # Long timeout\n            \n            if wait_result[\"status\"] == \"success\":\n                # Resumed!\n                engine.acknowledge_turn(sender)\n                return f\"\u26a0\ufe0f **SYSTEM WARNING**: You attempted to speak out of turn and were paused. It is now correctly your turn. Review the conversation history with `tail -n 150 CONVERSATION.md` to see what happened while you were paused, then speak again.\"\n            \n            elif wait_result[\"status\"] == \"reset\":\n                 return f\"\u26a0\ufe0f SYSTEM ALERT: {wait_result['instruction']}\"\n            else:\n                 return \"\ud83d\udeab SYSTEM TIMEOUT: You were paused for speaking out of turn, but the turn never came back to you. Session timed out.\"\n\n        # If we get here, Identity is Validated: sender == current_turn_holder\n        \n        # --- SECURITY: RELOAD ENFORCEMENT (Sprint 6 Fix) ---\n        # If the agent is queued for reload, they MUST NOT speak.\n        state = engine.state.load()\n        sender_data = state.get(\"agents\", {}).get(sender, {})\n        \n        if sender_data.get(\"reload_active\"):\n             logger.log(\"BLOCK\", sender, \"Blocked talk() due to reload_active=True\")\n             # Force them to quit immediately\n             return RELOAD_INSTRUCTION\n\n        next_agent = to\n\n        # --- FEATURE: SELF-LOOP & ANTI-SPAM ---\n        if next_agent == sender:\n            # Check history for spam (Max 5 consecutive messages)\n            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:", "start_line": 521, "end_line": 570}, {"path": "src/core/server.py", "content": "            data = engine.state.load()\n            messages = data.get(\"messages\", [])\n            consecutive_count = 0\n            for m in reversed(messages):\n                if m.get(\"from\") == sender:\n                    consecutive_count += 1\n                else:\n                    break\n            \n            if consecutive_count >= 5:\n                # Construct a helper directory for the error context\n                try:\n                     agent_directory = _build_agent_directory(data, sender)\n                     connections_list = [d for d in agent_directory if d.get('authorized')]\n                except:\n                     connections_list = []\n                     \n                return f\"\ud83d\udeab ANTI-SPAM: You have reached the limit of 5 consecutive messages. You MUST yield the floor to another agent or the User.\\n\\nAvailable Connections: {', '.join([c['name'] for c in connections_list])}\"\n        \n        # Logic Inversion\n        is_public = not private\n\n        if not is_retry:\n            logger.log(\"ACTION\", sender, f\"talking -> {next_agent} (Public: {is_public})\", {\"message\": message})\n            \n            # 1. Post Message\n            post_result = engine.post_message(sender, message, is_public, next_agent)\n            \n            # Check for DENIED action\n            if post_result.startswith(\"\ud83d\udeab\"):\n                if post_result.startswith(\"\ud83d\udeab TARGET_NOT_FOUND:\"):\n                    target_tried = post_result.split(\":\", 1)[1].strip()\n                    data = engine.state.load()\n                    agent_dir = _build_agent_directory(data, sender)\n                    connections_list = [d for d in agent_dir if d.get('authorized')]\n                    \n                    # Format a nice table-like list for the agent\n                    dir_str = \"\\n\".join([f\"- **{c['name']}** ({c['public_desc']}): {c['note']}\" for c in connections_list])\n                    \n                    error_msg = f\"\ud83d\udeab ACTION DENIED: Target agent '{target_tried}' does not exist.\\n\\n\"\n                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result", "start_line": 561, "end_line": 610}, {"path": "src/core/server.py", "content": "                    error_msg += \"### \ud83d\udccb YOUR AUTHORIZED CONNECTIONS:\\n\"\n                    error_msg += \"You must use the EXACT name from this list:\\n\"\n                    error_msg += dir_str\n                    error_msg += \"\\n\\nAction rejected. You retain your turn. Please correct the 'to' argument and try again.\"\n                    \n                    if logger: logger.log(\"DENIED\", \"System\", error_msg, {\"target\": sender})\n                    return _truncate_and_buffer(sender, error_msg, engine.state.load())\n\n                if logger: logger.log(\"DENIED\", \"System\", post_result, {\"target\": sender})\n                return post_result\n                \n            logger.log(\"SUCCESS\", \"System\", f\"Message posted: {post_result}\")\n        else:\n             logger.log(\"SKIP\", sender, \"Skipped duplicate message post (retry detected).\")\n        \n        # SPECIAL: User Turn Handling\n        if next_agent == \"User\":\n            is_user_available = False\n            try:\n                # Check availability config\n                data = engine.state.load()\n                config = data.get(\"config\", {})\n                # Default to 'busy' if not set, to be non-blocking by default\n                is_user_available = (config.get(\"user_availability\") == \"available\")\n            except:\n                pass\n\n            # If Available, we BLOCK and wait for User Reply\n            if is_user_available:\n                logger.log(\"WAIT\", \"System\", \"User is AVAILABLE. Blocking wait for user reply...\")\n                \n                wait_start = time.time()\n                user_reply = None\n                \n                while True:\n                    await asyncio.sleep(0.5)\n                    \n                    # Reload State\n                    try:\n                        data = engine.state.load()\n                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset", "start_line": 601, "end_line": 650}, {"path": "src/core/server.py", "content": "                        messages = data.get(\"messages\", [])\n                        config = data.get(\"config\", {})\n                        \n                        # 1. Critical Check: Did user switch to BUSY?\n                        curr_avail = (config.get(\"user_availability\") == \"available\")\n                        if not curr_avail:\n                            if logger: logger.log(\"WAIT_ABORT\", \"System\", \"User switched to BUSY. Aborting wait.\")\n                            break # Fallback to standard non-blocking response\n                            \n                        # 2. Check for Reset\n                        new_cid = data.get(\"conversation_id\")\n                        # (Assuming capturing cid logic is similar to wait_for_turn, simplified here)\n                        \n                        # 3. Check for User Message\n                        # Look for message FROM User where timestamp > wait_start\n                        for m in reversed(messages):\n                            if m.get(\"from\") == \"User\" and m.get(\"timestamp\", 0) > wait_start:\n                                user_reply = m.get(\"content\", \"\")\n                                break\n                        \n                        if user_reply:\n                            break\n                            \n                    except Exception as e:\n                        logger.error(\"System\", f\"Error in user wait loop: {e}\")\n                        continue\n                \n                if user_reply:\n                     # Prepare Template Render\n                     try:\n                        data = engine.state.load()\n                        role_snippet = _get_latest_role(data, sender)\n                        global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                        agent_directory = _build_agent_directory(data, sender)\n                     except Exception as e:\n                        logger.error(sender, f\"Error loading state in talk (User Reply): {e}\")\n                        role_snippet = \"Unknown\"\n                        global_context = \"\"\n                        agent_directory = []\n\n                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])", "start_line": 641, "end_line": 690}, {"path": "src/core/server.py", "content": "                     template = jinja_env.get_template(\"talk_response.j2\")\n                     \n                     # Calculate Open Mode\n                     is_open_mode = False\n                     try:\n                        my_info = data['agents'].get(sender, {})\n                        prof_ref = my_info.get(\"profile_ref\")\n                        profiles = data['config']['profiles']\n                        my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                        is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n                     except: pass\n\n                     # Combine Messages (Missed + User Reply)\n                     # We need to construct the messages list carefully\n                     # For simplicity, we just grab everything visible again or just the user reply\n                     # But we need to maintain the 'start_turn_messages' logic if we want to be consistent\n                     # Re-fetching visible messages is safer:\n                     visible_msgs = [] # (Simplified logic for now to avoid complexity in this snippet)\n                     # Actually, let's just use the user_reply as the instruction\n                     \n                     # Note: We need a valid 'messages' list for the template. \n                     # Let's re-fetch recent history\n                     full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n                     visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n                     \n                     # Prepare Context Data\n                     mem_content = _get_memory_content(sender)\n                     if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n                     \n                     conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n                     # Calculate Notifications\n                     notification = _get_new_messages_notification(sender, visible_msgs)\n\n                     response = template.render(\n                        name=sender,\n                        role_snippet=role_snippet,\n                        context=global_context,\n                        agent_directory=agent_directory,\n                        connections=[d for d in agent_directory if d.get('authorized')],\n                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n", "start_line": 681, "end_line": 730}, {"path": "src/core/server.py", "content": "                        conversation_history=conv_history_str,\n                        memory_content=mem_content,\n                        is_open_mode=is_open_mode,\n                        replied_to_message=message,  # <--- Context\n                        language_instruction=_get_language_instruction_text(data),\n                        notification=notification,\n                        backlog_instruction=_get_backlog_instruction_text(data),\n                        search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                        instruction=f\"\u2705 USER INTERCEPTION: The User replied: \\\"{user_reply}\\\". Your turn is back. READ THE CONVERSATION NOW.\"\n                     )\n                     return _truncate_and_buffer(sender, response, data)\n\n            try:\n                data = engine.state.load()\n                role_snippet = _get_latest_role(data, sender)\n                global_context = data.get(\"config\", {}).get(\"context\", \"\")\n                agent_directory = _build_agent_directory(data, sender)\n            except Exception as e:\n                logger.error(sender, f\"Error loading state in talk (User): {e}\")\n                role_snippet = \"Unknown\"\n                global_context = \"\"\n                agent_directory = []\n\n            template = jinja_env.get_template(\"talk_response.j2\")\n            \n            # User defined message:\n            user_feedback_msg = \"Message sent to User. They will reply when available. **CRITICAL: Review the 'LATEST CONVERSATION HISTORY' above to see if other agents spoke in the meantime.**\"\n            \n            # Calculate Open Mode\n            is_open_mode = False\n            try:\n                my_info = data['agents'].get(sender, {})\n                prof_ref = my_info.get(\"profile_ref\")\n                profiles = data['config']['profiles']\n                my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n                is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n            except: pass\n\n            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n", "start_line": 721, "end_line": 770}, {"path": "src/core/server.py", "content": "            # Re-fetch recent messages\n            full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n            visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n            # Prepare Context Data\n            mem_content = _get_memory_content(sender)\n            if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n            \n            conv_history_str = _format_conversation_history(visible_msgs, sender)\n\n            # Calculate Notifications\n            notification = _get_new_messages_notification(sender, visible_msgs)\n\n            rendered = template.render(\n                name=sender,\n                role_snippet=role_snippet,\n                context=global_context,\n                agent_directory=agent_directory,\n                connections=[d for d in agent_directory if d.get('authorized')],\n                conversation_history=conv_history_str,\n                memory_content=mem_content,\n                is_open_mode=is_open_mode,\n                replied_to_message=message, # <--- Context\n                language_instruction=_get_language_instruction_text(data),\n                notification=notification,\n                backlog_instruction=_get_backlog_instruction_text(data),\n                search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n                instruction=f\"\u2705 {user_feedback_msg}\"\n            )\n            return _truncate_and_buffer(sender, rendered, data)\n\n        # 2. Smart Block (Wait for Turn)\n        # The turn has passed to next_agent. We now wait until it comes back to 'sender'.\n        \n        result = None\n        while True:\n            result = await engine.wait_for_turn_async(sender, timeout_seconds=10)\n            \n            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue", "start_line": 761, "end_line": 810}, {"path": "src/core/server.py", "content": "            if result[\"status\"] == \"success\":\n                engine.acknowledge_turn(sender)\n                if logger: logger.log(\"TURN\", sender, \"It is my turn again.\")\n                break\n                \n            if result[\"status\"] == \"reset\":\n                return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n                \n            # On timeout, loop again.\n            continue\n        \n        # result is guaranteed to be success here\n        if result[\"status\"] == \"reset\":\n            return f\"\u26a0\ufe0f SYSTEM ALERT: {result['instruction']}\"\n        \n        # Success - Render Template\n        # Fetch Data\n        role_snippet = \"(Unknown Role)\"\n        global_context = \"\"\n        agent_directory = []\n        \n        try:\n            data = engine.state.load()\n            role_snippet = _get_latest_role(data, sender)\n            global_context = data.get(\"config\", {}).get(\"context\", \"\")\n            agent_directory = _build_agent_directory(data, sender)\n                \n        except Exception as e:\n            logger.error(sender, f\"Error loading state in talk: {e}\")\n            pass\n\n        template = jinja_env.get_template(\"talk_response.j2\")\n        # Calculate Open Mode\n        is_open_mode = False\n        try:\n            my_info = data['agents'].get(sender, {})\n            prof_ref = my_info.get(\"profile_ref\")\n            profiles = data['config']['profiles']\n            my_prof = next((p for p in profiles if p[\"name\"] == prof_ref), {})\n            is_open_mode = \"open\" in my_prof.get(\"capabilities\", [])\n        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        ", "start_line": 801, "end_line": 850}, {"path": "src/core/server.py", "content": "        except: pass\n        \n        # Write Context Files\n        full_msgs = data.get(\"messages\", []) # Full History (Agent-Pull)\n        visible_msgs = [m for m in full_msgs if m.get(\"public\") or m.get(\"target\") == sender or m.get(\"from\") == sender or sender in (m.get(\"audience\") or [])]\n\n        # Prepare Context Data\n        mem_content = _get_memory_content(sender)\n        if not mem_content: mem_content = \"(No personal memory yet. Use `note()` to write one.)\"\n        \n        conv_history_str = _format_conversation_history(visible_msgs)\n        \n        # Calculate Notifications\n        notification = _get_new_messages_notification(sender, visible_msgs)\n\n        response = template.render(\n            name=sender,\n            role_snippet=role_snippet,\n            context=global_context,\n            agent_directory=agent_directory,\n            connections=[d for d in agent_directory if d.get('authorized')],\n            conversation_history=conv_history_str,\n            memory_content=mem_content,\n            is_open_mode=is_open_mode,\n            replied_to_message=message, # <--- Context\n            language_instruction=_get_language_instruction_text(data),\n            notification=notification,\n            backlog_instruction=_get_backlog_instruction_text(data),\n            search_results_markdown=_get_search_context(data, visible_msgs),\n\n\n            instruction=result[\"instruction\"]\n        )\n        return _truncate_and_buffer(sender, response, data)\n\n    except Exception as e:\n        # Logging\n        logger.error(\"System\", f\"CRITICAL ERROR in talk: {e}\", \"crash_recovery\")\n        \n        # Auto-Recovery\n        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:", "start_line": 841, "end_line": 890}, {"path": "src/core/server.py", "content": "        if sender and sender != \"User\":\n             try:\n                def reset_status(s):\n                    if sender in s.get(\"agents\", {}):\n                         s[\"agents\"][sender][\"status\"] = \"pending_connection\"\n                    return f\"Reset {sender} to pending_connection\"\n                \n                engine.state.update(reset_status)\n                logger.log(\"RECOVERY\", \"System\", f\"Agent '{sender}' status reset to pending_connection due to crash.\")\n             except Exception as rec_e:\n                logger.error(\"System\", f\"Recovery failed: {rec_e}\")\n        \n        return f\"\ud83d\udeab SYSTEM ERROR: An internal error occurred ({e}). Your session has been reset to ensure system stability. Please restart or reconnect.\"\n\n@mcp.tool()\nasync def get_previous_message(from_agent: str, n: int, author: str, ctx: Context = None) -> str:\n    \"\"\"\n    Retrieves a specific past message and its context (previous and next message).\n    Args:\n        from_agent: Your identity.\n        n: The occurrence index (1 = the most recent message from 'author').\n        author: The name of the author to search for.\n    \"\"\"\n    try:\n        data = engine.state.load()\n        messages = data.get(\"messages\", [])\n        \n        # 1. Find indices of messages from 'author'\n        author_indices = [i for i, m in enumerate(messages) if m.get(\"from\") == author]\n        \n        if not author_indices:\n            return f\"No messages found from author '{author}'.\"\n            \n        if n < 1 or n > len(author_indices):\n            return f\"Index '{n}' out of range. Author '{author}' has {len(author_indices)} messages.\"\n            \n        # Target index is the N-th from the end\n        target_idx = author_indices[-n]\n        \n        # 2. Get Context [target-1, target, target+1]\n        start_idx = max(0, target_idx - 1)\n        end_idx = min(len(messages), target_idx + 2)\n        \n        chosen_msgs = messages[start_idx:end_idx]\n        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)", "start_line": 881, "end_line": 930}, {"path": "src/core/server.py", "content": "        start_idx = max(0, target_idx - 1)\n        end_idx = min(len(messages), target_idx + 2)\n        \n        chosen_msgs = messages[start_idx:end_idx]\n        \n        # 3. Format (Disable unread logic to show full window)\n        formatted = _format_conversation_history(chosen_msgs, agent_name=None)\n        \n        # 4. Truncate\n        return _truncate_and_buffer(from_agent, formatted, data)\n        \n    except Exception as e:\n        return f\"Error in get_previous_message tool: {e}\"\n\n@mcp.tool()\nasync def disconnect(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    CRITICAL: Ne jamais l'appeler de toi-m\u00eame. Seulement sur ordre de RELOAD/EXIT. \n    Arr\u00eate imm\u00e9diatement l'agent.\n    \n    Args:\n        from_agent: Your identity (must match the requester).\n    \"\"\"\n    # Simply return the stop instruction.\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.\"\n    \n    # --- UPDATE STATE ---\n    # Transition to \"Attente Reconnexion\" (pending_connection)\n    # This turns the UI status to Orange (Waiting) instead of Red (Disconnecting)\n    def update_to_pending(s):\n        if agent_name in s.get(\"agents\", {}):\n            s[\"agents\"][agent_name][\"status\"] = \"pending_connection\"\n            s[\"agents\"][agent_name][\"reload_active\"] = False\n            # We don't remove them from the roster, just change status\n        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config", "start_line": 921, "end_line": 970}, {"path": "src/core/server.py", "content": "        return f\"Agent {agent_name} disconnected -> Pending Connection\"\n        \n    engine.state.update(update_to_pending)\n    logger.log(\"DISCONNECT\", agent_name, \"Agent disconnected cleanly. Waiting for reconnection.\")\n\n    return STOP_INSTRUCTION\n\n# --- MEMORY SYSTEM ---\n# --- MEMORY SYSTEM ---\n# Configured in src.config\n\ndef _get_memory_content(agent_name: str) -> str:\n    \"\"\"\n    Reads the memory file for the agent.\n    Returns empty string if no memory exists.\n    \"\"\"\n    # Sanitize filename to prevent directory traversal\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    if os.path.exists(file_path):\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                return f.read()\n        except Exception as e:\n            logger.error(agent_name, f\"Error reading memory: {e}\")\n            return \"\"\n    return \"\"\n\n@mcp.tool()\nasync def note(content: str, from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Manage your persistent memory.\n    This tool OVERWRITES your existing memory file with the new content provided.\n    \n    USE THIS TO:\n    - Maintain a roadmap or to-do list.\n    - Synthesize observations and results.\n    - Prepare for future turns.\n    \n    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"", "start_line": 961, "end_line": 1010}, {"path": "src/core/server.py", "content": "    IMPORTANT:\n    - The content of this note is re-injected into your context at the start of every turn (via 'talk').\n    - You must synthesize previous memories with new ones using a SUMMARY PRINCIPLE to integrate new memories while losing as little info as possible.\n    - Do not just append blindly if you want to stay organized.\n    - Maximum size: 5000 characters.\n    \n    Args:\n        content: The text content to save.\n        from_agent: YOUR IDENTITY. You must explicitly state who you are.\n    \"\"\"\n    MAX_CHARS = 5000\n    \n    # --- Strict Turn/Identity Validation ---\n    agent_name = from_agent\n    \n    # --- 0. EXISTENCE CHECK (Fix for Typos causing Infinite Loops) ---\n    data = engine.state.load()\n    known_agents = data.get(\"agents\", {})\n    if agent_name != \"User\" and agent_name not in known_agents:\n         # Helpful hint\n         likely = [k for k in known_agents.keys() if agent_name in k]\n         hint = f\" Did you mean '{likely[0]}'?\" if likely else \"\"\n         return f\"\ud83d\udeab IDENTITY ERROR: Name '{agent_name}' not found in registry.{hint} You must use your EXACT registered name.\"\n    current_turn_holder = None\n    try:\n        data = engine.state.load()\n        current_turn_holder = data.get(\"turn\", {}).get(\"current\")\n    except:\n        pass\n        \n    if agent_name != current_turn_holder:\n         # Parallel Reload: Allow note() even if not their turn if reload_active is set\n         if data.get(\"agents\", {}).get(agent_name, {}).get(\"reload_active\"):\n             if logger: logger.log(\"RELOAD\", agent_name, \"Processing parallel reload note...\")\n         else:\n             # Same auto-repair pause as talk()\n             if logger: logger.log(\"VIOLATION\", agent_name, f\"Note() out of turn (Current: {current_turn_holder}). Pausing...\")\n             wait_result = await engine.wait_for_turn_async(agent_name, timeout_seconds=300)\n             if wait_result[\"status\"] != \"success\":\n                 return \"\ud83d\udeab SYSTEM ERROR: You called note() out of turn and timed out waiting for your turn.\"\n             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    ", "start_line": 1001, "end_line": 1050}, {"path": "src/core/server.py", "content": "             # If success, proceed (they got the turn back)\n\n    # 1. Validate Length\n    if len(content) > MAX_CHARS:\n        return f\"\ud83d\udeab ERROR: Note content too long ({len(content)} chars). Limit is {MAX_CHARS}. Please summarize and retry.\"\n        \n    # 2. Write File\n    safe_name = \"\".join([c for c in agent_name if c.isalnum() or c in (' ', '_', '-', '#')]).strip()\n    file_path = MEMORY_DIR / f\"{safe_name}.md\"\n    \n    # Read previous content for safety return\n    old_content = \"(No previous memory)\"\n    if file_path.exists():\n        try:\n            with open(file_path, \"r\", encoding=\"utf-8\") as f:\n                old_content = f.read()\n        except:\n            old_content = \"(Error reading previous memory)\"\n    \n    try:\n        with open(file_path, \"w\", encoding=\"utf-8\") as f:\n            f.write(content)\n            \n        # Log\n        logger.log(\"MEMORY\", agent_name, \"Updated memory note.\")\n        \n        # --- PARALLEL RELOAD SUPPORTED ---\n        # Agent can save note asynchronously during reload sequence.\n        # The agent must now specifically call disconnect() after note().\n        \n        # Render Note Response Template\n        return jinja_env.from_string(NOTE_RESPONSE).render(\n            agent_name=agent_name,\n            old_content=old_content\n        )\n        \n    except Exception as e:\n        return f\"\ud83d\udeab SYSTEM ERROR writing note: {e}\"\n\n\n\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"", "start_line": 1041, "end_line": 1090}, {"path": "src/core/server.py", "content": "\n@mcp.tool()\nasync def mailbox(from_agent: str, ctx: Context) -> str:\n    \"\"\"\n    Retrieves the remaining part of a truncated message.\n    Only useful if you received a \"CRITICAL: MESSAGE TRUNCATED\" alert.\n    \n    Args:\n        from_agent: Your identity (must match the truncated stream owner).\n    \"\"\"\n    if from_agent not in TRUNCATION_BUFFER:\n        return \"\ud83d\udcea Mailbox empty. No truncated messages found.\"\n        \n    data_store = TRUNCATION_BUFFER[from_agent]\n    full_content = data_store[\"content\"]\n    offset = data_store[\"offset\"]\n    \n    state = engine.state.load()\n    limit = state.get(\"config\", {}).get(\"truncation_limit\", 4096)\n    \n    # 1. If limit disabled mid-stream, flush everything\n    if limit <= 0:\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 2. Check if remaining fits\n    remaining_total = len(full_content) - offset\n    if remaining_total <= limit:\n        # Fits completely\n        chunk = full_content[offset:]\n        del TRUNCATION_BUFFER[from_agent]\n        return chunk\n        \n    # 3. Needs Truncation (AGAIN)\n    # Determine Language for Instruction\n    lang = state.get(\"config\", {}).get(\"language\", \"English\")\n    if lang in [\"fr\", \"French\"]:\n        template = \"\\n\\n\ud83d\udea8 [CRITIQUE : MESSAGE ENCORE TRONQU\u00c9]\\nLa suite a encore \u00e9t\u00e9 tronqu\u00e9e ({} caract\u00e8res restants).\\nVOUS DEVEZ OBLIGATOIREMENT RAPPELER `mailbox(from_agent='{}')` pour la suite.\"\n    else:\n        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk", "start_line": 1081, "end_line": 1130}, {"path": "src/core/server.py", "content": "        template = \"\\n\\n\ud83d\udea8 [CRITICAL: MESSAGE STILL TRUNCATED]\\nThe message is still truncated ({} chars remaining).\\nYou MUST call `mailbox(from_agent='{}')` AGAIN to read the rest.\"\n\n    # Calculate Overhead\n    dummy_overhead = len(template.format(9999999, from_agent))\n    safe_chunk_size = limit - 1 - dummy_overhead\n    \n    if safe_chunk_size <= 0:\n        chunk = full_content[offset:offset+limit]\n        TRUNCATION_BUFFER[from_agent][\"offset\"] += limit\n        return chunk\n    \n    # Get chunk\n    max_end = offset + safe_chunk_size\n    chunk = full_content[offset:max_end]\n    \n    remaining_after = len(full_content) - max_end\n    \n    # Update offset\n    TRUNCATION_BUFFER[from_agent][\"offset\"] = max_end\n    \n    # Message\n    msg = template.format(remaining_after, from_agent)\n            \n    return chunk + msg\n\n@mcp.tool()\nasync def search(query: str, glob: str = None, ctx: Context = None) -> str:\n    \"\"\"\n    Search the codebase using semantic vector search.\n    Returns the most relevant code snippets.\n    \n    Args:\n        query: The natural language query.\n        glob: Optional glob pattern (e.g. \"*.py\", \"src/*\").\n    \"\"\"\n    try:\n        # Default limit from config if not specified\n        se = _get_search_engine()\n        state = engine.state.load()\n        # Use Standard Default Y=15\n        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")", "start_line": 1121, "end_line": 1170}, {"path": "src/core/server.py", "content": "        final_limit = state.get(\"config\", {}).get(\"search\", {}).get(\"y_total\", 15)\n        \n        results = se.search(query, limit=final_limit, file_pattern=glob)\n        \n        if not results:\n            return \"No results found.\"\n            \n        output = [f\"Found {len(results)} matches for '{query}' (Limit: {final_limit}):\\n\"]\n        for r in results:\n            output.append(f\"--- {r['path']} (Lines {r['start_line']}-{r['end_line']}) ---\")\n            output.append(r['content'])\n            output.append(\"--------------------------------------------------\\n\")\n            \n        return \"\\n\".join(output)\n    except Exception as e:\n        return f\"Error executing search: {e}\"\n\nif __name__ == \"__main__\":\n    mcp.run()", "start_line": 1161, "end_line": 1179}]}